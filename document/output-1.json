[
  {
    "title": "scenic.domains.driving.actions — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/modules/scenic.domains.driving.actions.html#scenic.domains.driving.actions.SetThrottleAction",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\nHow Scenic is Compiled\nGuide to the Scenic Parser & Compiler\nScenic Grammar\nScenic Modules\nscenic.core\nscenic.domains\nscenic.domains.driving\nscenic.formats\nscenic.simulators\nscenic.syntax\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Scenic Internals scenic.domains scenic.domains.driving scenic.domains.driving.actions\n Edit on GitHub\nscenic.domains.driving.actions\n\nActions for dynamic agents in the driving domain.\n\nThese actions are automatically imported when using the driving domain.\n\nThe RegulatedControlAction is based on code from the CARLA project, licensed under the following terms:\n\nCopyright (c) 2018-2020 CVC.\n\nThis work is licensed under the terms of the MIT license. For a copy, see <https://opensource.org/licenses/MIT>.\n\nSummary of Module Members\n\nClasses\n\nOffsetAction\n\n\t\n\nTeleports actor forward (in direction of its heading) by some offset.\n\n\n\n\nRegulatedControlAction\n\n\t\n\nRegulated control of throttle, braking, and steering.\n\n\n\n\nSetBrakeAction\n\n\t\n\nSet the amount of brake.\n\n\n\n\nSetHandBrakeAction\n\n\t\n\nSet or release the hand brake.\n\n\n\n\nSetPositionAction\n\n\t\n\nTeleport an agent to the given position.\n\n\n\n\nSetReverseAction\n\n\t\n\nEngage or release reverse gear.\n\n\n\n\nSetSpeedAction\n\n\t\n\nSet the speed of an agent (keeping its heading fixed).\n\n\n\n\nSetSteerAction\n\n\t\n\nSet the steering 'angle'.\n\n\n\n\nSetThrottleAction\n\n\t\n\nSet the throttle.\n\n\n\n\nSetVelocityAction\n\n\t\n\nSet the velocity of an agent.\n\n\n\n\nSetWalkingDirectionAction\n\n\t\n\nSet the walking direction.\n\n\n\n\nSetWalkingSpeedAction\n\n\t\n\nSet the walking speed.\n\n\n\n\nSteeringAction\n\n\t\n\nAbstract class for actions usable by agents which can steer.\n\n\n\n\nSteers\n\n\t\n\nMixin protocol for agents which can steer.\n\n\n\n\nWalkingAction\n\n\t\n\nAbstract class for actions usable by agents which can walk.\n\n\n\n\nWalks\n\n\t\n\nMixin protocol for agents which can walk with a given direction and speed.\n\nMember Details\nclassSteers[source]\n\nMixin protocol for agents which can steer.\n\nSpecifically, agents must support throttling, braking, steering, setting the hand brake, and going into reverse.\n\nclassWalks[source]\n\nMixin protocol for agents which can walk with a given direction and speed.\n\nWe provide a simplistic implementation which directly sets the velocity of the agent. This implementation needs to be explicitly opted-into, since simulators may provide a more sophisticated API that properly animates pedestrians.\n\nclassSetPositionAction(pos)[source]\n\nBases: Action\n\nTeleport an agent to the given position.\n\nParameters\n:\n\npos (Vector) –\n\nclassOffsetAction(offset)[source]\n\nBases: Action\n\nTeleports actor forward (in direction of its heading) by some offset.\n\nParameters\n:\n\noffset (Vector) –\n\nclassSetVelocityAction(xVel, yVel, zVel=0)[source]\n\nBases: Action\n\nSet the velocity of an agent.\n\nParameters\n:\n\nxVel (float) –\n\nyVel (float) –\n\nzVel (float) –\n\nclassSetSpeedAction(speed)[source]\n\nBases: Action\n\nSet the speed of an agent (keeping its heading fixed).\n\nParameters\n:\n\nspeed (float) –\n\nclassSteeringAction[source]\n\nBases: Action\n\nAbstract class for actions usable by agents which can steer.\n\nSuch agents must implement the Steers protocol.\n\nclassSetThrottleAction(throttle)[source]\n\nBases: SteeringAction\n\nSet the throttle.\n\nParameters\n:\n\nthrottle (float) – Throttle value between 0 and 1.\n\nclassSetSteerAction(steer)[source]\n\nBases: SteeringAction\n\nSet the steering ‘angle’.\n\nParameters\n:\n\nsteer (float) – Steering ‘angle’ between -1 and 1.\n\nclassSetBrakeAction(brake)[source]\n\nBases: SteeringAction\n\nSet the amount of brake.\n\nParameters\n:\n\nbrake (float) – Amount of braking between 0 and 1.\n\nclassSetHandBrakeAction(handBrake)[source]\n\nBases: SteeringAction\n\nSet or release the hand brake.\n\nParameters\n:\n\nhandBrake (bool) – Whether or not the hand brake is set.\n\nclassSetReverseAction(reverse)[source]\n\nBases: SteeringAction\n\nEngage or release reverse gear.\n\nParameters\n:\n\nreverse (bool) – Whether or not the car is in reverse.\n\nclassRegulatedControlAction(throttle, steer, past_steer, max_throttle=0.5, max_brake=0.5, max_steer=0.8)[source]\n\nBases: SteeringAction\n\nRegulated control of throttle, braking, and steering.\n\nControls throttle and braking using one signal that may be positive or negative. Useful with simple controllers that output a single value.\n\nParameters\n:\n\nthrottle (float) – Control signal for throttle and braking (will be clamped as below).\n\nsteer (float) – Control signal for steering (also clamped).\n\npast_steer (float) – Previous steering signal, for regulating abrupt changes.\n\nmax_throttle (float) – Maximum value for throttle, when positive.\n\nmax_brake (float) – Maximum (absolute) value for throttle, when negative.\n\nmax_steer (float) – Maximum absolute value for steer.\n\nclassWalkingAction[source]\n\nBases: Action\n\nAbstract class for actions usable by agents which can walk.\n\nSuch agents must implement the Walks protocol.\n\nclassSetWalkingDirectionAction(heading)[source]\n\nBases: WalkingAction\n\nSet the walking direction.\n\nclassSetWalkingSpeedAction(speed)[source]\n\nBases: WalkingAction\n\nSet the walking speed.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "scenic.core.object_types — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/modules/scenic.core.object_types.html#scenic.core.object_types.Mutator",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\nHow Scenic is Compiled\nGuide to the Scenic Parser & Compiler\nScenic Grammar\nScenic Modules\nscenic.core\nscenic.core.distributions\nscenic.core.dynamics\nscenic.core.errors\nscenic.core.external_params\nscenic.core.geometry\nscenic.core.lazy_eval\nscenic.core.object_types\nscenic.core.propositions\nscenic.core.pruning\nscenic.core.regions\nscenic.core.requirements\nscenic.core.sample_checking\nscenic.core.scenarios\nscenic.core.serialization\nscenic.core.shapes\nscenic.core.simulators\nscenic.core.specifiers\nscenic.core.type_support\nscenic.core.utils\nscenic.core.vectors\nscenic.core.visibility\nscenic.core.workspaces\nscenic.domains\nscenic.formats\nscenic.simulators\nscenic.syntax\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Scenic Internals scenic.core scenic.core.object_types\n Edit on GitHub\nscenic.core.object_types\n\nImplementations of the built-in Scenic classes.\n\nDefines the 3 Scenic classes Point, OrientedPoint, and Object, and associated helper code (notably their base class Constructible, which implements the handling of property definitions and Specifier Resolution).\n\nWarning\n\nIn 2D Compatibility Mode, these classes are overwritten with 2D analogs. While we make an effort to map imports to the correct class, this only works if imports use the form import scenic.core.object_types as object_types followed by accessing object_types.Object. If you instead use from scenic.core.object_types import Object, you may get the wrong class.\n\nSummary of Module Members\n\nModule Attributes\n\nInterval\n\n\t\n\nType alias for an interval (a pair of floats).\n\n\n\n\nDimensionLimits\n\n\t\n\nType alias for limits on dimensions (a triple of intervals).\n\nFunctions\n\ndefaultSideSurface\n\n\t\n\nExtracts a side surface from the occupiedSpace of an object.\n\n\n\n\ndisableDynamicProxyFor\n\n\t\n\n\n\n\nenableDynamicProxyFor\n\n\t\n\n\n\n\nsetDynamicProxyFor\n\n\t\n\nClasses\n\nConstructible\n\n\t\n\nAbstract base class for Scenic objects.\n\n\n\n\nMutator\n\n\t\n\nAn object controlling how the mutate statement affects an Object.\n\n\n\n\nObject\n\n\t\n\nThe Scenic class Object.\n\n\n\n\nObject2D\n\n\t\n\nA 2D version of Object, used for backwards compatibility with Scenic 2.0\n\n\n\n\nOrientationMutator\n\n\t\n\nMutator adding Gaussian noise to yaw, pitch, and roll.\n\n\n\n\nOrientedPoint\n\n\t\n\nThe Scenic class OrientedPoint.\n\n\n\n\nOrientedPoint2D\n\n\t\n\nA 2D version of OrientedPoint, used for backwards compatibility with Scenic 2.0\n\n\n\n\nPoint\n\n\t\n\nThe Scenic base class Point.\n\n\n\n\nPoint2D\n\n\t\n\nA 2D version of Point, used for backwards compatibility with Scenic 2.0\n\n\n\n\nPositionMutator\n\n\t\n\nMutator adding Gaussian noise to position.\n\nMember Details\nInterval\n\nType alias for an interval (a pair of floats).\n\nalias of Tuple[float, float]\n\nDimensionLimits\n\nType alias for limits on dimensions (a triple of intervals).\n\nalias of Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float]]\n\nclassConstructible(properties, constProps=frozenset({}), _internal=False)[source]\n\nBases: Samplable\n\nAbstract base class for Scenic objects.\n\nScenic objects, which are constructed using specifiers, are implemented internally as instances of ordinary Python classes. This abstract class implements the procedure to resolve specifiers and determine values for the properties of an object, as well as several common methods supported by objects.\n\nWarning\n\nThis class is an implementation detail, and none of its methods should be called directly from a Scenic program.\n\nclassmethod_withProperties(properties, constProps=None)[source]\n\nCreate an instance with the given property values.\n\nValues of unspecified properties are determined by specifier resolution as usual.\n\nclassmethod_withSpecifiers(specifiers, constProps=None, register=True)[source]\n\nCreate an instance from the given specifiers.\n\n_copyWith(**overrides)[source]\n\nCopy this object, possibly overriding some of its properties.\n\nclassMutator[source]\n\nAn object controlling how the mutate statement affects an Object.\n\nA Mutator can be assigned to the mutator property of an Object to control the effect of the mutate statement. When mutation is enabled for such an object using that statement, the mutator’s appliedTo method is called to compute a mutated version. The appliedTo method can also decide whether to apply mutators inherited from superclasses.\n\nappliedTo(obj)[source]\n\nReturn a mutated version of the given object. Implemented by subclasses.\n\nThe mutator may inspect the mutationScale attribute of the given object to scale its effect according to the scale given in mutate O by S.\n\nReturns\n:\n\nA pair consisting of the mutated version of the object together with a Boolean indicating whether the mutator inherited from the superclass (if any) should also be applied.\n\nclassPositionMutator(stddevs)[source]\n\nBases: Mutator\n\nMutator adding Gaussian noise to position. Used by Point.\n\nAttributes\n:\n\nstddevs (tuple[float,float,float]) – standard deviation of noise for each dimension (x,y,z).\n\nclassOrientationMutator(stddevs)[source]\n\nBases: Mutator\n\nMutator adding Gaussian noise to yaw, pitch, and roll. Used by OrientedPoint.\n\nAttributes\n:\n\nstddevs (tuple[float,float,float]) – standard deviation of noise for each angle (yaw, pitch, roll).\n\nclassPoint <specifiers>[source]\n\nBases: Constructible\n\nThe Scenic base class Point.\n\nThe default mutator for Point adds Gaussian noise to position with a standard deviation given by the positionStdDev property.\n\nProperties\n:\n\nposition (Vector; dynamic) – Position of the point. Default value is the origin (0,0,0).\n\nwidth (float) – Default value 0 (only provided for compatibility with operators that expect an Object).\n\nlength (float) – Default value 0.\n\nheight (float) – Default value 0.\n\nbaseOffset (Vector) – Only provided for compatibility with the on (region | Object | vector) specifier. Default value is (0,0,0).\n\ncontactTolerance (float) – Only provided for compatibility with the specifiers that expect an Object. Default value 0.\n\nonDirection (Vector) – The direction used to determine where to place this Point on a region, when using the modifying on specifier. See the on region page for more details. Default value is None, indicating the direction will be inferred from the region this object is being placed on.\n\nvisibleDistance (float) – Distance used to determine the visible range of this object. Default value 50.\n\nviewRayDensity (float) – By default determines the number of rays used during visibility checks. This value is the density of rays per degree of visible range in one dimension. The total number of rays sent will be this value squared per square degree of this object’s view angles. This value determines the default value for viewRayCount, so if viewRayCount is overwritten this value is ignored. Default value 5.\n\nviewRayCount (None | tuple[float, float]) – The total number of horizontal and vertical view angles to be sent, or None if this value should be computed automatically. Default value None.\n\nviewRayDistanceScaling (bool) – Whether or not the number of rays should scale with the distance to the object. Ignored if viewRayCount is passed. Default value False.\n\nmutationScale (float) – Overall scale of mutations, as set by the mutate statement. Default value 0 (mutations disabled).\n\npositionStdDev (tuple[float, float, float]) – Standard deviation of Gaussian noise for each dimension (x,y,z) to be added to this object’s position when mutation is enabled with scale 1. Default value (1,1,0), mutating only the x,y values of the point.\n\npropertyvisibleRegion\n\nThe visible region of this object.\n\nThe visible region of a Point is a sphere centered at its position with radius visibleDistance.\n\ncanSee(other, occludingObjects=(), debug=False)[source]\n\nWhether or not this Point can see other.\n\nParameters\n:\n\nother – A Point, OrientedPoint, or Object to check for visibility.\n\noccludingObjects – A list of objects that can occlude visibility.\n\nReturn type\n:\n\nbool\n\nclassOrientedPoint <specifiers>[source]\n\nBases: Point\n\nThe Scenic class OrientedPoint.\n\nThe default mutator for OrientedPoint adds Gaussian noise to yaw, pitch and roll, using the three standard deviations (for yaw/pitch/roll respectively) given by the orientationStdDev property. It then also applies the mutator for Point. By default the standard deviations for pitch and roll are zero so that, by default, only yaw is mutated.\n\nProperties\n:\n\nyaw (float; dynamic) – Yaw of the OrientedPoint in radians in the local coordinate system provided by parentOrientation. Default value 0.\n\npitch (float; dynamic) – Pitch of the OrientedPoint in radians in the local coordinate system provided by parentOrientation. Default value 0.\n\nroll (float; dynamic) – Roll of the OrientedPoint in radians in the local coordinate system provided by parentOrientation. Default value 0.\n\nparentOrientation (Orientation) – The local coordinate system that the OrientedPoint’s yaw, pitch, and roll are interpreted in. Default value is the global coordinate system, where an object is flat in the XY plane, facing North.\n\norientation (Orientation; dynamic; final) – The orientation of the OrientedPoint relative to the global coordinate system. Derived from the yaw, pitch, roll, and parentOrientation of this OrientedPoint and non-overridable.\n\nheading (float; dynamic; final) – Yaw value of this OrientedPoint in the global coordinate system. Derived from orientation and non-overridable.\n\nviewAngles (tuple[float,float]) – Horizontal and vertical view angles of this OrientedPoint in radians. Horizontal view angle can be up to 2π and vertical view angle can be up to π. Values greater than these will be truncated. Default value is (2π, π)\n\norientationStdDev (tuple[float,float,float]) – Standard deviation of Gaussian noise to add to this object’s Euler angles (yaw, pitch, roll) when mutation is enabled with scale 1. Default value (5°, 0, 0), mutating only the yaw of this OrientedPoint.\n\npropertyvisibleRegion\n\nThe visible region of this object.\n\nThe visible region of an OrientedPoint restricts that of Point (a sphere with radius visibleDistance) based on the value of viewAngles. In general, it is a capped rectangular pyramid subtending an angle of viewAngles[0] horizontally and viewAngles[1] vertically, as long as those angles are less than π/2; larger angles yield various kinds of wrap-around regions. See ViewRegion for details.\n\ncanSee(other, occludingObjects=(), debug=False)[source]\n\nWhether or not this OrientedPoint can see other.\n\nParameters\n:\n\nother – A Point, OrientedPoint, or Object to check for visibility.\n\noccludingObjects – A list of objects that can occlude visibility.\n\nReturn type\n:\n\nbool\n\ndistancePast(vec)[source]\n\nDistance past a given point, assuming we’ve been moving in a straight line.\n\nclassObject <specifiers>[source]\n\nBases: OrientedPoint\n\nThe Scenic class Object.\n\nThis is the default base class for Scenic classes.\n\nProperties\n:\n\nwidth (float) – Width of the object, i.e. extent along its X axis. Default value of 1 inherited from the object’s shape.\n\nlength (float) – Length of the object, i.e. extent along its Y axis. Default value of 1 inherited from the object’s shape.\n\nheight (float) – Height of the object, i.e. extent along its Z axis. Default value of 1 inherited from the object’s shape.\n\nshape (Shape) – The shape of the object, which must be an instance of Shape. The default shape is a box, with default unit dimensions.\n\nallowCollisions (bool) – Whether the object is allowed to intersect other objects. Default value False.\n\nregionContainedIn (Region or None) – A Region the object is required to be contained in. If None, the object need only be contained in the scenario’s workspace.\n\nbaseOffset (Vector) – An offset from the position of the Object to the base of the object, used by the on (region | Object | vector) specifier. Default value is (0, 0, -self.height/2), placing the base of the Object at the bottom center of the Object’s bounding box.\n\ncontactTolerance (float) – The maximum distance this object can be away from a surface to be considered on the surface. Objects are placed at half this distance away from a point when the on (region | Object | vector) specifier or a directional specifier like (left | right) of Object [by scalar] is used. Default value 1e-4.\n\nsideComponentThresholds (DimensionLimits) – Used to determine the various sides of an object (when using the default implementation). The three interior 2-tuples represent the maximum and minimum bounds for each dimension’s (x,y,z) surface. See defaultSideSurface for details. Default value ((-0.5, 0.5), (-0.5, 0.5), (-0.5, 0.5)).\n\ncameraOffset (Vector) – Position of the camera for the can see operator, relative to the object’s position. Default (0, 0, 0).\n\nrequireVisible (bool) – Whether the object is required to be visible from the ego object. Default value False.\n\noccluding (bool) – Whether or not this object can occlude other objects. Default value True.\n\nshowVisibleRegion (bool) – Whether or not to display the visible region in the Scenic internal visualizer.\n\ncolor (tuple[float, float, float, float] or tuple[float, float, float] or None) – An optional color (with optional alpha) property that is used by the internal visualizer, or possibly simulators. All values should be between 0 and 1. Default value None\n\nvelocity (Vector; dynamic) – Velocity in dynamic simulations. Default value is the velocity determined by speed and orientation.\n\nspeed (float; dynamic) – Speed in dynamic simulations. Default value 0.\n\nangularVelocity (Vector; dynamic)\n\nangularSpeed (float; dynamic) – Angular speed in dynamic simulations. Default value 0.\n\nbehavior – Behavior for dynamic agents, if any (see Dynamic Scenarios). Default value None.\n\nlastActions – Tuple of actions taken by this agent in the last time step (an empty tuple if the object is not an agent or this is the first time step).\n\nstartDynamicSimulation()[source]\n\nHook called when the object is created in a dynamic simulation.\n\nDoes nothing by default; provided for objects to do simulator-specific initialization as needed.\n\nChanged in version 3.0: This method is called on objects created in the middle of dynamic simulations, not only objects present in the initial scene.\n\ncontainsPoint(point)[source]\n\nWhether or not the space this object occupies contains a point\n\ndistanceTo(point)[source]\n\nThe minimal distance from the space this object occupies to a given point\n\nintersects(other)[source]\n\nWhether or not this object intersects another object or region\n\npropertyvisibleRegion\n\nThe visible region of this object.\n\nThe visible region of an Object is the same as that of an OrientedPoint (see OrientedPoint.visibleRegion) except that it is offset by the value of cameraOffset (which is the zero vector by default).\n\ncanSee(other, occludingObjects=(), debug=False)[source]\n\nWhether or not this Object can see other.\n\nParameters\n:\n\nother – A Point, OrientedPoint, or Object to check for visibility.\n\noccludingObjects – A list of objects that can occlude visibility.\n\nReturn type\n:\n\nbool\n\npropertycorners\n\nA tuple containing the corners of this object’s bounding box\n\n \npropertyoccupiedSpace\n\nA region representing the space this object occupies\n\n \nproperty_isConvex\n\nWhether this object’s shape is convex\n\n \npropertyboundingBox\n\nA region representing this object’s bounding box\n\n \npropertyinradius\n\nA lower bound on the inradius of this object\n\n \npropertyplanarInradius\n\nA lower bound on the planar inradius of this object.\n\nThis is defined as the inradius of the polygon of the occupiedSpace of this object projected into the XY plane, assuming that pitch and roll are both 0.\n\n \npropertysurface\n\nA region containing the entire surface of this object\n\n \npropertyonSurface\n\nThe surface used by the on specifier.\n\nThis region is used to sample position when another object is placed on this object. By default the top surface of this object (topSurface), but can be overwritten by subclasses.\n\n \npropertytopSurface\n\nA region containing the top surface of this object\n\nFor how this surface is computed, see defaultSideSurface.\n\n \npropertyrightSurface\n\nA region containing the right surface of this object\n\nFor how this surface is computed, see defaultSideSurface.\n\n \npropertyleftSurface\n\nA region containing the left surface of this object\n\nFor how this surface is computed, see defaultSideSurface.\n\n \npropertyfrontSurface\n\nA region containing the front surface of this object\n\nFor how this surface is computed, see defaultSideSurface.\n\n \npropertybackSurface\n\nA region containing the back surface of this object\n\nFor how this surface is computed, see defaultSideSurface.\n\n \npropertybottomSurface\n\nA region containing the bottom surface of this object\n\nFor how this surface is computed, see defaultSideSurface.\n\n \nproperty_isPlanarBox\n\nWhether this object is a box aligned with the XY plane.\n\ndefaultSideSurface(occupiedSpace, dimension, positive, thresholds)[source]\n\nExtracts a side surface from the occupiedSpace of an object.\n\nThis function is the default implementation for computing a region representing a side surface of an object. This is done by keeping only the faces of the object’s occupiedSpace mesh that have normal vectors with a large/small enough x,y, or z component. For example, for the front surface of an object we would would keep all faces that had a normal vector with y component greater than thresholds[1][1] and for the back surface of an object we would keep all faces that had a normal vector with y component less than thresholds[1][0].\n\nParameters\n:\n\noccupiedSpace – The occupiedSpace region of the object to extract the side surface from.\n\ndimension – The target dimension who’s component will be checked.\n\npositive – If False, the target component must be less than the first value in the appropriate tuple. If True, the component must be greater than the second value in the appropriate tuple.\n\nthresholds – A 3-tuple of 2-tuples, one for each dimension (x,y,z), with each tuple containing the thresholds for a non-positive and positive side, respectively, in each dimension.\n\non_dimension – The on_dimension to be passed to the created surface.\n\nReturn type\n:\n\nMeshSurfaceRegion\n\nclassPoint2D <specifiers>[source]\n\nBases: Point\n\nA 2D version of Point, used for backwards compatibility with Scenic 2.0\n\n_3DClass\n\nalias of Point\n\npropertyvisibleRegion\n\nThe visible region of this 2D point.\n\nThe visible region of a Point is a disc centered at its position with radius visibleDistance.\n\nclassOrientedPoint2D <specifiers>[source]\n\nBases: Point2D, OrientedPoint\n\nA 2D version of OrientedPoint, used for backwards compatibility with Scenic 2.0\n\n_3DClass\n\nalias of OrientedPoint\n\npropertyvisibleRegion\n\nThe visible region of this 2D oriented point.\n\nThe visible region of an OrientedPoint is a sector of the disc centered at its position with radius visibleDistance, oriented along heading and subtending an angle of viewAngle.\n\nclassObject2D <specifiers>[source]\n\nBases: OrientedPoint2D, Object\n\nA 2D version of Object, used for backwards compatibility with Scenic 2.0\n\n_3DClass\n\nalias of Object\n\npropertyvisibleRegion\n\nThe visible region of this 2D object.\n\nThe visible region of a 2D Object is a circular sector as for OrientedPoint, except that the base of the sector may be offset from position by the cameraOffset property (to allow modeling cameras which are not located at the center of the object).\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "scenic.simulators.gta — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/modules/scenic.simulators.gta.html#module-scenic.simulators.gta",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\nHow Scenic is Compiled\nGuide to the Scenic Parser & Compiler\nScenic Grammar\nScenic Modules\nscenic.core\nscenic.domains\nscenic.formats\nscenic.simulators\nscenic.simulators.carla\nscenic.simulators.gta\nscenic.simulators.lgsvl\nscenic.simulators.newtonian\nscenic.simulators.utils\nscenic.simulators.webots\nscenic.simulators.xplane\nscenic.syntax\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Scenic Internals scenic.simulators scenic.simulators.gta\n Edit on GitHub\nscenic.simulators.gta\n\nScenic world model for Grand Theft Auto V (GTAV).\n\nThis interface must be used in 2D Compatibility Mode.\n\nImporting scenes generated using this model into GTA V requires a GTA V plugin, which you can find here.\n\nSubmodules\n\ncenter_detection\n\n\t\n\nThis file contains helper functions\n\n\n\n\nimg_modf\n\n\t\n\nThis file has basic image modification functions\n\n\n\n\ninterface\n\n\t\n\nPython supporting code for the GTA model.\n\n\n\n\nmap\n\n\t\n\n\n\n\nmessages\n\n\t\n\n\n\n\nmodel\n\n\t\n\nWorld model for GTA.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "scenic.simulators.gta.model — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/modules/scenic.simulators.gta.model.html#scenic.simulators.gta.model.Car",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\nHow Scenic is Compiled\nGuide to the Scenic Parser & Compiler\nScenic Grammar\nScenic Modules\nscenic.core\nscenic.domains\nscenic.formats\nscenic.simulators\nscenic.simulators.carla\nscenic.simulators.gta\nscenic.simulators.lgsvl\nscenic.simulators.newtonian\nscenic.simulators.utils\nscenic.simulators.webots\nscenic.simulators.xplane\nscenic.syntax\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Scenic Internals scenic.simulators scenic.simulators.gta scenic.simulators.gta.model\n Edit on GitHub\nscenic.simulators.gta.model\n\nWorld model for GTA.\n\nSummary of Module Members\n\nModule Attributes\n\nroadDirection\n\n\t\n\nVector field representing the nominal traffic direction at a point on the road\n\n\n\n\nroad\n\n\t\n\nRegion representing the roads in the GTA map.\n\n\n\n\ncurb\n\n\t\n\nRegion representing the curbs in the GTA map.\n\nFunctions\n\ncreatePlatoonAt\n\n\t\n\nCreate a platoon starting from the given car.\n\nClasses\n\nBus\n\n\t\n\nConvenience subclass for buses.\n\n\n\n\nCar\n\n\t\n\nScenic class for cars.\n\n\n\n\nCompact\n\n\t\n\nConvenience subclass for compact cars.\n\n\n\n\nEgoCar\n\n\t\n\nConvenience subclass with defaults for ego cars.\n\nMember Details\nroadDirection\n\nVector field representing the nominal traffic direction at a point on the road\n\nroad\n\nRegion representing the roads in the GTA map.\n\ncurb\n\nRegion representing the curbs in the GTA map.\n\nclassCar <specifiers>[source]\n\nBases: Object2D\n\nScenic class for cars.\n\nProperties\n:\n\nposition – The default position is uniformly random over the road.\n\nheading – The default heading is aligned with roadDirection, plus an offset given by roadDeviation.\n\nroadDeviation (float) – Relative heading with respect to the road direction at the Car’s position. Used by the default value for heading.\n\nmodel (CarModel) – Model of the car.\n\ncolor (Color or RGB tuple) – Color of the car.\n\nclassEgoCar <specifiers>[source]\n\nBases: Car\n\nConvenience subclass with defaults for ego cars.\n\nclassBus <specifiers>[source]\n\nBases: Car\n\nConvenience subclass for buses.\n\nclassCompact <specifiers>[source]\n\nBases: Car\n\nConvenience subclass for compact cars.\n\ncreatePlatoonAt(car, numCars, model=None, dist=Range(2.0, 8.0), shift=Range(-0.5, 0.5), wiggle=0)[source]\n\nCreate a platoon starting from the given car.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "scenic.simulators.webots — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/modules/scenic.simulators.webots.html#module-scenic.simulators.webots",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\nHow Scenic is Compiled\nGuide to the Scenic Parser & Compiler\nScenic Grammar\nScenic Modules\nscenic.core\nscenic.domains\nscenic.formats\nscenic.simulators\nscenic.simulators.carla\nscenic.simulators.gta\nscenic.simulators.lgsvl\nscenic.simulators.newtonian\nscenic.simulators.utils\nscenic.simulators.webots\nscenic.simulators.xplane\nscenic.syntax\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Scenic Internals scenic.simulators scenic.simulators.webots\n Edit on GitHub\nscenic.simulators.webots\n\nScenic world models for the Webots robotics simulator.\n\nThis module contains common code for working with Webots, e.g. parsing WBT files, as well as a generic dynamic simulator interface and world model for Webots. More detailed world models for particular types of scenarios are in submodules.\n\nSubmodules\n\nactions\n\n\t\n\nActions for dynamic agents in Webots simulations.\n\n\n\n\nguideways\n\n\t\n\nWorld model for road intersection scenarios in Webots.\n\n\n\n\nmodel\n\n\t\n\nGeneric Scenic world model for the Webots simulator.\n\n\n\n\nroad\n\n\t\n\nWorld model and associated code for traffic scenarios in Webots.\n\n\n\n\nsimulator\n\n\t\n\nInterface to Webots for dynamic simulations.\n\n\n\n\nutils\n\n\t\n\nVarious utilities for working with Webots scenarios.\n\n\n\n\nWBTLexer\n\n\t\n\n\n\n\nWBTParser\n\n\t\n\n\n\n\nWBTVisitor\n\n\t\n\n\n\n\nworld_parser\n\n\t\n\nParser for WBT files using ANTLR.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "scenic.simulators.newtonian — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/modules/scenic.simulators.newtonian.html#module-scenic.simulators.newtonian",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\nHow Scenic is Compiled\nGuide to the Scenic Parser & Compiler\nScenic Grammar\nScenic Modules\nscenic.core\nscenic.domains\nscenic.formats\nscenic.simulators\nscenic.simulators.carla\nscenic.simulators.gta\nscenic.simulators.lgsvl\nscenic.simulators.newtonian\nscenic.simulators.utils\nscenic.simulators.webots\nscenic.simulators.xplane\nscenic.syntax\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Scenic Internals scenic.simulators scenic.simulators.newtonian\n Edit on GitHub\nscenic.simulators.newtonian\n\nSimple Newtonian physics simulator.\n\nThis interface must be used in 2D Compatibility Mode.\n\nThis simulator allows dynamic scenarios to be tested without installing an external simulator. It is currently very simplistic (e.g. not modeling collisions).\n\nThe simulator provides two world models: a generic one, and a more specialized model supporting traffic scenarios using the scenic.domains.driving abstract domain.\n\nSubmodules\n\ndriving_model\n\n\t\n\nScenic world model for traffic scenarios in the Newtonian simulator.\n\n\n\n\nmodel\n\n\t\n\nScenic world model for the Newtonian simulator.\n\n\n\n\nsimulator\n\n\t\n\nNewtonian simulator implementation.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Data Types Reference — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/reference/data.html#shape",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nGeneral Notes on Syntax\nData Types Reference\nBoolean\nScalar\nVector\nHeading\nOrientation\nVector Field\nRegion\nShape\nRegion Types Reference\nDistributions Reference\nStatements Reference\nObjects and Classes Reference\nSpecifiers Reference\nOperators Reference\nBuilt-in Functions Reference\nVisibility System\nScene Generation\nExecution of Dynamic Scenarios\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Language Reference Data Types Reference\n Edit on GitHub\nData Types Reference\n\nThis page describes the primitive data types built into Scenic. In addition to these types, Scenic provides a class hierarchy for points, oriented points, and objects: see the Objects and Classes Reference.\n\nBoolean\n\nBooleans represent truth values, and can be True or False.\n\nNote\n\nThese are equivalent to the Python bool type.\n\nScalar\n\nScalars represent distances, angles, etc. as floating-point numbers, which can be sampled from various distributions.\n\nNote\n\nThese are equivalent to the Python float type; however, any context which accepts a scalar will also allow an int or a NumPy numeric type such as numpy.single (to be precise, any instance of numbers.Real is legal).\n\nVector\n\nVectors represent positions and offsets in space. They are constructed from coordinates using a length-3 list or tuple ([X, Y, Z] or (X, Y, Z). Alternatively, they can be constructed with the syntax X @ Y (inspired by Smalltalk) or a length-2 list or tuple, with an implied z value of 0. By convention, coordinates are in meters, although the semantics of Scenic does not depend on this.\n\nFor convenience, instances of Point can be used in any context where a vector is expected: so for example if P is a Point, then P offset by (1, 2) is equivalent to P.position offset by (1, 2).\n\nChanged in version 3.0: Vectors are now 3 dimensional.\n\nHeading\n\nHeadings represent yaw in the global XY plane. Scenic represents headings in radians, measured anticlockwise from North, so that a heading of 0 is due North and a heading of π/2 is due West. We use the convention that the heading of a local coordinate system is the heading of its Y-axis, so that, for example, the vector -2 @ 3 means 2 meters left and 3 ahead.\n\nFor convenience, instances of OrientedPoint can be used in any context where a heading is expected: so for example if OP is an OrientedPoint, then relative heading of OP is equivalent to relative heading of OP.heading. Since OrientedPoint is a subclass of Point, expressions involving two oriented points like OP1 relative to OP2 can be ambiguous: the polymorphic operator relative to accepts both vectors and headings, and either version could be meant here. Scenic rejects such expressions as being ambiguous: more explicit syntax like OP1.position relative to OP2 must be used instead.\n\nOrientation\n\nOrientations represent orientations in 3D space. Scenic represents orientations internally using quaternions, though for convenience they can be created using Euler angles. Scenic follows the right hand rule with the Z,X,Y order of rotations. In other words, Euler angles are given as (Yaw, Pitch, Roll), in radians, and applied in that order. To help visualize, one can consider their right hand with fingers extended orthogonally. The index finger points along positive X, the middle finger bends left along positive Y, and the thumb ends up pointing along positive Z. For rotations, align your right thumb with a positive axis and the way your fingers curl is a positive rotation.\n\nNew in version 3.0.\n\nVector Field\n\nVector fields associate an orientation to each point in space. For example, a vector field could represent the shortest paths to a destination, or the nominal traffic direction on a road (e.g. scenic.domains.driving.model.roadDirection).\n\nChanged in version 3.0: Vector fields now return an Orientation instead of a scalar heading.\n\nRegion\n\nRegions represent sets of points in space. Scenic provides a variety of ways to define regions in 2D and 3D space: meshes, rectangles, circular sectors, line segments, polygons, occupancy grids, and explicit lists of points, among others.\n\nRegions can have an associated vector field giving points in the region preferred orientations. For example, a region representing a lane of traffic could have a preferred orientation aligned with the lane, so that we can easily talk about distances along the lane, even if it curves. Another possible use of preferred orientations is to give the surface of an object normal vectors, so that other objects placed on the surface face outward by default.\n\nThe main operations available for use with all regions are:\n\nthe (vector | Object) in region operator to test containment within a region;\n\nthe visible region operator to get the part of a region which is visible from the ego;\n\nthe in region specifier to choose a position uniformly at random inside a region;\n\nthe on region specifier to choose a position like in region or to project an existing position onto the region’s surface.\n\nIf you need to perform more complex operations on regions, or are writing a world model and need to define your own regions, you will have to work with the Region class (which regions are instances of) and its subclasses for particular types of regions. These are listed in the Regions Types reference. If you are working on Scenic’s internals, see the scenic.core.regions module for full details.\n\nShape\n\nShapes represent the shape of an object, i.e., the volume it occupies modulo translation, rotation, and scaling. Shapes are represented by meshes, automatically converted to unit size and centered; Scenic considers the side of the shape facing the positive Y axis to be its front.\n\nShapes can be created from an arbitrary mesh or using one of the geometric primitives below. For convenience, a shape created with specified dimensions will set the default dimensions for any Object created with that shape. When creating a MeshShape, if no dimensions are provided then dimensions will be inferred from the mesh. MeshShape also takes an optional initial_rotation parameter, which allows directions other than the positive Y axis to be considered the front of the shape.\n\nclassMeshShape(mesh, dimensions=None, scale=1, initial_rotation=None)[source]\n\nA Shape subclass defined by a trimesh.base.Trimesh object.\n\nThe mesh passed must be a trimesh.base.Trimesh object that represents a well defined volume (i.e. the is_volume property must be true), meaning the mesh must be watertight, have consistent winding and have outward facing normals.\n\nParameters\n:\n\nmesh – A mesh object.\n\ndimensions – The raw (before scaling) dimensions of the shape. If dimensions and scale are both specified the dimensions are first set by dimensions, and then scaled by scale.\n\nscale – Scales all the dimensions of the shape by a multiplicative factor. If dimensions and scale are both specified the dimensions are first set by dimensions, and then scaled by scale.\n\ninitial_rotation – A 3-tuple containing the yaw, pitch, and roll respectively to apply when loading the mesh. Note the initial_rotation must be fixed.\n\nclassmethodfromFile(path, unify=True, **kwargs)[source]\n\nLoad a mesh shape from a file, attempting to infer filetype and compression.\n\nFor example: “foo.obj.bz2” is assumed to be a compressed .obj file. “foo.obj” is assumed to be an uncompressed .obj file. “foo” is an unknown filetype, so unless a filetype is provided an exception will be raised.\n\nParameters\n:\n\npath (str) – Path to the file to import.\n\nfiletype (str) – Filetype of file to be imported. This will be inferred if not provided. The filetype must be one compatible with trimesh.load.\n\ncompressed (bool) – Whether or not this file is compressed (with bz2). This will be inferred if not provided.\n\nbinary (bool) – Whether or not to open the file as a binary file.\n\nunify (bool) – Whether or not to attempt to unify this mesh.\n\nkwargs – Additional arguments to the MeshShape initializer.\n\nclassBoxShape(dimensions=(1, 1, 1), scale=1, initial_rotation=None)[source]\n\nA box shape with all dimensions 1 by default.\n\nclassCylinderShape(dimensions=(1, 1, 1), scale=1, initial_rotation=None, sections=24)[source]\n\nA cylinder shape with all dimensions 1 by default.\n\nclassConeShape(dimensions=(1, 1, 1), scale=1, initial_rotation=None)[source]\n\nA cone shape with all dimensions 1 by default.\n\nclassSpheroidShape(dimensions=(1, 1, 1), scale=1, initial_rotation=None)[source]\n\nA spheroid shape with all dimensions 1 by default.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "scenic.core.simulators — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/modules/scenic.core.simulators.html#scenic.core.simulators.Simulator.simulate",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\nHow Scenic is Compiled\nGuide to the Scenic Parser & Compiler\nScenic Grammar\nScenic Modules\nscenic.core\nscenic.core.distributions\nscenic.core.dynamics\nscenic.core.errors\nscenic.core.external_params\nscenic.core.geometry\nscenic.core.lazy_eval\nscenic.core.object_types\nscenic.core.propositions\nscenic.core.pruning\nscenic.core.regions\nscenic.core.requirements\nscenic.core.sample_checking\nscenic.core.scenarios\nscenic.core.serialization\nscenic.core.shapes\nscenic.core.simulators\nscenic.core.specifiers\nscenic.core.type_support\nscenic.core.utils\nscenic.core.vectors\nscenic.core.visibility\nscenic.core.workspaces\nscenic.domains\nscenic.formats\nscenic.simulators\nscenic.syntax\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Scenic Internals scenic.core scenic.core.simulators\n Edit on GitHub\nscenic.core.simulators\n\nInterface between Scenic and simulators.\n\nThis module defines the core classes Simulator and Simulation which orchestrate dynamic simulations. Each simulator interface defines subclasses of these classes for their particular simulator.\n\nOrdinary Scenic users only need to know about the top-level simulation API Simulator.simulate and the attributes of the Simulation class (in particular the result attribute, which captures information about the result of the simulation as a SimulationResult object).\n\nSummary of Module Members\n\nClasses\n\nDummySimulation\n\n\t\n\nMinimal Simulation subclass for DummySimulator.\n\n\n\n\nDummySimulator\n\n\t\n\nSimulator which does (almost) nothing, for testing and debugging purposes.\n\n\n\n\nReplayMode\n\n\t\n\nAn enumeration.\n\n\n\n\nSimulation\n\n\t\n\nA single simulation run.\n\n\n\n\nSimulationResult\n\n\t\n\nResult of running a simulation.\n\n\n\n\nSimulator\n\n\t\n\nA simulator which can execute dynamic simulations from Scenic scenes.\n\n\n\n\nTerminationType\n\n\t\n\nEnum describing the possible ways a simulation can end.\n\nExceptions\n\nDivergenceError\n\n\t\n\nException indicating simulation replay failed due to simulator nondeterminism.\n\n\n\n\nSimulationCreationError\n\n\t\n\nException indicating a simulation could not be run from the given scene.\n\n\n\n\nSimulatorInterfaceWarning\n\n\t\n\nWarning indicating an issue with the interface to an external simulator.\n\nMember Details\nexceptionSimulatorInterfaceWarning[source]\n\nBases: UserWarning\n\nWarning indicating an issue with the interface to an external simulator.\n\nexceptionSimulationCreationError[source]\n\nBases: Exception\n\nException indicating a simulation could not be run from the given scene.\n\nCan also be issued during a simulation if dynamic object creation fails.\n\nexceptionDivergenceError[source]\n\nBases: Exception\n\nException indicating simulation replay failed due to simulator nondeterminism.\n\nclassSimulator[source]\n\nBases: ABC\n\nA simulator which can execute dynamic simulations from Scenic scenes.\n\nSimulator interfaces which support dynamic simulations should implement a subclass of Simulator. An instance of the class represents a connection to the simulator suitable for running multiple simulations (not necessarily of the same Scenic program). For an example of how to implement this class, and its counterpart Simulation for individual simulations, see scenic.simulators.webots.simulator.\n\nUsers who create an instance of Simulator should call its destroy method when they are finished running simulations to allow the interface to do any necessary cleanup.\n\nsimulate(scene, maxSteps=None, maxIterations=1, *, timestep=None, verbosity=None, raiseGuardViolations=False, replay=None, enableReplay=True, enableDivergenceCheck=False, divergenceTolerance=0, continueAfterDivergence=False, allowPickle=False)[source]\n\nRun a simulation for a given scene.\n\nFor details on how simulations are run, see Execution of Dynamic Scenarios.\n\nParameters\n:\n\nscene (Scene) – Scene from which to start the simulation (sampled using Scenario.generate).\n\nmaxSteps (int) – Maximum number of time steps for the simulation, or None to not impose a time bound.\n\nmaxIterations (int) – Maximum number of rejection sampling iterations.\n\ntimestep (float) – Length of a time step in seconds, or None to use a default provided by the simulator interface. Some interfaces may not allow arbitrary time step lengths or may require the timestep to be set when creating the Simulator and not customized per-simulation.\n\nverbosity (int) – If not None, override Scenic’s global verbosity level (from the --verbosity option or scenic.setDebuggingOptions).\n\nraiseGuardViolations (bool) – Whether violations of preconditions/invariants of scenarios/behaviors should cause this method to raise an exception, instead of only rejecting the simulation (the default behavior).\n\nreplay (bytes) – If not None, must be replay data output by Simulation.getReplay: we will then replay the saved simulation rather than randomly generating one as usual. If maxSteps is larger than that of the original simulation, then once the replay is exhausted the simulation will continue to run in the usual randomized manner.\n\nenableReplay (bool) – Whether to save data from the simulation so that it can be serialized for later replay using Scenario.simulationToBytes or Simulation.getReplay. Enabled by default as the overhead is generally low.\n\nenableDivergenceCheck (bool) – Whether to save the values of every dynamic property at each time step, so that when the simulation is replayed, nondeterminism in the simulator (or replaying the simulation in the wrong simulator) can be detected. Disabled by default as this option greatly increases the size of replay objects (~100 bytes per object per step).\n\ndivergenceTolerance (float) – Amount by which a dynamic property can deviate in a replay from its original value before we consider the replay to have diverged. The default value is zero: no deviation is allowed. If finer control over divergences is required, see Simulation.valuesHaveDiverged.\n\ncontinueAfterDivergence (bool) – Whether to continue simulating after a divergence is detected instead of raising a DivergenceError. If this is true, then a divergence ends the replaying of the saved scenario but the simulation will continue in the usual randomized manner (i.e., it is as if the replay data ran out at the moment of the divergence).\n\nallowPickle (bool) – Whether to use pickle to (de)serialize custom object types. See sceneFromBytes for a discussion of when this may be needed (rarely) and its security implications.\n\nReturns\n:\n\nA Simulation object representing the completed simulation, or None if no simulation satisfying the requirements could be found within maxIterations iterations.\n\nRaises\n:\n\nSimulationCreationError – if an error occurred while trying to run a simulation (e.g. some assumption made by the simulator was violated, like trying to create an object inside another).\n\nGuardViolation – if raiseGuardViolations is true and a precondition or invariant was violated during the simulation.\n\nDivergenceError – if replaying a simulation (via the replay option) and the replay has diverged from the original; requires the original simulation to have been run with enableDivergenceCheck.\n\nSerializationError – if writing or reading replay data fails. This could happen if your scenario uses an unusual custom distribution (see sceneToBytes) or if the replayed scenario has diverged without divergence-checking enabled.\n\nChanged in version 3.0: maxIterations is now 1 by default.\n\nNew in version 3.0: The timestep argument.\n\nreplay(scene, replay, **kwargs)[source]\n\nReplay a simulation.\n\nThis convenience method simply calls simulate (and so takes all the same arguments), but makes the replay argument positional so you can write simulator.replay(scene, replay) instead of simulator.simulate(scene, replay=replay).\n\nabstractcreateSimulation(scene, **kwargs)[source]\n\nCreate a Simulation from a Scenic scene.\n\nThis should be overridden by subclasses to return instances of their own specialized subclass of Simulation. The given scene and kwargs (together making up all the arguments passed to simulate except for maxIterations) should be passed through to the initializer of that instance.\n\nChanged in version 3.0: This method is now called with all the arguments to simulate except for maxIterations; these should be passed through as described above.\n\ndestroy()[source]\n\nClean up as needed when shutting down the simulator interface.\n\nSubclasses should call the parent implementation, which will catch this method being called twice on the same Simulator.\n\nclassSimulation(scene, *, maxSteps, name, timestep, replay=None, enableReplay=True, allowPickle=False, enableDivergenceCheck=False, divergenceTolerance=0, continueAfterDivergence=False, verbosity=0)[source]\n\nBases: ABC\n\nA single simulation run.\n\nThese objects are not manipulated manually, but are created by a Simulator. Simulator interfaces should subclass this class, implementing various abstract methods to call the appropriate simulator APIs. In particular, the following methods must be implemented:\n\ncreateObjectInSimulator, to create an object;\n\nstep, to run the simulation for one time step;\n\ngetProperties, to read back the new state of an object.\n\nOther methods can be overridden if necessary, e.g. setup for initialization at the start of the simulation and destroy for cleanup afterward.\n\nChanged in version 3.0: The __init__ method of subclasses should no longer create objects; the createObjectInSimulator method will be called instead. Other initialization which needs to take place after object creation should be done in setup after calling the superclass implementation.\n\nThe arguments to __init__ are the same as those to simulate, except that maxIterations is omitted.\n\nAttributes\n:\n\ncurrentTime (int) – Number of time steps elapsed so far.\n\ntimestep (float) – Length of each time step in seconds.\n\nobjects – List of Scenic objects (instances of Object) existing in the simulation. This list will change if objects are created dynamically.\n\nagents – List of agents in the simulation. An agent is any object that has or had a behavior at any point in the simulation. The agents list may have objects appended to the end as the simulation progresses (if a non-agent object has its behavior overridden), but once an object is in the agents list its position is fixed.\n\nresult (SimulationResult) – Result of the simulation, or None if it has not yet completed. This is the primary object which should be inspected to get data out of the simulation: the other undocumented attributes of this class are for internal use only.\n\nRaises\n:\n\nRejectSimulationException – if a requirement is violated.\n\nsetup()[source]\n\nSet up the simulation to run in the simulator.\n\nSubclasses may override this method to perform custom initialization, but should call the parent implementation to create the objects in the initial scene (through createObjectInSimulator).\n\nabstractcreateObjectInSimulator(obj)[source]\n\nCreate the given object in the simulator.\n\nImplemented by subclasses. Should raise SimulationCreationError if creating the object fails.\n\nParameters\n:\n\nobj (Object) – the Scenic object to create.\n\nRaises\n:\n\nSimulationCreationError – if unable to create the object in the simulator.\n\nscheduleForAgents()[source]\n\nCompute the order for the agents to run in the next time step.\n\nThe default order is the order in which the agents were created.\n\nReturns\n:\n\nAn iterable which is a permutation of self.agents.\n\nactionsAreCompatible(agent, actions)[source]\n\nCheck whether the given actions can be taken simultaneously by an agent.\n\nThe default is to consider all actions compatible with each other, and to call Action.canBeTakenBy to determine if an agent can take an action. Subclasses should override this method as appropriate.\n\nParameters\n:\n\nagent (Object) – the agent which wants to take the given actions.\n\nactions (tuple) – tuple of actions to be taken.\n\nexecuteActions(allActions)[source]\n\nExecute the actions selected by the agents.\n\nThe default implementation calls the applyTo method of each Action to apply it to the appropriate agent. Subclasses may override this method to make additional simulator API calls as needed, but should call this implementation too or otherwise emulate its functionality.\n\nParameters\n:\n\nallActions – a defaultdict mapping each agent to a tuple of actions, with the default value being an empty tuple. The order of agents in the dict should be respected in case the order of actions matters.\n\nabstractstep()[source]\n\nRun the simulation for one step and return the next trajectory element.\n\nImplemented by subclasses. This should cause the simulator to simulate physics for self.timestep seconds.\n\nupdateObjects()[source]\n\nUpdate the positions and other properties of objects from the simulation.\n\nSubclasses likely do not need to override this method: they should implement its subroutine getProperties below.\n\nvaluesHaveDiverged(obj, prop, expected, actual)[source]\n\nDecide whether the value of a dynamic property has diverged from the replay.\n\nThe default implementation considers scalar and vector properties to have diverged if the distance between the actual and expected values is greater than self.divergenceTolerance (which is 0 by default); other types of properties use the != operator.\n\nSubclasses may override this function to provide more specialized criteria (e.g. allowing some properties to diverge more than others).\n\nParameters\n:\n\nobj (Object) – The object being considered.\n\nprop (str) – The name of the dynamic property being considered.\n\nexpected – The value of the property saved in the replay currently being run.\n\nactual – The value of the property in the current simulation.\n\nReturns\n:\n\nTrue if the actual value should be considered as having diverged from the expected one; otherwise False.\n\nabstractgetProperties(obj, properties)[source]\n\nRead the values of the given properties of the object from the simulator.\n\nImplemented by subclasses.\n\nParameters\n:\n\nobj (Object) – Scenic object in question.\n\nproperties (set) – Set of names of properties to read from the simulator. It is safe to destructively iterate through the set if you want.\n\nReturns\n:\n\nA dict mapping each of the given properties to its current value.\n\ncurrentState()[source]\n\nReturn the current state of the simulation.\n\nThe definition of ‘state’ is up to the simulator; the ‘state’ is simply saved at each time step to define the ‘trajectory’ of the simulation.\n\nThe default implementation returns a tuple of the positions of all objects.\n\npropertycurrentRealTime\n\nCurrent simulation time, in seconds.\n\ndestroy()[source]\n\nPerform any cleanup necessary to reset the simulator after a simulation.\n\nThe default implementation does nothing by default; it may be overridden by subclasses.\n\ngetReplay()[source]\n\nEncode this simulation to a bytes object for future replay.\n\nRequires that the simulation was run with enableReplay=True (the default).\n\nclassReplayMode(value)[source]\n\nBases: IntFlag\n\nAn enumeration.\n\nclassDummySimulator(drift=0)[source]\n\nBases: Simulator\n\nSimulator which does (almost) nothing, for testing and debugging purposes.\n\nTo allow testing the change of dynamic properties over time, all objects drift upward by drift every time step.\n\nclassDummySimulation(scene, drift=0, **kwargs)[source]\n\nBases: Simulation\n\nMinimal Simulation subclass for DummySimulator.\n\nclassTerminationType(value)[source]\n\nBases: Enum\n\nEnum describing the possible ways a simulation can end.\n\ntimeLimit= 'reached simulation time limit'\n\nSimulation reached the specified time limit.\n\nscenarioComplete= 'the top-level scenario finished'\n\nThe top-level scenario finished executing.\n\n(Either its compose block completed, one of its termination conditions was met, or it was terminated with terminate.)\n\nsimulationTerminationCondition= 'a simulation termination condition was met'\n\nA user-specified simulation termination condition was met.\n\nterminatedByMonitor= 'a monitor terminated the simulation'\n\nA monitor used terminate simulation to end the simulation.\n\nterminatedByBehavior= 'a behavior terminated the simulation'\n\nA dynamic behavior used terminate simulation to end the simulation.\n\nclassSimulationResult(trajectory, actions, terminationType, terminationReason, records)[source]\n\nResult of running a simulation.\n\nAttributes\n:\n\ntrajectory – A tuple giving for each time step the simulation’s ‘state’: by default the positions of every object. See Simulation.currentState.\n\nfinalState – The last ‘state’ of the simulation, as above.\n\nactions – A tuple giving for each time step a dict specifying for each agent the (possibly-empty) tuple of actions it took at that time step.\n\nterminationType (TerminationType) – The way the simulation ended.\n\nterminationReason (str) – A human-readable string giving the reason why the simulation ended, possibly including debugging info.\n\nrecords (dict) – For each record statement, the value or time series of values its expression took during the simulation.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Specifiers Reference — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/reference/specifiers.html#left-of-object",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nGeneral Notes on Syntax\nData Types Reference\nRegion Types Reference\nDistributions Reference\nStatements Reference\nObjects and Classes Reference\nSpecifiers Reference\nGeneral Specifiers\nPosition Specifiers\nat vector\nin region\ncontained in region\non (region | Object | vector)\noffset by vector\noffset along direction by vector\nbeyond vector by (vector | scalar) [from (vector | OrientedPoint)]\nvisible [from (Point | OrientedPoint)]\nnot visible [from (Point | OrientedPoint)]\n(left | right) of (vector) [by scalar]\n(left | right) of OrientedPoint [by scalar]\n(left | right) of Object [by scalar]\n(ahead of | behind) vector [by scalar]\n(ahead of | behind) OrientedPoint [by scalar]\n(ahead of | behind) Object [by scalar]\n(above | below) vector [by scalar]\n(above | below) OrientedPoint [by scalar]\n(above | below) Object [by scalar]\nfollowing vectorField [from vector] for scalar\nOrientation Specifiers\nSpecifier Resolution\nOperators Reference\nBuilt-in Functions Reference\nVisibility System\nScene Generation\nExecution of Dynamic Scenarios\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Language Reference Specifiers Reference\n Edit on GitHub\nSpecifiers Reference\n\nSpecifiers are used to define the properties of an object when a Scenic class is instantiated. This page describes all the specifiers built into Scenic, and the procedure used to resolve a set of specifiers into an assignment of values to properties.\n\nEach specifier assigns values to one or more properties of an object, as a function of the arguments of the specifier and possibly other properties of the object assigned by other specifiers. For example, the left of X by Y specifier assigns the position property of the object being defined so that the object is a distance Y to the left of X: this requires knowing the width of the object first, so we say the left of specifier specifies the position property and depends on the width property.\n\nIn fact, the left of specifier also specifies the parentOrientation property (to be the orientation of X), but it does this with a lower priority. Multiple specifiers can specify the same property, but only the specifier that specifies the property with the highest priority is used. If a property is specified multiple times with the same priority, an ambiguity error is raised. We represent priorities as integers, with priority 1 being the highest and larger integers having progressively lower priorities (e.g. priority 2 supersedes priority 3). When a specifier specifies a property with a priority lower than 1, we say it optionally specifies the property, since it can be overridden (for example using the with specifier), whereas a specifier specifying the property with priority 1 cannot be overridden.\n\nCertain specifiers can also modify already-specified values. These modifying specifiers do not cause an ambiguity error as above if another specifier specifies the same property with the same priority: they take the already-specified value and manipulate it in some way (potentially also specifying other properties as usual). Note that no property can be modified twice. The only modifying specifier currently in Scenic is on region, which can be used either as a standard specifier or a modifying specifier (the modifying version projects the already-specified position onto the given region – see below).\n\nThe Specifier Resolution process works out which specifier determines each property of an object, as well as an appropriate order in which to evaluate the specifiers so that dependencies have already been computed when needed.\n\nGeneral Specifiers\nwith property value\n\nSpecifies:\n\nthe given property, with priority 1\n\nDependencies: None\n\nAssigns the given property to the given value. This is currently the only specifier available for properties other than position and orientation.\n\nPosition Specifiers\n\nIllustration of the beyond, behind, and offset by specifiers. Each OrientedPoint (e.g. P) is shown as a bold arrow.\n\nat vector\n\nSpecifies:\n\nposition with priority 1\n\nDependencies: None\n\nPositions the object at the given global coordinates.\n\nin region\n\nSpecifies:\n\nposition with priority 1\n\nparentOrientation with priority 3 (if the region has a preferred orientation)\n\nDependencies: None\n\nPositions the object uniformly at random in the given Region. If the Region has a preferred orientation (a vector field), also specifies parentOrientation to be equal to that orientation at the object’s position.\n\ncontained in region\n\nSpecifies:\n\nposition with priority 1\n\nregionContainedIn with priority 1\n\nparentOrientation with priority 3 (if the region has a preferred orientation)\n\nDependencies: None\n\nLike in region, but also enforces that the object be entirely contained in the given Region.\n\non (region | Object | vector)\n\nSpecifies:\n\nposition with priority 1; modifies existing value, if any\n\nparentOrientation with priority 2 (if the region has a preferred orientation)\n\nDependencies: baseOffset • contactTolerance • onDirection\n\nIf position is not already specified with priority 1, positions the base of the object uniformly at random in the given Region, on the onSurface of the given Object, or with the base of the object at the given vector. The position is always offset by half of contactTolerance (to avoid a collision). The base of the object is determined by adding the object’s baseOffset to its position.\n\nIf instead position has already been specified with priority 1, then its value is modified by projecting it onto the given region (or the onSurface of the given object). Note that this modifying version of the specifier does not accept a vector. More precisely, we find the closest point in the region along onDirection (or its negation 1), and place the base of the object at that point. If onDirection is not specified, a default value is inferred from the region. A region can either specify a default value to be used, or for volumes straight up is used and for surfaces the mean of the face normal values is used (weighted by the area of the faces).\n\nIf the region has a preferred orientation (a vector field), parentOrientation is specified to be equal to that orientation at the object’s position (whether or not this specifier is being used as a modifying specifier). Note that this is done with higher priority than all other specifiers which optionally specify parentOrientation, and in particular the ahead of specifier and its variants: therefore the code new Object ahead of taxi by 100, on road aligns the new object with the road at the point 100 m ahead of the taxi rather than with the taxi itself (while also using projection to ensure the new object is on the surface of the road rather than under or over it if the road isn’t flat).\n\n[1]\n\nThis allows for natural projection even when an object is below the desired surface, such as placing a car, ahead of another car, on an uphill road.\n\noffset by vector\n\nSpecifies:\n\nposition with priority 1\n\nparentOrientation with priority 3\n\nDependencies: None\n\nPositions the object at the given coordinates in the local coordinate system of ego (which must already be defined). Also specifies parentOrientation to be equal to the ego’s orientation.\n\nNew in version 3.0: offset by now specifies parentOrientation, whereas previously it did not optionally specify heading.\n\noffset along direction by vector\n\nSpecifies:\n\nposition with priority 1\n\nparentOrientation with priority 3\n\nDependencies: None\n\nPositions the object at the given coordinates in a local coordinate system centered at ego and oriented along the given direction (which can be a Heading, an Orientation, or a Vector Field). Also specifies parentOrientation to be equal to the ego’s orientation.\n\nbeyond vector by (vector | scalar) [from (vector | OrientedPoint)]\n\nSpecifies:\n\nposition with priority 1\n\nparentOrientation with priority 3\n\nDependencies: None\n\nPositions the object at coordinates given by the second vector, in a local coordinate system centered at the first vector and oriented along the line of sight from the third vector (i.e. an orientation of (0,0,0) in the local coordinate system faces directly away from the third vector). If the second argument is a scalar D instead of a vector, it is interpreted as the vector (0, D, 0): thus beyond X by D from Y places the new object a distance of D behind X from the perspective of Y. If no third argument is provided, it is assumed to be the ego.\n\nThe value of parentOrientation is specified to be the orientation of the third argument if it is an OrientedPoint (including Object such as ego); otherwise the global coordinate system is used. For example, beyond taxi by (1, 3, 0) means 3 meters behind the taxi and one meter to the right as viewed by the ego.\n\nvisible [from (Point | OrientedPoint)]\n\nSpecifies:\n\nposition with priority 3\n\nalso adds a requirement (see below)\n\nDependencies: regionContainedIn\n\nRequires that this object is visible from the ego or the given Point/OrientedPoint. See the Visibility System reference for a discussion of the visibility model.\n\nAlso optionally specifies position to be uniformly random over all points that could result in a visible object (note that the above requirement will ensure the object is in fact visible).\n\nChanged in version 3.0: This specifier now specifies position uniformly randomly over all points that could result in a visible object. This allows for objects whose position might be out of the visible region, but which have a portion of their occupied space visible (e.g. a corner that is visible). With the previous semantics, such configurations would never be generated because the center of the object was required to be visible.\n\nNote\n\nAs an implementation detail, position is initially set to be sampled from everywhere (or the workspace if one has been set). Scenic will then attempt to further restrict the sample region via various pruning techniques, but sometimes this is not possible. If this occurs and Scenic has not been able to further restrict the sampled region from everywhere, an error will be raised at compile time. The simplest way to remedy this is by setting a workspace or specifying position with a higher priority using a different specifier.\n\nnot visible [from (Point | OrientedPoint)]\n\nSpecifies:\n\nposition with priority 3\n\nalso adds a requirement (see below)\n\nDependencies: regionContainedIn\n\nRequires that this object is not visible from the ego or the given Point/OrientedPoint.\n\nSimilarly to visible [from (Point | OrientedPoint)], this specifier can optionally position the object uniformly at random over all points that could result in a non-visible object (note that the above requirement will ensure the object is in fact not visible).\n\nChanged in version 3.0: This specifier now specifies position uniformly randomly over all points that could result in a non-visible object. This disallows objects whose position is out of the visible region, but which have a portion of their occupied space visible (e.g. a corner that is visible). With the previous semantics, such configurations would sometimes be generated because only the center of the object was required to be non-visible.\n\n(left | right) of (vector) [by scalar]\n\nSpecifies:\n\nposition with priority 1\n\nDependencies: width • orientation\n\nWithout the optional by scalar, positions the object immediately to the left/right of the given position; i.e., so that the midpoint of the right/left side of the object’s bounding box is at that position. If by scalar is used, the object is placed further to the left/right by the given distance.\n\n(left | right) of OrientedPoint [by scalar]\n\nSpecifies:\n\nposition with priority 1\n\nparentOrientation with priority 3\n\nDependencies: width\n\nPositions the object to the left/right of the given OrientedPoint. Also inherits parentOrientation from the given OrientedPoint.\n\n(left | right) of Object [by scalar]\n\nSpecifies:\n\nposition with priority 1\n\nparentOrientation with priority 3\n\nDependencies: width • contactTolerance\n\nPositions the object to the left/right of the given Object. This accounts for both objects’ dimensions, placing them so that the distance between their bounding boxes is exactly the desired scalar distance (or contactTolerance if by scalar is not used). Also inherits parentOrientation from the given OrientedPoint.\n\n(ahead of | behind) vector [by scalar]\n\nSpecifies:\n\nposition with priority 1\n\nDependencies: length • orientation\n\nWithout the optional by scalar, positions the object immediately ahead of/behind the given position; i.e., so that the midpoint of the front/back side of the object’s bounding box is at that position. If by scalar is used, the object is placed further ahead/behind by the given distance.\n\n(ahead of | behind) OrientedPoint [by scalar]\n\nSpecifies:\n\nposition with priority 1\n\nparentOrientation with priority 3\n\nDependencies: length\n\nPositions the object ahead of/behind the given OrientedPoint. Also inherits parentOrientation from the given OrientedPoint.\n\n(ahead of | behind) Object [by scalar]\n\nSpecifies:\n\nposition with priority 1\n\nparentOrientation with priority 3\n\nDependencies: length • contactTolerance\n\nPositions the object ahead of/behind the given Object. This accounts for both objects’ dimensions, placing them so that the distance between their bounding boxes is exactly the desired scalar distance (or contactTolerance if by scalar is not used). Also inherits parentOrientation from the given OrientedPoint.\n\n(above | below) vector [by scalar]\n\nSpecifies:\n\nposition with priority 1\n\nDependencies: height • orientation\n\nWithout the optional by scalar, positions the object immediately above/below the given position; i.e., so that the midpoint of the top/bottom side of the object’s bounding box is at that position. If by scalar is used, the object is placed further above/below by the given distance.\n\n(above | below) OrientedPoint [by scalar]\n\nSpecifies:\n\nposition with priority 1\n\nparentOrientation with priority 3\n\nDependencies: height\n\nPositions the object above/below the given OrientedPoint. Also inherits parentOrientation from the given OrientedPoint.\n\n(above | below) Object [by scalar]\n\nSpecifies:\n\nposition with priority 1\n\nparentOrientation with priority 3\n\nDependencies: height • contactTolerance\n\nPositions the object above/below the given Object. This accounts for both objects’ dimensions, placing them so that the distance between their bounding boxes is exactly the desired scalar distance (or contactTolerance if by scalar is not used). Also inherits parentOrientation from the given OrientedPoint.\n\nfollowing vectorField [from vector] for scalar\n\nSpecifies:\n\nposition with priority 1\n\nparentOrientation with priority 3\n\nDependencies: None\n\nPositions the object at a point obtained by following the given Vector Field for the given distance starting from ego (or the position optionally provided with from vector). Specifies parentOrientation to be the orientation of the vector field at the resulting point.\n\nNote\n\nThis specifier uses a forward Euler approximation of the continuous vector field. The choice of step size can be customized for individual fields: see the documentation of Vector Field. If necessary, you can also call the underlying method VectorField.followFrom directly.\n\nOrientation Specifiers\nfacing orientation\n\nSpecifies:\n\nyaw with priority 1\n\npitch with priority 1\n\nroll with priority 1\n\nDependencies: parentOrientation\n\nSets the object’s yaw, pitch, and roll so that its orientation in global coordinates is equal to the given orientation. If a single scalar is given, it is interpreted as a Heading: so for example facing 45 deg orients the object in the XY plane, facing northwest. If a triple of scalars is given, it is interpreted as a triple of global Euler angles: so for example facing (45 deg, 90 deg, 0) would orient the object to face northwest as above but then apply a 90° pitch upwards.\n\nfacing vectorField\n\nSpecifies:\n\nyaw with priority 1\n\npitch with priority 1\n\nroll with priority 1\n\nDependencies: position • parentOrientation\n\nSets the object’s yaw, pitch, and roll so that its orientation in global coordinates is equal to the orientation provided by the given Vector Field at the object’s position.\n\nfacing (toward | away from) vector\n\nSpecifies:\n\nyaw with priority 1\n\nDependencies: position • parentOrientation\n\nSets the object’s yaw so that it faces toward/away from the given position (thereby depending on the object’s position).\n\nfacing directly (toward | away from) vector\n\nSpecifies:\n\nyaw with priority 1\n\npitch with priority 1\n\nDependencies: position • parentOrientation\n\nSets the object’s yaw and pitch so that it faces directly toward/away from the given position (thereby depending on the object’s position).\n\napparently facing heading [from vector]\n\nSpecifies:\n\nyaw with priority 1\n\nDependencies: position • parentOrientation\n\nSets the yaw of the object so that it has the given heading with respect to the line of sight from ego (or the from vector). For example, if the ego is in the XY plane, then apparently facing 90 deg orients the new object so that the ego’s camera views its left side head-on.\n\nSpecifier Resolution\n\nSpecifier resolution is the process of determining, given the set of specifiers used to define an object, which properties each specifier should determine and what order to evaluate the specifiers in. As each specifier can specify multiple properties with various priorities, and can depend on the results of other specifiers, this process is somewhat non-trivial. Assuming there are no cyclic dependencies or conflicts, the process will conclude with each property being determined by its unique highest-priority specifier if one exists (possibly modified by a modifying specifier), and otherwise by its default value, with default values from subclasses overriding those in superclasses.\n\nThe full procedure, given a set of specifiers S used to define an instance of class C, works as follows:\n\nIf a property is specified at the same priority level by multiple specifiers in S, an ambiguity error is raised.\n\nThe set of properties P for the new object is found by combining the properties specified by all members of S with the properties inherited from the class C.\n\nDefault value specifiers from C (or if not overridden, from its superclasses) are added to S as needed so that each property in P is paired with a unique non-modifying specifier in S specifying it (taking the highest-priority specifier, if there are multiple), plus up to one modifying specifier modifying it.\n\nThe dependency graph of the specifiers S is constructed (with edges from each specifier to the others which depend on its results). If it is cyclic, an error is raised.\n\nThe graph is topologically sorted and the specifiers are evaluated in this order to determine the values of all properties P of the new object.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Statements Reference — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/reference/statements.html#monitordef",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nGeneral Notes on Syntax\nData Types Reference\nRegion Types Reference\nDistributions Reference\nStatements Reference\nCompound Statements\nSimple Statements\nDynamic Statements\nObjects and Classes Reference\nSpecifiers Reference\nOperators Reference\nBuilt-in Functions Reference\nVisibility System\nScene Generation\nExecution of Dynamic Scenarios\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Language Reference Statements Reference\n Edit on GitHub\nStatements Reference\nCompound Statements\nClass Definition\nclass <name>[(<superclass>)]:\n    [<property>: <value>]*\n\n\nDefines a Scenic class. If a superclass is not explicitly specified, Object is used (see Objects and Classes Reference). The body of the class defines a set of properties its objects have, together with default values for each property. Properties are inherited from superclasses, and their default values may be overridden in a subclass. Default values may also use the special syntax self.property to refer to one of the other properties of the same object, which is then a dependency of the default value. The order in which to evaluate properties satisfying all dependencies is computed (and cyclic dependencies detected) during Specifier Resolution.\n\nScenic classes may also define attributes and methods in the same way as Python classes.\n\nBehavior Definition\nbehavior <name>(<arguments>):\n    [precondition: <boolean>]*\n    [invariant: <boolean>]*\n    <statement>+\n\n\nDefines a dynamic behavior, which can be assigned to a Scenic object by setting its behavior property using the with behavior behavior specifier; this makes the object an agent. See our tutorial on Dynamic Scenarios for examples of how to write behaviors.\n\nBehavior definitions have the same form as function definitions, with an argument list and a body consisting of one or more statements; the body may additionally begin with definitions of preconditions and invariants. Preconditions are checked when a behavior is started, and invariants are checked at every time step of the simulation while the behavior is executing (including time step zero, like preconditions, but not including time spent inside sub-behaviors: this allows sub-behaviors to break and restore invariants before they return).\n\nThe body of a behavior executes in parallel with the simulation: in each time step, it must either take specified action(s) or wait and perform no actions. After each take or wait statement, the behavior’s execution is suspended, the simulation advances one step, and the behavior is then resumed. It is thus an error for a behavior to enter an infinite loop which contains no take or wait statements (or do statements invoking a sub-behavior; see below): the behavior will never yield control to the simulator and the simulation will stall.\n\nBehaviors end naturally when their body finishes executing (or if they return): if this happens, the agent performing the behavior will take no actions for the rest of the scenario. Behaviors may also terminate the current scenario, ending it immediately.\n\nBehaviors may invoke sub-behaviors, optionally for a limited time or until a desired condition is met, using do statements. It is also possible to (temporarily) interrupt the execution of a sub-behavior under certain conditions and resume it later, using try-interrupt statements.\n\nMonitor Definition\nmonitor <name>(<arguments>):\n    <statement>+\n\n\nDefines a type of monitor, which can be run in parallel with the simulation like a dynamic behavior. Monitors are not associated with an Object and cannot take actions, but can wait to wait for the next time step (or use terminate or terminate simulation to end the scenario/simulation). A monitor can be instantiated in a scenario with the require monitor statement.\n\nThe main purpose of monitors is to evaluate complex temporal properties that are not expressible using the temporal operators available for require LTL formula statements. They can maintain state and use require to enforce requirements depending on that state. For examples of monitors, see our tutorial on Dynamic Scenarios.\n\nChanged in version 3.0: Monitors may take arguments, and must be explicitly instantiated using a require monitor statement.\n\nModular Scenario Definition\nscenario <name>(<arguments>):\n    [precondition: <boolean>]*\n    [invariant: <boolean>]*\n    [setup:\n        <statement>+]\n    [compose:\n        <statement>+]\n\nscenario <name>(<arguments>):\n    <statement>+\n\n\nDefines a Scenic modular scenario. Scenario definitions, like behavior definitions, may include preconditions and invariants. The body of a scenario consists of two optional parts: a setup block and a compose block. The setup block contains code that runs once when the scenario begins to execute, and is a list of statements like a top-level Scenic program (so it may create objects, define requirements, etc.). The compose block orchestrates the execution of sub-scenarios during a dynamic scenario, and may use do and any of the other statements allowed inside behaviors (except take, which only makes sense for an individual agent). If a modular scenario does not use preconditions, invariants, or sub-scenarios (i.e., it only needs a setup block) it may be written in the second form above, where the entire body of the scenario comprises the setup block.\n\nSee also\n\nOur tutorial on Composing Scenarios gives many examples of how to use modular scenarios.\n\nTry-Interrupt Statement\ntry:\n    <statement>+\n[interrupt when <boolean>:\n    <statement>+]*\n[except <exception> [as <name>]:\n    <statement>+]*\n\n\nA try-interrupt statement can be placed inside a behavior (or compose block of a modular scenario) to run a series of statements, including invoking sub-behaviors with do, while being able to interrupt at any point if given conditions are met. When a try-interrupt statement is encountered, the statements in the try block are executed. If at any time step one of the interrupt conditions is met, the corresponding interrupt block (its handler) is entered and run. Once the interrupt handler is complete, control is returned to the statement that was being executed under the try block.\n\nIf there are multiple interrupt clauses, successive clauses take precedence over those which precede them; furthermore, during execution of an interrupt handler, successive interrupt clauses continue to be checked and can interrupt the handler. Likewise, if try-interrupt statements are nested, the outermost statement takes precedence and can interrupt the inner statement at any time. When one handler interrupts another and then completes, the original handler is resumed (and it may even be interrupted again before control finally returns to the try block).\n\nThe try-interrupt statement may conclude with any number of except blocks, which function identically to their Python counterparts (though Scenic does not allow except* blocks).\n\nSimple Statements\n\nThe following statements can occur throughout a Scenic program unless otherwise stated.\n\nmodel name\n\nSelect a world model to use for this scenario. The statement model X is equivalent to from X import * except that X can be replaced using the --model command-line option or the model keyword argument to the top-level APIs. When writing simulator-agnostic scenarios, using the model statement is preferred to a simple import since a more specific world model for a particular simulator can then be selected at compile time.\n\nimport module\n\nImport a Scenic or Python module. This statement behaves as in Python, but when importing a Scenic module it also imports any objects created and requirements imposed in that module. Scenic also supports the form from module import identifier, ... , which as in Python imports the module plus one or more identifiers from its namespace.\n\nparam name = value, …\n\nDefines one or more global parameters of the scenario. These have no semantics in Scenic, simply having their values included as part of the generated Scene, but provide a general-purpose way to encode arbitrary global information.\n\nIf multiple param statements define parameters with the same name, the last statement takes precedence, except that Scenic world models imported using the model statement do not override existing values for global parameters. This allows models to define default values for parameters which can be overridden by particular scenarios. Global parameters can also be overridden at the command line using the --param option, or from the top-level API using the params argument to scenic.scenarioFromFile.\n\nTo access global parameters within the scenario itself, you can read the corresponding attribute of the globalParameters object. For example, if you declare param weather = 'SUNNY', you could then access this parameter later in the program via globalParameters.weather. If the parameter was not overridden, this would evaluate to 'SUNNY'; if Scenic was run with the command-line option --param weather SNOW, it would evaluate to 'SNOW' instead.\n\nSome simulators provide global parameters whose names are not valid identifiers in Scenic. To support giving values to such parameters without renaming them, Scenic allows the names of global parameters to be quoted strings, as in this example taken from an X-Plane scenario:\n\nparam simulation_length = 30\nparam 'sim/weather/cloud_type[0]' = DiscreteRange(0, 5)\nparam 'sim/weather/rain_percent' = 0\n\nrequire boolean\n\nDefines a hard requirement, requiring that the given condition hold in all instantiations of the scenario. This is equivalent to an “observe” statement in other probabilistic programming languages.\n\nrequire[number] boolean\n\nDefines a soft requirement; like require above but enforced only with the given probability, thereby requiring that the given condition hold with at least that probability (which must be a literal number, not an expression). For example, require[0.75] ego in parking_lot would require that the ego be in the parking lot at least 75% percent of the time.\n\nrequire LTL formula\n\nDefines a temporal requirement, requiring that the given Linear Temporal Logic formula hold in a dynamic scenario. See Temporal Operators for the list of supported LTL operators.\n\nNote that an expression that does not use any temporal operators is evaluated only in the current time step. So for example:\n\nrequire A and always B will only require that A hold at time step zero, while B must hold at every time step (note that this is the same behavior you would get if you wrote require A and require always B separately);\n\nrequire (always A) implies B requires that if A is true at every time step, then B must be true at time step zero;\n\nrequire always A implies B requires that in every time step when A is true, B must also be true (since B is within the scope of the always operator).\n\nrequire monitor monitor\n\nRequire a condition encoded by a monitor hold during the scenario. See Monitor Definition for how to define types of monitors.\n\nIt is legal to create multiple instances of a monitor with varying parameters. For example:\n\nmonitor ReachesBefore(obj1, region, obj2):\n    reached = False\n    while not reached:\n        if obj1 in region:\n            reached = True\n        else:\n            require obj2 not in region\n            wait\n\nrequire monitor ReachesBefore(ego, goal, racecar2)\nrequire monitor ReachesBefore(ego, goal, racecar3)\n\nterminate when boolean\n\nTerminates the scenario when the provided condition becomes true. If this statement is used in a modular scenario which was invoked from another scenario, only the current scenario will end, not the entire simulation.\n\nterminate simulation when boolean\n\nThe same as terminate when, except terminates the entire simulation even when used inside a sub-scenario (so there is no difference between the two statements when used at the top level).\n\nterminate after scalar (seconds | steps)\n\nLike terminate when above, but terminates the scenario after the given amount of time. The time limit can be an expression, but must be a non-random value.\n\nmutate identifier, … [by scalar]\n\nEnables mutation of the given list of objects (any Point, OrientedPoint, or Object), with an optional scale factor (default 1). If no objects are specified, mutation applies to every Object already created.\n\nThe default mutation system adds Gaussian noise to the position and heading properties, with standard deviations equal to the scale factor times the positionStdDev and headingStdDev properties.\n\nNote\n\nUser-defined classes may specify custom mutators to allow mutation to apply to properties other than position and heading. This is done by providing a value for the mutator property, which should be an instance of Mutator. Mutators inherited from superclasses (such as the default position and heading mutators from Point and OrientedPoint) will still be applied unless the new mutator disables them; see Mutator for details.\n\nrecord [initial | final] value [as name]\n\nRecord the value of an expression during each simulation. The value can be recorded at the start of the simulation (initial), at the end of the simulation (final), or at every time step (if neither initial nor final is specified). The recorded values are available in the records dictionary of SimulationResult: its keys are the given names of the records (or synthesized names if not provided), and the corresponding values are either the value of the recorded expression or a tuple giving its value at each time step as appropriate. For debugging, the records can also be printed out using the --show-records command-line option.\n\nDynamic Statements\n\nThe following statements are valid only in dynamic behaviors, monitors, and compose blocks.\n\ntake action, …\n\nTakes the action(s) specified and pass control to the simulator until the next time step. Unlike wait, this statement may not be used in monitors or modular scenarios, since these do not take actions.\n\nwait\n\nTake no actions this time step.\n\nterminate\n\nImmediately end the scenario. As for terminate when, if this statement is used in a modular scenario which was invoked from another scenario, only the current scenario will end, not the entire simulation. Inside a behavior being run by an agent, the “current scenario” for this purpose is the scenario which created the agent.\n\nterminate simulation\n\nImmediately end the entire simulation.\n\ndo behavior/scenario, …\n\nRun one or more sub-behaviors or sub-scenarios in parallel. This statement does not return until all invoked sub-behaviors/scenarios have completed.\n\ndo behavior/scenario, … until boolean\n\nAs above, except the sub-behaviors/scenarios will terminate when the condition is met.\n\ndo behavior/scenario for scalar (seconds | steps)\n\nRun sub-behaviors/scenarios for a set number of simulation seconds/time steps. This statement can return before that time if all the given sub-behaviors/scenarios complete.\n\ndo choose behavior/scenario, …\n\nRandomly pick one of the given behaviors/scenarios whose preconditions are satisfied, and run it. If no choices are available, the simulation is rejected.\n\nThis statement also allows the more general form do choose { behaviorOrScenario: weight, ... }, giving weights for each choice (which need not add up to 1). Among all choices whose preconditions are satisfied, this picks a choice with probability proportional to its weight.\n\ndo shuffle behavior/scenario, …\n\nLike do choose above, except that when the chosen sub-behavior/scenario completes, a different one whose preconditions are satisfied is chosen to run next, and this repeats until all the sub-behaviors/scenarios have run once. If at any point there is no available choice to run (i.e. we have a deadlock), the simulation is rejected.\n\nThis statement also allows the more general form do shuffle { behaviorOrScenario: weight, ... }, giving weights for each choice (which need not add up to 1). Each time a new sub-behavior/scenario needs to be selected, this statement finds all choices whose preconditions are satisfied and picks one with probability proportional to its weight.\n\nabort\n\nUsed in an interrupt handler to terminate the current try-interrupt statement.\n\noverride object specifier, …\n\nOverride one or more properties of an object, e.g. its behavior, for the duration of the current scenario. The properties will revert to their previous values when the current scenario terminates. It is illegal to override dynamic properties, since they are set by the simulator each time step and cannot be mutated manually.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "scenic.core.regions — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/modules/scenic.core.regions.html#scenic.core.regions.RectangularRegion",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\nHow Scenic is Compiled\nGuide to the Scenic Parser & Compiler\nScenic Grammar\nScenic Modules\nscenic.core\nscenic.core.distributions\nscenic.core.dynamics\nscenic.core.errors\nscenic.core.external_params\nscenic.core.geometry\nscenic.core.lazy_eval\nscenic.core.object_types\nscenic.core.propositions\nscenic.core.pruning\nscenic.core.regions\nscenic.core.requirements\nscenic.core.sample_checking\nscenic.core.scenarios\nscenic.core.serialization\nscenic.core.shapes\nscenic.core.simulators\nscenic.core.specifiers\nscenic.core.type_support\nscenic.core.utils\nscenic.core.vectors\nscenic.core.visibility\nscenic.core.workspaces\nscenic.domains\nscenic.formats\nscenic.simulators\nscenic.syntax\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Scenic Internals scenic.core scenic.core.regions\n Edit on GitHub\nscenic.core.regions\n\nObjects representing regions in space.\n\nManipulations of polygons and line segments are done using the shapely package.\n\nManipulations of meshes is done using the trimesh package.\n\nSummary of Module Members\n\nModule Attributes\n\neverywhere\n\n\t\n\nA Region containing all points.\n\n\n\n\nnowhere\n\n\t\n\nA Region containing no points.\n\nFunctions\n\nconvertToFootprint\n\n\t\n\nRecursively convert a region into it's footprint.\n\n\n\n\norientationFor\n\n\t\n\n\n\n\nregionFromShapelyObject\n\n\t\n\nBuild a 'Region' from Shapely geometry.\n\n\n\n\ntoPolygon\n\n\t\n\nClasses\n\nAllRegion\n\n\t\n\nRegion consisting of all space.\n\n\n\n\nBoxRegion\n\n\t\n\nRegion in the shape of a rectangular cuboid, i.e. a box.\n\n\n\n\nCircularRegion\n\n\t\n\nA circular region with a possibly-random center and radius.\n\n\n\n\nCylinderSectionRegion\n\n\t\n\n\n\n\nDifferenceRegion\n\n\t\n\n\n\n\nEmptyRegion\n\n\t\n\nRegion containing no points.\n\n\n\n\nGridRegion\n\n\t\n\nA Region given by an obstacle grid.\n\n\n\n\nIntersectionRegion\n\n\t\n\n\n\n\nMeshRegion\n\n\t\n\nRegion given by a scaled, positioned, and rotated mesh.\n\n\n\n\nMeshSurfaceRegion\n\n\t\n\nA region representing the surface of a mesh.\n\n\n\n\nMeshVolumeRegion\n\n\t\n\nA region representing the volume of a mesh.\n\n\n\n\nPathRegion\n\n\t\n\nA region composed of multiple polylines in 3D space.\n\n\n\n\nPointInRegionDistribution\n\n\t\n\nUniform distribution over points in a Region\n\n\n\n\nPointSetRegion\n\n\t\n\nRegion consisting of a set of discrete points.\n\n\n\n\nPolygonalFootprintRegion\n\n\t\n\nRegion that contains all points in a polygonal footprint, regardless of their z value.\n\n\n\n\nPolygonalRegion\n\n\t\n\nRegion given by one or more polygons (possibly with holes) at a fixed z coordinate.\n\n\n\n\nPolylineRegion\n\n\t\n\nRegion given by one or more polylines (chain of line segments).\n\n\n\n\nRectangularRegion\n\n\t\n\nA rectangular region with a possibly-random position, heading, and size.\n\n\n\n\nRegion\n\n\t\n\nAn abstract base class for Scenic Regions\n\n\n\n\nSectorRegion\n\n\t\n\nA sector of a CircularRegion.\n\n\n\n\nSpheroidRegion\n\n\t\n\nRegion in the shape of a spheroid.\n\n\n\n\nSurfaceCollisionTrimesh\n\n\t\n\nA Trimesh object that always returns non-convex.\n\n\n\n\nUnionRegion\n\n\t\n\n\n\n\nViewRegion\n\n\t\n\nThe viewing volume of a camera defined by a radius and horizontal/vertical view angles.\n\n\n\n\nViewSectionRegion\n\n\t\n\n\n\n\nVoxelRegion\n\n\t\n\n(WIP) Region represented by a voxel grid in 3D space.\n\nExceptions\n\nUndefinedSamplingException\n\n\t\n\nMember Details\nclassRegion(name, *dependencies, orientation=None)[source]\n\nBases: Samplable, ABC\n\nAn abstract base class for Scenic Regions\n\nabstractuniformPointInner()[source]\n\nDo the actual random sampling. Implemented by subclasses.\n\nabstractcontainsPoint(point)[source]\n\nCheck if the Region contains a point. Implemented by subclasses.\n\nReturn type\n:\n\nbool\n\nabstractcontainsObject(obj)[source]\n\nCheck if the Region contains an Object\n\nReturn type\n:\n\nbool\n\nabstractcontainsRegionInner(reg, tolerance)[source]\n\nCheck if the Region contains a Region\n\nReturn type\n:\n\nbool\n\nabstractdistanceTo(point)[source]\n\nDistance to this region from a given point.\n\nReturn type\n:\n\nfloat\n\nabstractprojectVector(point, onDirection)[source]\n\nReturns point projected onto this region along onDirection.\n\nabstract propertyAABB\n\nAxis-aligned bounding box for this Region.\n\nintersects(other)[source]\n\nCheck if this Region intersects another.\n\nReturn type\n:\n\nbool\n\nintersect(other, triedReversed=False)[source]\n\nGet a Region representing the intersection of this one with another.\n\nIf both regions have a preferred orientation, the one of self is inherited by the intersection.\n\nReturn type\n:\n\nRegion\n\nunion(other, triedReversed=False)[source]\n\nGet a Region representing the union of this one with another.\n\nNot supported by all region types.\n\nReturn type\n:\n\nRegion\n\ndifference(other)[source]\n\nGet a Region representing the difference of this one and another.\n\nNot supported by all region types.\n\nReturn type\n:\n\nRegion\n\n_trueContainsPoint(point)[source]\n\nWhether or not this region could produce point when sampled.\n\nBy default this method calls containsPoint, but should be overwritten if containsPoint does not properly represent the points that can be sampled.\n\nReturn type\n:\n\nbool\n\nstaticuniformPointIn(region, tag=None)[source]\n\nGet a uniform Distribution over points in a Region.\n\norient(vec)[source]\n\nOrient the given vector along the region’s orientation, if any.\n\nclassPointInRegionDistribution(region, tag=None)[source]\n\nBases: VectorDistribution\n\nUniform distribution over points in a Region\n\nclassAllRegion(name, *dependencies, orientation=None)[source]\n\nBases: Region\n\nRegion consisting of all space.\n\nclassEmptyRegion(name, *dependencies, orientation=None)[source]\n\nBases: Region\n\nRegion containing no points.\n\neverywhere= <AllRegion everywhere>\n\nA Region containing all points.\n\nPoints may not be sampled from this region, as no uniform distribution over it exists.\n\nnowhere= <EmptyRegion nowhere>\n\nA Region containing no points.\n\nAttempting to sample from this region causes the sample to be rejected.\n\nregionFromShapelyObject(obj, orientation=None)[source]\n\nBuild a ‘Region’ from Shapely geometry.\n\nclassSurfaceCollisionTrimesh(vertices=None, faces=None, face_normals=None, vertex_normals=None, face_colors=None, vertex_colors=None, face_attributes=None, vertex_attributes=None, metadata=None, process=True, validate=False, merge_tex=None, merge_norm=None, use_embree=True, initial_cache=None, visual=None, **kwargs)[source]\n\nBases: Trimesh\n\nA Trimesh object that always returns non-convex.\n\nUsed so that fcl doesn’t find collision without an actual surface intersection.\n\nParameters\n:\n\nvertices (Optional[Union[_SupportsArray[dtype[Any]], _NestedSequence[_SupportsArray[dtype[Any]]], bool, int, float, complex, str, bytes, _NestedSequence[Union[bool, int, float, complex, str, bytes]]]]) –\n\nfaces (Optional[Union[_SupportsArray[dtype[Any]], _NestedSequence[_SupportsArray[dtype[Any]]], bool, int, float, complex, str, bytes, _NestedSequence[Union[bool, int, float, complex, str, bytes]]]]) –\n\nface_normals (Optional[Union[_SupportsArray[dtype[Any]], _NestedSequence[_SupportsArray[dtype[Any]]], bool, int, float, complex, str, bytes, _NestedSequence[Union[bool, int, float, complex, str, bytes]]]]) –\n\nvertex_normals (Optional[Union[_SupportsArray[dtype[Any]], _NestedSequence[_SupportsArray[dtype[Any]]], bool, int, float, complex, str, bytes, _NestedSequence[Union[bool, int, float, complex, str, bytes]]]]) –\n\nface_colors (Optional[Union[_SupportsArray[dtype[Any]], _NestedSequence[_SupportsArray[dtype[Any]]], bool, int, float, complex, str, bytes, _NestedSequence[Union[bool, int, float, complex, str, bytes]]]]) –\n\nvertex_colors (Optional[Union[_SupportsArray[dtype[Any]], _NestedSequence[_SupportsArray[dtype[Any]]], bool, int, float, complex, str, bytes, _NestedSequence[Union[bool, int, float, complex, str, bytes]]]]) –\n\nface_attributes (Optional[dict[str, Union[numpy._typing._array_like._SupportsArray[numpy.dtype[Any]], numpy._typing._nested_sequence._NestedSequence[numpy._typing._array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy._typing._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]]]]) –\n\nvertex_attributes (Optional[dict[str, Union[numpy._typing._array_like._SupportsArray[numpy.dtype[Any]], numpy._typing._nested_sequence._NestedSequence[numpy._typing._array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy._typing._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]]]]) –\n\nmetadata (dict) –\n\nprocess (bool) –\n\nvalidate (bool) –\n\nmerge_tex (Optional[bool]) –\n\nmerge_norm (Optional[bool]) –\n\nuse_embree (bool) –\n\ninitial_cache (Optional[dict[str, numpy.ndarray]]) –\n\nvisual (Optional[Union[ColorVisuals, TextureVisuals]]) –\n\nclassMeshRegion(mesh, dimensions=None, position=None, rotation=None, orientation=None, tolerance=1e-06, centerMesh=True, onDirection=None, name=None, additionalDeps=[])[source]\n\nBases: Region\n\nRegion given by a scaled, positioned, and rotated mesh.\n\nThis is an abstract class and cannot be instantiated directly. Instead a subclass should be used, like MeshVolumeRegion or MeshSurfaceRegion.\n\nThe mesh is first placed so the origin is at the center of the bounding box (unless centerMesh is False). The mesh is scaled to dimensions, translated so the center of the bounding box of the mesh is at positon, and then rotated to rotation.\n\nMeshes are centered by default (since centerMesh is true by default). If you disable this operation, do note that scaling and rotation transformations may not behave as expected, since they are performed around the origin.\n\nParameters\n:\n\nmesh – The base mesh for this MeshRegion.\n\nname – An optional name to help with debugging.\n\ndimensions – An optional 3-tuple, with the values representing width, length, height respectively. The mesh will be scaled such that the bounding box for the mesh has these dimensions.\n\nposition – An optional position, which determines where the center of the region will be.\n\nrotation – An optional Orientation object which determines the rotation of the object in space.\n\norientation – An optional vector field describing the preferred orientation at every point in the region.\n\ntolerance – Tolerance for internal computations.\n\ncenterMesh – Whether or not to center the mesh after copying and before transformations.\n\nonDirection – The direction to use if an object being placed on this region doesn’t specify one.\n\nadditionalDeps – Any additional sampling dependencies this region relies on.\n\nclassmethodfromFile(path, unify=True, **kwargs)[source]\n\nLoad a mesh region from a file, attempting to infer filetype and compression.\n\nFor example: “foo.obj.bz2” is assumed to be a compressed .obj file. “foo.obj” is assumed to be an uncompressed .obj file. “foo” is an unknown filetype, so unless a filetype is provided an exception will be raised.\n\nParameters\n:\n\npath (str) – Path to the file to import.\n\nfiletype (str) – Filetype of file to be imported. This will be inferred if not provided. The filetype must be one compatible with trimesh.load.\n\ncompressed (bool) – Whether or not this file is compressed (with bz2). This will be inferred if not provided.\n\nbinary (bool) – Whether or not to open the file as a binary file.\n\nunify (bool) – Whether or not to attempt to unify this mesh.\n\nkwargs – Additional arguments to the MeshRegion initializer.\n\nprojectVector(point, onDirection)[source]\n\nFind the nearest point in the region following the onDirection or its negation.\n\nReturns None if no such points exist.\n\npropertycircumcircle\n\nCompute an upper bound on the radius of the region\n\n \npropertyboundingPolygon\n\nA PolygonalRegion bounding the mesh\n\nclassMeshVolumeRegion(*args, _internal=False, _isConvex=None, **kwargs)[source]\n\nBases: MeshRegion\n\nA region representing the volume of a mesh.\n\nThe mesh passed must be a trimesh.base.Trimesh object that represents a well defined volume (i.e. the is_volume property must be true), meaning the mesh must be watertight, have consistent winding and have outward facing normals.\n\nThe mesh is first placed so the origin is at the center of the bounding box (unless centerMesh is False). The mesh is scaled to dimensions, translated so the center of the bounding box of the mesh is at positon, and then rotated to rotation.\n\nMeshes are centered by default (since centerMesh is true by default). If you disable this operation, do note that scaling and rotation transformations may not behave as expected, since they are performed around the origin.\n\nParameters\n:\n\nmesh – The base mesh for this region.\n\nname – An optional name to help with debugging.\n\ndimensions – An optional 3-tuple, with the values representing width, length, height respectively. The mesh will be scaled such that the bounding box for the mesh has these dimensions.\n\nposition – An optional position, which determines where the center of the region will be.\n\nrotation – An optional Orientation object which determines the rotation of the object in space.\n\norientation – An optional vector field describing the preferred orientation at every point in the region.\n\ntolerance – Tolerance for internal computations.\n\ncenterMesh – Whether or not to center the mesh after copying and before transformations.\n\nonDirection – The direction to use if an object being placed on this region doesn’t specify one.\n\nintersects(other, triedReversed=False)[source]\n\nCheck if this region intersects another.\n\nThis function handles intersect calculations for MeshVolumeRegion with: * MeshVolumeRegion * MeshSurfaceRegion * PolygonalFootprintRegion\n\ncontainsPoint(point)[source]\n\nCheck if this region’s volume contains a point.\n\ncontainsObject(obj)[source]\n\nCheck if this region’s volume contains an Object.\n\nintersect(other, triedReversed=False)[source]\n\nGet a Region representing the intersection of this region with another.\n\nThis function handles intersection computation for MeshVolumeRegion with: * MeshVolumeRegion * PolygonalFootprintRegion * PolygonalRegion * PathRegion * PolylineRegion\n\nunion(other, triedReversed=False)[source]\n\nGet a Region representing the union of this region with another.\n\nThis function handles union computation for MeshVolumeRegion with:\n\nMeshVolumeRegion\n\ndifference(other, debug=False)[source]\n\nGet a Region representing the difference of this region with another.\n\nThis function handles union computation for MeshVolumeRegion with: * MeshVolumeRegion * PolygonalFootprintRegion\n\ndistanceTo(point)[source]\n\nGet the minimum distance from this region to the specified point.\n\nvoxelized(pitch, lazy=False)[source]\n\nReturns a VoxelRegion representing a filled voxelization of this mesh\n\n_erodeOverapproximate(maxErosion, pitch)[source]\n\nCompute an overapproximation of this region eroded.\n\nErode as much as possible, but no more than maxErosion, outputting a VoxelRegion. Note that this can sometimes return a larger region than the original mesh\n\n_bufferOverapproximate(minBuffer, pitch)[source]\n\nCompute an overapproximation of this region buffered.\n\nBuffer as little as possible, but at least minBuffer. If pitch is less than 1, the output is a VoxelRegion. If pitch is 1, a fast path is taken which returns a BoxRegion.\n\ngetSurfaceRegion()[source]\n\nReturn a region equivalent to this one, except as a MeshSurfaceRegion\n\ngetVolumeRegion()[source]\n\nReturns this object, as it is already a MeshVolumeRegion\n\nclassMeshSurfaceRegion(*args, orientation=True, **kwargs)[source]\n\nBases: MeshRegion\n\nA region representing the surface of a mesh.\n\nThe mesh is first placed so the origin is at the center of the bounding box (unless centerMesh is False). The mesh is scaled to dimensions, translated so the center of the bounding box of the mesh is at positon, and then rotated to rotation.\n\nMeshes are centered by default (since centerMesh is true by default). If you disable this operation, do note that scaling and rotation transformations may not behave as expected, since they are performed around the origin.\n\nIf an orientation is not passed to this mesh, a default orientation is provided which provides an orientation that aligns an object’s z axis with the normal vector of the face containing that point, and has a yaw aligned with a yaw of 0 in the global coordinate system.\n\nParameters\n:\n\nmesh – The base mesh for this region.\n\nname – An optional name to help with debugging.\n\ndimensions – An optional 3-tuple, with the values representing width, length, height respectively. The mesh will be scaled such that the bounding box for the mesh has these dimensions.\n\nposition – An optional position, which determines where the center of the region will be.\n\nrotation – An optional Orientation object which determines the rotation of the object in space.\n\norientation – An optional vector field describing the preferred orientation at every point in the region.\n\ntolerance – Tolerance for internal computations.\n\ncenterMesh – Whether or not to center the mesh after copying and before transformations.\n\nonDirection – The direction to use if an object being placed on this region doesn’t specify one.\n\nintersects(other, triedReversed=False)[source]\n\nCheck if this region’s surface intersects another.\n\nThis function handles intersection computation for MeshSurfaceRegion with: * MeshSurfaceRegion * PolygonalFootprintRegion\n\ncontainsPoint(point)[source]\n\nCheck if this region’s surface contains a point.\n\ndistanceTo(point)[source]\n\nGet the minimum distance from this object to the specified point.\n\ngetFlatOrientation(pos)[source]\n\nGet a flat orientation at a point in the region.\n\nGiven a point on the surface of the mesh, returns an orientation that aligns an instance’s z axis with the normal vector of the face containing that point. Since there are infinitely many such orientations, the orientation returned has yaw aligned with a global yaw of 0.\n\nIf pos is not within self.tolerance of the surface of the mesh, a RejectionException is raised.\n\ngetVolumeRegion()[source]\n\nReturn a region equivalent to this one, except as a MeshVolumeRegion\n\ngetSurfaceRegion()[source]\n\nReturns this object, as it is already a MeshSurfaceRegion\n\nclassBoxRegion(*args, **kwargs)[source]\n\nBases: MeshVolumeRegion\n\nRegion in the shape of a rectangular cuboid, i.e. a box.\n\nBy default the unit box centered at the origin and aligned with the axes is used.\n\nParameters are the same as MeshVolumeRegion, with the exception of the mesh parameter which is excluded.\n\nclassSpheroidRegion(*args, **kwargs)[source]\n\nBases: MeshVolumeRegion\n\nRegion in the shape of a spheroid.\n\nBy default the unit sphere centered at the origin and aligned with the axes is used.\n\nParameters are the same as MeshVolumeRegion, with the exception of the mesh parameter which is excluded.\n\nclassVoxelRegion(voxelGrid, orientation=None, name=None, lazy=False)[source]\n\nBases: Region\n\n(WIP) Region represented by a voxel grid in 3D space.\n\nNOTE: This region is a work in progress and is currently only recommended for internal use.\n\nParameters\n:\n\nvoxelGrid – The Trimesh voxelGrid to be used.\n\norientation – An optional vector field describing the preferred orientation at every point in the region.\n\nname – An optional name to help with debugging.\n\nlazy – Whether or not to be lazy about pre-computing internal values. Set this to True if this VoxelRegion is unlikely to be used outside of an intermediate step in compiling/pruning.\n\ndilation(iterations, structure=None)[source]\n\nReturns a dilated/eroded version of this VoxelRegion.\n\nParameters\n:\n\niterations – How many times repeat the dilation/erosion. A positive number indicates a dilation and a negative number indicates an erosion.\n\nstructure – The structure to use. If none is provided, a rank 3 structuring unit with connectivity 3 is used.\n\npropertymesh\n\n(WIP) Return a MeshVolumeRegion representation of this region.\n\nNOTE: This region is a WIP and will sometimes return None if the transformation is not feasible.\n\nclassPolygonalFootprintRegion(polygon, name=None)[source]\n\nBases: Region\n\nRegion that contains all points in a polygonal footprint, regardless of their z value.\n\nThis region cannot be sampled from, as it has infinite height and therefore infinite volume.\n\nParameters\n:\n\npolygon – A shapely Polygon or MultiPolygon, that defines the footprint of this region.\n\nname – An optional name to help with debugging.\n\nintersect(other, triedReversed=False)[source]\n\nGet a Region representing the intersection of this region with another.\n\nThis function handles intersection computation for PolygonalFootprintRegion with: * PolygonalFootprintRegion * PolygonalRegion\n\nunion(other, triedReversed=False)[source]\n\nGet a Region representing the union of this region with another.\n\nThis function handles union computation for PolygonalFootprintRegion with: * PolygonalFootprintRegion\n\ndifference(other)[source]\n\nGet a Region representing the difference of this region with another.\n\nThis function handles difference computation for PolygonalFootprintRegion with: * PolygonalFootprintRegion\n\ncontainsPoint(point)[source]\n\nChecks if a point is contained in the polygonal footprint.\n\nEquivalent to checking if the (x, y) values are contained in the polygon.\n\nParameters\n:\n\npoint – A point to be checked for containment.\n\ncontainsObject(obj)[source]\n\nChecks if an object is contained in the polygonal footprint.\n\nParameters\n:\n\nobj – An object to be checked for containment.\n\ndistanceTo(point)[source]\n\nMinimum distance from this polygonal footprint to the target point\n\napproxBoundFootprint(centerZ, height)[source]\n\nReturns an overapproximation of boundFootprint\n\nReturns a volume that is guaranteed to contain the result of boundFootprint(centerZ, height), but may be taller. Used to save time on recomputing boundFootprint.\n\nboundFootprint(centerZ, height)[source]\n\nCap the footprint of the object to a given height, centered at a given z.\n\nParameters\n:\n\ncenterZ – The resulting mesh will be vertically centered at this height.\n\nheight – The resulting mesh will have this height.\n\nclassPathRegion(points=None, polylines=None, tolerance=1e-08, orientation=True, name=None)[source]\n\nBases: Region\n\nA region composed of multiple polylines in 3D space.\n\nOne of points or polylines should be provided.\n\nParameters\n:\n\npoints – A list of points defining a single polyline.\n\npolylines – A list of list of points, defining multiple polylines.\n\norientation (optional) – preferred orientation to use, or True to use an orientation aligned with the direction of the path (the default).\n\ntolerance – Tolerance used internally.\n\n_segmentDistanceHelper(point)[source]\n\nReturns distance to point from each line segment\n\nclassPolygonalRegion(points=None, polygon=None, z=0, orientation=None, name=None, additionalDeps=[])[source]\n\nBases: Region\n\nRegion given by one or more polygons (possibly with holes) at a fixed z coordinate.\n\nThe region may be specified by giving either a sequence of points defining the boundary of the polygon, or a collection of shapely polygons (a Polygon or MultiPolygon).\n\nParameters\n:\n\npoints – sequence of points making up the boundary of the polygon (or None if using the polygon argument instead).\n\npolygon – shapely polygon or collection of polygons (or None if using the points argument instead).\n\nz – The z coordinate the polygon is located at.\n\norientation (VectorField; optional) – preferred orientation to use.\n\nname (str; optional) – name for debugging.\n\npropertyboundary: PolylineRegion\n\nGet the boundary of this region as a PolylineRegion.\n\nclassCircularRegion(center, radius, resolution=32, name=None)[source]\n\nBases: PolygonalRegion\n\nA circular region with a possibly-random center and radius.\n\nParameters\n:\n\ncenter (Vector) – center of the disc.\n\nradius (float) – radius of the disc.\n\nresolution (int; optional) – number of vertices to use when approximating this region as a polygon.\n\nname (str; optional) – name for debugging.\n\nclassSectorRegion(center, radius, heading, angle, resolution=32, name=None)[source]\n\nBases: PolygonalRegion\n\nA sector of a CircularRegion.\n\nThis region consists of a sector of a disc, i.e. the part of a disc subtended by a given arc.\n\nParameters\n:\n\ncenter (Vector) – center of the corresponding disc.\n\nradius (float) – radius of the disc.\n\nheading (float) – heading of the centerline of the sector.\n\nangle (float) – angle subtended by the sector.\n\nresolution (int; optional) – number of vertices to use when approximating this region as a polygon.\n\nname (str; optional) – name for debugging.\n\nclassRectangularRegion(position, heading, width, length, name=None)[source]\n\nBases: PolygonalRegion\n\nA rectangular region with a possibly-random position, heading, and size.\n\nParameters\n:\n\nposition (Vector) – center of the rectangle.\n\nheading (float) – the heading of the length axis of the rectangle.\n\nwidth (float) – width of the rectangle.\n\nlength (float) – length of the rectangle.\n\nname (str; optional) – name for debugging.\n\nclassPolylineRegion(points=None, polyline=None, orientation=True, name=None)[source]\n\nBases: Region\n\nRegion given by one or more polylines (chain of line segments).\n\nThe region may be specified by giving either a sequence of points or shapely polylines (a LineString or MultiLineString).\n\nParameters\n:\n\npoints – sequence of points making up the polyline (or None if using the polyline argument instead).\n\npolyline – shapely polyline or collection of polylines (or None if using the points argument instead).\n\norientation (optional) – preferred orientation to use, or True to use an orientation aligned with the direction of the polyline (the default).\n\nname (str; optional) – name for debugging.\n\npropertystart\n\nGet an OrientedPoint at the start of the polyline.\n\nThe OP’s orientation will be aligned with the orientation of the region, if there is one (the default orientation pointing along the polyline).\n\n \npropertyend\n\nGet an OrientedPoint at the end of the polyline.\n\nThe OP’s orientation will be aligned with the orientation of the region, if there is one (the default orientation pointing along the polyline).\n\nsignedDistanceTo(point)[source]\n\nCompute the signed distance of the PolylineRegion to a point.\n\nThe distance is positive if the point is left of the nearest segment, and negative otherwise.\n\nReturn type\n:\n\nfloat\n\npointAlongBy(distance, normalized=False)[source]\n\nFind the point a given distance along the polyline from its start.\n\nIf normalized is true, then distance should be between 0 and 1, and is interpreted as a fraction of the length of the polyline. So for example pointAlongBy(0.5, normalized=True) returns the polyline’s midpoint.\n\nReturn type\n:\n\nVector\n\nclassPointSetRegion(name, points, kdTree=None, orientation=None, tolerance=1e-06)[source]\n\nBases: Region\n\nRegion consisting of a set of discrete points.\n\nNo Object can be contained in a PointSetRegion, since the latter is discrete. (This may not be true for subclasses, e.g. GridRegion.)\n\nParameters\n:\n\nname (str) – name for debugging\n\npoints (arraylike) – set of points comprising the region\n\nkdTree (scipy.spatial.KDTree, optional) – k-D tree for the points (one will be computed if none is provided)\n\norientation (VectorField; optional) – preferred orientation for the region\n\ntolerance (float; optional) – distance tolerance for checking whether a point lies in the region\n\nconvertToFootprint(region)[source]\n\nRecursively convert a region into it’s footprint.\n\nFor a polygonal region, returns the footprint. For composed regions, recursively reconstructs them using the footprints of their sub regions.\n\nclassGridRegion(name, grid, Ax, Ay, Bx, By, orientation=None)[source]\n\nBases: PointSetRegion\n\nA Region given by an obstacle grid.\n\nA point is considered to be in a GridRegion if the nearest grid point is not an obstacle.\n\nParameters\n:\n\nname (str) – name for debugging\n\ngrid – 2D list, tuple, or NumPy array of 0s and 1s, where 1 indicates an obstacle and 0 indicates free space\n\nAx (float) – spacing between grid points along X axis\n\nAy (float) – spacing between grid points along Y axis\n\nBx (float) – X coordinate of leftmost grid column\n\nBy (float) – Y coordinate of lowest grid row\n\norientation (VectorField; optional) – orientation of region\n\nclassViewRegion(visibleDistance, viewAngles, name=None, position=Vector(0, 0, 0), rotation=None, angleCutoff=0.017, tolerance=1e-08)[source]\n\nBases: MeshVolumeRegion\n\nThe viewing volume of a camera defined by a radius and horizontal/vertical view angles.\n\nThe default view region can take several forms, depending on the viewAngles parameter:\n\nCase 1: viewAngles[1] = 180 degrees\n\nCase 1.a viewAngles[0] = 360 degrees => Sphere\n\nCase 1.b viewAngles[0] < 360 degrees => Sphere & CylinderSectionRegion\n\nCase 2: viewAngles[1] < 180 degrees => Sphere & ViewSectionRegion\n\nWhen making changes to this class you should run pytest -k test_viewRegion --exhaustive.\n\nParameters\n:\n\nvisibleDistance – The view distance for this region.\n\nviewAngles – The view angles for this region.\n\nname – An optional name to help with debugging.\n\nposition – An optional position, which determines where the center of the region will be.\n\nrotation – An optional Orientation object which determines the rotation of the object in space.\n\nangleCutoff – How close to 180/360 degrees an angle has to be to be mapped to that value.\n\ntolerance – Tolerance for collision computations.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Porting to Scenic 3 — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/porting.html#porting-to-scenic-3",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Porting to Scenic 3\n Edit on GitHub\nPorting to Scenic 3\n\nAs described in What’s New in Scenic, Scenic 2 programs are not compatible with Scenic 3 due to a few changes in syntax and semantics. See that page for a complete list of backwards-incompatibilities and explanations of how you can change your code. This page describes two tools that assist in the migration process: the Scenic 2-to-3 converter and 2D compatibility mode. The former converts a Scenic 2 program into a syntactically-valid Scenic 3 program; the latter is a compiler option that changes the semantics of several Scenic constructs so that they behave as in Scenic 2. The goal of these tools is that applying them together to a Scenic 2 program makes it possible to run the program under Scenic 3 and get largely the same behavior.\n\nNote\n\n2D compatibility mode does not exactly emulate the behavior of Scenic 2: for example, it does not disable fixes for bugs. It is intended as a temporary measure to help easily run old Scenic programs without fully porting them to 3D geometry. If it is essential for your application that you can reproduce the exact behavior of your Scenic 2 scenarios, you should not upgrade to Scenic 3: old releases of Scenic are always available on PyPI and in our GitHub repository. For most use cases, however, upgrading to Scenic 3 and using 2D mode until you can digest our documentation and port your scenarios will work just fine.\n\nScenic 2-to-3 Converter\n\nThis tool reads a Scenic 2 program and adjusts its syntax so that it parses under Scenic 3. It requires the Scenic 2 parser in order to work, so it is not included in Scenic 3: you must either use the tool before upgrading, or temporarily check out the 2.x branch of our repository to get the latest Scenic 2 release (you can switch back to the main branch afterward).\n\nTo run the tool and see the list of options it supports, run this command in the environment where you have Scenic installed:\n\n$ python -m scenic.syntax.scenic2to3 --help\n\n\nNote that due to the nature of Scenic 2 parsing, the tool must actually execute your Scenic 2 program, so you will have to ensure your program runs before you can convert it.\n\n2D Compatibility Mode\n\nRunning the scenic command with the --2d option enables 2D compatibility mode. This mode changes several aspects of Scenic’s semantics in order to more closely match the historical behavior of Scenic 2. Specifically:\n\nThe baseOffset and contactTolerance properties of Object are zeroed, so that the specifier on region places the position of the object within the region, as it did in Scenic 2 (vs. the Scenic 3 behavior of placing the object above that position so that the base of the object lies on the region).\n\nThe requireVisible property of Object is true by default, as it was in Scenic 2.\n\nThe occluding property of Object is false by default, so that objects do not occlude each other for the purpose of visibility checks (as Scenic 2 did not account for occlusion).\n\nThe visible regions of Point, OrientedPoint, and Object are 2D regions as in Scenic 2 (either a CircularRegion or a SectorRegion).\n\nDefault values for heading in class definitions are replaced with default values for parentOrientation.\n\nThe specifier with heading X is replaced with facing X.\n\nThe visible and not visible will behave as they did in Scenic 2, requiring the center of the object to be visible rather than any part of the object. More precisely, visible will specify position to be uniformly random in the observing object’s visible region and not visible will specify position to be uniformly random in the difference of the workspace and the observing object’s visible region.\n\nNote that despite these changes, Scenic will still use 3D geometry internally. For example, if you write ego = new Object at (1, 2) the value of ego.position will be the 3D vector (1, 2, 0).\n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Welcome to Scenic’s documentation! — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Welcome to Scenic’s documentation!\n Edit on GitHub\nWelcome to Scenic’s documentation!\n\nScenic is a domain-specific probabilistic programming language for modeling the environments of cyber-physical systems like robots and autonomous cars. A Scenic program defines a distribution over scenes, configurations of physical objects and agents; sampling from this distribution yields concrete scenes which can be simulated to produce training or testing data. Scenic can also define (probabilistic) policies for dynamic agents, allowing modeling scenarios where agents take actions over time in response to the state of the world.\n\nScenic was designed and implemented by Daniel J. Fremont, Eric Vin, Edward Kim, Tommaso Dreossi, Shromona Ghosh, Xiangyu Yue, Alberto L. Sangiovanni-Vincentelli, and Sanjit A. Seshia, with contributions from many others. For a description of the language and some of its applications, see our journal paper on Scenic 2, which extends our PLDI 2019 paper on Scenic 1; the new features in Scenic 3 are described in our CAV 2023 paper. Our publications page lists additional papers using Scenic.\n\nNote\n\nThe syntax of Scenic 3 is not completely backwards-compatible with earlier versions of Scenic, which were used in our papers prior to 2023. See What’s New in Scenic for a list of syntax changes and new features. Old code can likely be easily ported; you can also install older releases if necessary from GitHub.\n\nIf you have any problems using Scenic, please submit an issue to our GitHub repository or ask a question on our community forum.\n\nTable of Contents\n\nIntroduction\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTutorials\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLanguage and Tool Reference\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLibraries and Simulators\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGeneral Information\n\nPublications Using Scenic\nCredits\nIndices and Tables\n\nIndex\n\nModule Index\n\nGlossary\n\nLicense\n\nScenic is distributed under the 3-Clause BSD License.\n\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "btb4.jpg (640×400)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/btb4.jpg",
    "html": ""
  },
  {
    "title": "btb3.jpg (640×400)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/btb3.jpg",
    "html": ""
  },
  {
    "title": "btb1.jpg (640×400)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/btb1.jpg",
    "html": ""
  },
  {
    "title": "platoon4.jpg (640×400)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/platoon4.jpg",
    "html": ""
  },
  {
    "title": "platoon3.jpg (640×400)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/platoon3.jpg",
    "html": ""
  },
  {
    "title": "platoon2.jpg (640×400)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/platoon2.jpg",
    "html": ""
  },
  {
    "title": "narrowGoalWebots.jpg (1024×546)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/narrowGoalWebots.jpg",
    "html": ""
  },
  {
    "title": "Glossary — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/glossary.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Glossary\n Edit on GitHub\nGlossary\naction\n\nA primitive operation executed by an agent during a single step of a dynamic simulation. For example, a car might take an action which sets its throttle, or turns on its headlights. Actions are defined by the simulator interfaces (or abstract domains like scenic.domains.driving) as subclasses of Action.\n\nagent\n\nA Scenic Object which has a dynamic behavior (set as its behavior property).\n\nbehavior\ndynamic behavior\n\nA function defining the behavior of an agent during a simulation. The function runs in parallel with the simulation, taking actions at each time step. See our tutorial on Dynamic Scenarios for examples.\n\ncontainer\n\nThe region specified as the regionContainedIn property of an Object, or the entire workspace if it is None (the default). A built-in requirement enforces that objects are completely contained in their containers: so by default all objects fit into the workspace, and particular kinds of objects can define more stringent requirements by overriding regionContainedIn (e.g. making cars be on roads by default).\n\ndynamic properties\n\nProperties of Scenic objects which are updated at each time step of a dynamic simulation. The built-in properties representing positions, orientations, velocities, etc. are all dynamic (see Object). See the source code of scenic.domains.driving.model.DrivingObject for an example of defining a dynamic property.\n\nexternal parameters\n\nValues which are determined by an external tool instead of Scenic’s own sampler. These allow using optimization or other techniques to explore parameters of Scenic scenarios beyond simple random sampling. For how to define external parameters or interface to new external samplers, see scenic.core.external_params.\n\nfootprint\n\nThe infinite extrusion of a 2D Region in the positive and negative Z directions. Testing containment of an Object in a 2D region automatically uses its footprint, so that the object is considered contained if and only if its projection into the plane of the region is contained in the region. Footprints are represented internally by instances of the PolygonalFootprintRegion class, and can be accessed using the footprint attribute.\n\nglobal parameters\n\nParameters of a scene like weather or time of day which are not associated with any object. These are defined using the param statement, and can be overridden from the command line with the --param option.\n\nmodular scenario\n\nA scenario defined using the scenario statement (rather than simply being the content of a Scenic file). Such scenarios can take arguments, be instantiated multiple times, and be composed with other scenarios: see Composing Scenarios.\n\nmonitor\n\nA function which runs in parallel with a simulation, rejecting or terminating the simulation if conditions of interest are met (using the require and terminate statements). Monitors use similar syntax to dynamic behaviors, except that they are not associated with a specific Object and do not take actions (only using wait to advance time).\n\npreferred orientation\n\nA Vector Field set as the orientation attribute of a Region, indicating that objects placed within that region should be oriented to align along that vector field unless otherwise specified. For example, the road region provided by the Driving Domain has as its preferred orientation the roadDirection vector field, so that vehicles positioned using the specifier on road will be facing the nominal traffic direction at their position by default (but an explicit facing H specifier will override it).\n\ntemporal requirement\n\nA require statement using one or more temporal operators (always, until, etc.) to impose a requirement over an entire simulation rather than just the generated scene. For example, require always X requires not only that the condition X be true in any scenes sampled from the scenario, but that it remain true at every time step of simulations run from those scenes.\n\nvisible region\n\nThe Region which is “visible” from a given Object. See the Visibility System reference for more details.\n\nworkspace\n\nThe region of space in which a scenario takes place. Workspaces are represented as instances of the Workspace class, which extends Region with additional methods for rendering schematics of scenes for debugging. The default workspace contains all space, so it puts no restrictions on the locations of objects. A world model can define a more specific workspace to exclude space occupied by fixed objects in the simulated world which aren’t otherwise known to Scenic (e.g. buildings in GTA V or CARLA).\n\nworld model\n\nA Scenic library defining classes, regions, actions, helper functions, etc. for use by scenarios targeting a particular simulator or application domain. For example, the world model for the Driving Domain, scenic.domains.driving.model, defines classes for vehicles, actions for steering, and regions for different parts of the road network. In the line new Car in intersection, only the new keyword and in specifier are built into Scenic: the class Car and the region intersection are defined by the world model. A world model can be used through the model statement, or simply by importing it like any other Scenic module.\n\nSee also\n\nDefining a World Model gives further examples and details on how to write a world model.\n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "simplest2.jpg (640×400)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/simplest2.jpg",
    "html": ""
  },
  {
    "title": "on_chair.jpg (1024×455)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/on_chair.jpg",
    "html": ""
  },
  {
    "title": "Index — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/genindex.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Index\n Edit on GitHub\nIndex\nSymbols | _ | A | B | C | D | E | F | G | H | I | K | L | M | N | O | P | R | S | T | U | V | W | Y | Z\nSymbols\n--2d\ncommand line option\n--count\ncommand line option\n--full-backtrace\ncommand line option\n--model\ncommand line option\n--param\ncommand line option\n--pdb\ncommand line option\n--pdb-on-reject\ncommand line option\n--scenario\ncommand line option\n--seed\ncommand line option\n--show-params\ncommand line option\n--show-records\ncommand line option\n\t\n--simulate\ncommand line option\n--time\ncommand line option\n--verbosity\ncommand line option\n--version\ncommand line option\n-b\ncommand line option\n-m\ncommand line option\n-p\ncommand line option\n-S\ncommand line option\n-s\ncommand line option\n-v\ncommand line option\n_\n_3DClass (Object2D attribute)\n(OrientedPoint2D attribute)\n(Point2D attribute)\n_addDynamicRequirement() (DynamicScenario method), [1]\n_addMonitor() (DynamicScenario method), [1]\n_addRequirement() (DynamicScenario method), [1]\n_asdict() (EdgeData method)\n(Modifier method)\n_bindTo() (DynamicScenario method), [1]\n_bufferOverapproximate() (MeshVolumeRegion method), [1]\n_copyWith() (Constructible method)\n_crossing (DrivingObject property)\n_defaultValueType (Distribution attribute)\n(VectorDistribution attribute)\n(VerifaiDiscreteRange attribute), [1]\n(VerifaiRange attribute), [1]\n_deterministic (Distribution attribute)\n_element (DrivingObject property)\n_EndScenarioAction (class in scenic.core.dynamics.actions)\n_EndSimulationAction (class in scenic.core.dynamics.actions)\n_erodeOverapproximate() (MeshVolumeRegion method), [1]\n_fasterLane (LaneSection attribute)\n_getClosestTrafficLight() (in module scenic.simulators.carla.model)\n_intersection (DrivingObject property)\n_invokeInner() (Invocable method)\n_isConvex (Object property), [1]\n\t\n_isPlanarBox (Object property), [1]\n_lane (DrivingObject property)\n_laneGroup (DrivingObject property)\n_laneSection (DrivingObject property)\n_laneToLeft (LaneSection attribute)\n_laneToRight (LaneSection attribute)\n_make() (EdgeData class method)\n(Modifier class method)\n_opposite (LaneGroup attribute)\n_prepare() (DynamicScenario method), [1]\n_replace() (EdgeData method)\n(Modifier method)\n_requiresArguments() (DynamicScenario class method), [1]\n_road (DrivingObject property)\n_scenarioFromStream() (in module scenic.syntax.translator)\n_scenic_default (in module scenic.syntax.veneer)\n_segmentDistanceHelper() (PathRegion method), [1]\n_shoulder (LaneGroup attribute)\n_sidewalk (LaneGroup attribute)\n_slowerLane (LaneSection attribute)\n_start() (DynamicScenario method), [1]\n_step() (DynamicScenario method), [1]\n_stop() (DynamicScenario method), [1]\n_trueContainsPoint() (Region method), [1]\n_withProperties() (Constructible class method)\n_withSpecifiers() (Constructible class method)\nA\nAABB (Region property), [1]\nAbove() (in module scenic.syntax.veneer)\naction\nAction (class in scenic.core.dynamics.actions)\nactionsAreCompatible() (Simulation method)\naddCodec() (Serializer class method)\nadjacentLanes (LaneSection attribute)\nadvertisementModels (in module scenic.simulators.carla.blueprints)\nagent\nAhead() (in module scenic.syntax.veneer)\nAllRegion (class in scenic.core.regions)\nallRoads (Network attribute)\nAltitudeFrom() (in module scenic.syntax.veneer)\nAltitudeTo() (in module scenic.syntax.veneer)\nalwaysGlobalOrientation() (in module scenic.core.vectors)\n\t\nAngleFrom() (in module scenic.syntax.veneer)\nAngleTo() (in module scenic.syntax.veneer)\nangleWith() (Vector method), [1]\nApparentHeading() (in module scenic.syntax.veneer)\nApparentlyFacing() (in module scenic.syntax.veneer)\nappliedTo() (Mutator method), [1]\nApplyForceAction (class in scenic.simulators.webots.actions)\napplyTo() (Action method)\napproxBoundFootprint() (PolygonalFootprintRegion method)\nAST (class in scenic.syntax.ast)\nASTParseError\nAt() (in module scenic.syntax.veneer)\natmModels (in module scenic.simulators.carla.blueprints)\nAttributeDistribution (class in scenic.core.distributions)\nAttributeFinder (class in scenic.syntax.compiler)\nAutopilotBehavior() (in module scenic.simulators.carla.behaviors)\nB\nBack (class in scenic.syntax.ast)\nBack() (in module scenic.syntax.veneer)\nBackLeft (class in scenic.syntax.ast)\nBackLeft() (in module scenic.syntax.veneer)\nBackRight (class in scenic.syntax.ast)\nBackRight() (in module scenic.syntax.veneer)\nbackSurface (Object property), [1]\nbackwardLanes (Road attribute)\nbarrelModels (in module scenic.simulators.carla.blueprints)\nbarrierModels (in module scenic.simulators.carla.blueprints)\nBasicChecker (class in scenic.core.sample_checking)\nbehavior\nBehavior (class in scenic.core.dynamics.behaviors)\n(class in scenic.syntax.veneer)\nBehind() (in module scenic.syntax.veneer)\nBelow() (in module scenic.syntax.veneer)\nbenchModels (in module scenic.simulators.carla.blueprints)\nBetterPythonLexer (class in scenic.syntax.pygment)\nBeyond() (in module scenic.syntax.veneer)\nbicycleModels (in module scenic.simulators.carla.blueprints)\nBlockConclusion (class in scenic.core.dynamics.invocables)\n(class in scenic.syntax.veneer)\nBottom (class in scenic.syntax.ast)\n\t\nBottom() (in module scenic.syntax.veneer)\nBottomBackLeft (class in scenic.syntax.ast)\nBottomBackLeft() (in module scenic.syntax.veneer)\nBottomBackRight (class in scenic.syntax.ast)\nBottomBackRight() (in module scenic.syntax.veneer)\nBottomFrontLeft (class in scenic.syntax.ast)\nBottomFrontLeft() (in module scenic.syntax.veneer)\nBottomFrontRight (class in scenic.syntax.ast)\nBottomFrontRight() (in module scenic.syntax.veneer)\nbottomSurface (Object property), [1]\nboundary (PolygonalRegion property), [1]\nboundFootprint() (PolygonalFootprintRegion method)\nboundingBox (Object property), [1]\nboundingPolygon (MeshRegion property)\nBoundRelation (class in scenic.syntax.relations)\nboxModels (in module scenic.simulators.carla.blueprints)\nBoxRegion (class in scenic.core.regions)\n(class in scenic.syntax.veneer)\nBoxShape (class in scenic.core.shapes)\n(class in scenic.syntax.veneer)\nbucket() (Distribution method)\nBus (class in scenic.simulators.gta.model)\nbusStopModels (in module scenic.simulators.carla.blueprints)\nC\ncached() (in module scenic.core.utils)\ncached_method() (in module scenic.core.utils)\ncallBeginningScenicTrace() (in module scenic.core.errors)\ncanBeTakenBy() (Action method)\ncanCoerce() (in module scenic.core.type_support)\ncanCoerceType() (in module scenic.core.type_support)\ncanSee() (in module scenic.core.visibility)\nCanSee() (in module scenic.syntax.veneer)\ncanSee() (Object method), [1]\n(OrientedPoint method), [1]\n(Point method), [1]\ncanUnpackDistributions() (in module scenic.core.distributions)\nCar (class in scenic.domains.driving.model)\n(class in scenic.simulators.carla.model)\n(class in scenic.simulators.gta.model)\nCarlaActor (class in scenic.simulators.carla.model)\nCarlaSimulator (class in scenic.simulators.carla.simulator)\nCarModel (class in scenic.simulators.gta.interface)\n(class in scenic.simulators.webots.road.car_models)\ncarModels (in module scenic.simulators.carla.blueprints)\ncaseModels (in module scenic.simulators.carla.blueprints)\nchairModels (in module scenic.simulators.carla.blueprints)\ncheck_constrains_sampling() (PropositionNode method)\ncheckConditionedCycle() (in module scenic.core.pruning)\nchildren (PropositionNode property)\nCircularRegion (class in scenic.core.regions)\n(class in scenic.syntax.veneer)\ncircumcircle (MeshRegion property)\nclone() (Distribution method)\nClothoid (class in scenic.formats.opendrive.xodr_parser)\ncoerce() (in module scenic.core.type_support)\ncoerceToAny() (in module scenic.core.type_support)\nCoercionFailure\nColor (class in scenic.simulators.utils.colors)\nColorMutator (class in scenic.simulators.utils.colors)\ncommand line option\n--2d\n--count\n--full-backtrace\n--model\n--param\n--pdb\n--pdb-on-reject\n--scenario\n--seed\n--show-params\n--show-records\n--simulate\n--time\n--verbosity\n--version\n-b\n-m\n-p\n-s\n-S\n-v\n\t\nCompact (class in scenic.simulators.gta.model)\nCompileOptions (class in scenic.syntax.translator)\ncompileScenicAST() (in module scenic.syntax.compiler)\ncompileStream() (in module scenic.syntax.translator)\ncompute_distance() (in module scenic.simulators.carla.misc)\ncompute_magnitude_angle() (in module scenic.simulators.carla.misc)\nconditionOn() (Scenario method)\nconditionTo() (Samplable method)\nconeModels (in module scenic.simulators.carla.blueprints)\nConeShape (class in scenic.core.shapes)\n(class in scenic.syntax.veneer)\nconflictingManeuvers (Maneuver property)\nconnectingLane (Maneuver attribute)\nconnectingRoads (Network attribute)\nConstantSamplable (class in scenic.core.distributions)\nConstructible (class in scenic.core.object_types)\nconstructScenarioFrom() (in module scenic.syntax.translator)\nContainedIn() (in module scenic.syntax.veneer)\ncontainer\ncontainerModels (in module scenic.simulators.carla.blueprints)\ncontainsCenter (Shape property), [1]\ncontainsObject() (MeshVolumeRegion method), [1]\n(PolygonalFootprintRegion method)\n(Region method), [1]\ncontainsPoint() (MeshSurfaceRegion method), [1]\n(MeshVolumeRegion method), [1]\n(Object method), [1]\n(PolygonalFootprintRegion method)\n(Region method), [1]\ncontainsRegionInner() (Region method), [1]\nContext (class in scenic.syntax.compiler)\nconvertToFootprint() (in module scenic.core.regions)\ncorners (Object property), [1]\ncountry (Signal attribute)\ncreasedboxModels (in module scenic.simulators.carla.blueprints)\ncreateObjectInSimulator() (Simulation method)\ncreatePlatoonAt() (in module scenic.simulators.gta.model)\ncreateSimulation() (Simulator method)\ncrossing (DrivingObject property)\ncrossingAt() (Network method)\n(Road method)\nCrossingBehavior() (in module scenic.simulators.carla.behaviors)\ncrossings (Network attribute)\n(Road attribute)\nCrossroad (class in scenic.simulators.webots.road.interface)\nCubic (class in scenic.formats.opendrive.xodr_parser)\ncurb (in module scenic.domains.driving.model)\n(in module scenic.simulators.gta.model)\n(LaneGroup attribute)\ncurrentPropValue() (in module scenic.core.pruning)\ncurrentRealTime (Simulation property)\ncurrentState() (Simulation method)\nCurve (class in scenic.formats.opendrive.xodr_parser)\nCylinderShape (class in scenic.core.shapes)\n(class in scenic.syntax.veneer)\nD\nDebris (class in scenic.simulators.newtonian.driving_model)\ndebrisModels (in module scenic.simulators.carla.blueprints)\ndefaultCarColor() (Color static method)\nDefaultIdentityDict (class in scenic.core.utils)\ndefaultSideSurface() (in module scenic.core.object_types)\nDelayedArgument (class in scenic.core.lazy_eval)\ndependencies() (in module scenic.core.lazy_eval)\ndestroy() (Simulation method)\n(Simulator method)\ndifference() (MeshVolumeRegion method), [1]\n(PolygonalFootprintRegion method)\n(Region method), [1]\ndilation() (VoxelRegion method)\nDimensionLimits (in module scenic.core.object_types)\nDiscrete (in module scenic.syntax.veneer)\nDiscreteRange (class in scenic.core.distributions)\n(class in scenic.syntax.veneer)\ndisplayScenicException() (in module scenic.core.errors)\ndistance_vehicle() (in module scenic.simulators.carla.misc)\nDistanceFrom() (in module scenic.syntax.veneer)\nDistancePast() (in module scenic.syntax.veneer)\ndistancePast() (OrientedPoint method), [1]\nDistanceRelation (class in scenic.syntax.relations)\n\t\ndistanceTo() (MeshSurfaceRegion method), [1]\n(MeshVolumeRegion method), [1]\n(Object method), [1]\n(PolygonalFootprintRegion method)\n(Region method), [1]\ndistanceToClosest() (DrivingObject method)\nDistribution (class in scenic.core.distributions)\ndistributionFunction() (in module scenic.core.distributions)\ndistributionMethod() (in module scenic.core.distributions)\nDivergenceError\ndraw_waypoints() (in module scenic.simulators.carla.misc)\ndriveOnLeft (Network attribute)\nDrivingObject (class in scenic.domains.driving.model)\nDrivingSimulation (class in scenic.domains.driving.simulators)\nDrivingSimulator (class in scenic.domains.driving.simulators)\nDrivingWorkspace (class in scenic.domains.driving.workspace)\nDummySimulation (class in scenic.core.simulators)\nDummySimulator (class in scenic.core.simulators)\ndumpAsScenicCode() (in module scenic.core.serialization)\n(Scene method)\ndynamic behavior\ndynamic properties\nDynamicScenario (class in scenic.core.dynamics.scenarios)\n(class in scenic.syntax.veneer)\nE\nEdgeData (class in scenic.simulators.gta.center_detection)\nEgo (class in scenic.syntax.ast)\nego() (in module scenic.syntax.veneer)\nEgoCar (class in scenic.simulators.gta.model)\nelement (DrivingObject property)\nelementAt() (Network method)\nelements (Network attribute)\nEmptyRegion (class in scenic.core.regions)\nend (PolylineRegion property), [1]\nendLane (Maneuver attribute)\nENU (in module scenic.simulators.webots.utils)\nenvironment variable\nPYTHONPATH\nPYTHONWARNINGS\n\t\nErrorReporter (class in scenic.simulators.webots.world_parser)\neulerAngles (Orientation property), [1]\nEUN (in module scenic.simulators.webots.utils)\nevaluateIn() (LazilyEvaluable method)\n(Samplable method)\nevaluateInner() (LazilyEvaluable method)\nevaluateRequiringEqualTypes() (in module scenic.core.type_support)\nEvaluator (class in scenic.simulators.webots.world_parser)\neverywhere (in module scenic.core.regions)\nexecuteActions() (Simulation method)\nexecuteCodeIn() (in module scenic.syntax.translator)\nexternal parameters\nExternalParameter (class in scenic.core.external_params)\nExternalSampler (class in scenic.core.external_params)\nF\nFacing() (in module scenic.syntax.veneer)\nFacingAwayFrom() (in module scenic.syntax.veneer)\nFacingDirectlyAwayFrom() (in module scenic.syntax.veneer)\nFacingDirectlyToward() (in module scenic.syntax.veneer)\nFacingToward() (in module scenic.syntax.veneer)\nfalsifiedByInner() (SamplingRequirement method)\nfasterLane (LaneSection property)\nfeasibleRHPolygon() (in module scenic.core.pruning)\nFieldAt() (in module scenic.syntax.veneer)\nfind_center() (in module scenic.simulators.gta.center_detection)\nfindNodeTypesIn() (in module scenic.simulators.webots.world_parser)\nfindPointIn() (Network method)\nflatten() (PropositionNode method)\nflowFrom() (LinearElement method)\nFollow() (in module scenic.syntax.veneer)\nfollowFrom() (VectorField method), [1]\nFollowing() (in module scenic.syntax.veneer)\nFollowLaneBehavior() (in module scenic.domains.driving.behaviors)\nFollowTrajectoryBehavior() (in module scenic.domains.driving.behaviors)\n\t\nfootprint\nforParameters() (ExternalSampler static method)\nforUnionOf() (VectorField static method), [1]\nforwardLanes (Road attribute)\nfreezeTrafficLights() (in module scenic.simulators.carla.model)\nfromEuler() (Orientation class method), [1]\nfromFile() (MeshRegion class method)\n(MeshShape class method), [1]\n(Network class method)\nfromOpenDrive() (Network class method)\nfromQuaternion() (Orientation class method), [1]\nFront (class in scenic.syntax.ast)\nFront() (in module scenic.syntax.veneer)\nFrontLeft (class in scenic.syntax.ast)\nFrontLeft() (in module scenic.syntax.veneer)\nFrontRight (class in scenic.syntax.ast)\nFrontRight() (in module scenic.syntax.veneer)\nfrontSurface (Object property), [1]\nFunctionDistribution (class in scenic.core.distributions)\nG\ngarbageModels (in module scenic.simulators.carla.blueprints)\ngatherBehaviorNamespacesFrom() (in module scenic.syntax.translator)\ngenerate() (Scenario method)\ngenerateBatch() (Scenario method)\nget_speed() (in module scenic.simulators.carla.misc)\ngetAllGlobals() (in module scenic.core.requirements)\ngetFieldSafe() (in module scenic.simulators.webots.simulator)\ngetFlatOrientation() (MeshSurfaceRegion method), [1]\ngetLaneChangingControllers() (DrivingSimulation method)\ngetLaneFollowingControllers() (DrivingSimulation method)\ngetProperties() (Simulation method)\ngetReplay() (Simulation method)\ngetSurfaceRegion() (MeshSurfaceRegion method), [1]\n(MeshVolumeRegion method), [1]\n\t\ngetText() (in module scenic.core.errors)\ngetTurningControllers() (DrivingSimulation method)\ngetValuesFor() (Specifier method)\ngetVolumeRegion() (MeshSurfaceRegion method), [1]\n(MeshVolumeRegion method), [1]\nglobal parameters\nglobalToLocalAngles() (Orientation method), [1]\ngnomeModels (in module scenic.simulators.carla.blueprints)\ngpsToScenicPosition() (in module scenic.simulators.lgsvl.utils)\nGridRegion (class in scenic.core.regions)\nGround (class in scenic.simulators.webots.model)\ngroup (LaneSection attribute)\nGuardViolation, [1]\nguessTypeFromLanes() (ManeuverType static method)\nH\nhash (CompileOptions property)\nHeading (class in scenic.core.type_support)\n\t\nhiddenFolders (in module scenic.core.errors)\nHill (class in scenic.simulators.webots.model)\nI\nid (NetworkElement attribute)\nIn() (in module scenic.syntax.veneer)\nInconsistentScenarioError\ninferDistanceRelations() (in module scenic.syntax.relations)\ninferRelationsFrom() (in module scenic.syntax.relations)\ninferRelativeHeadingRelations() (in module scenic.syntax.relations)\ninferType() (AttributeDistribution static method)\n(OperatorDistribution static method)\ninit_theta (EdgeData attribute)\ninitApolloFor() (LGSVLSimulation method)\ninradius (Object property), [1]\nintersect() (MeshVolumeRegion method), [1]\n(PolygonalFootprintRegion method)\n(Region method), [1]\nIntersection (class in scenic.domains.driving.roads)\nintersection (DrivingObject property)\n(in module scenic.domains.driving.model)\n(Maneuver attribute)\nintersectionAt() (Network method)\nintersections (Network attribute)\nIntersects() (in module scenic.syntax.veneer)\nintersects() (MeshSurfaceRegion method), [1]\n(MeshVolumeRegion method), [1]\n(Object method), [1]\n(Region method), [1]\n\t\nInterval (in module scenic.core.object_types)\nInvalidScenarioError\nInvariantViolation, [1]\nInvocable (class in scenic.core.dynamics.invocables)\nironplateModels (in module scenic.simulators.carla.blueprints)\nis3Way (Intersection property)\nis4Way (Intersection property)\nis_temporal (PropositionNode attribute)\nis_typing_generic() (in module scenic.core.type_support)\nis_within_distance() (in module scenic.simulators.carla.misc)\nis_within_distance_ahead() (in module scenic.simulators.carla.misc)\nisA() (in module scenic.core.type_support)\nisForward (LaneSection attribute)\nisFunctionCall() (in module scenic.core.pruning)\nisLazy() (in module scenic.core.lazy_eval)\nisMethodCall() (in module scenic.core.pruning)\nisPhysicsEnabled() (in module scenic.simulators.webots.simulator)\nisPrimitive (Distribution property)\nisSignalized (Intersection property)\nisTrafficLight (Signal property)\nK\nkioskModels (in module scenic.simulators.carla.blueprints)\nL\nLane (class in scenic.domains.driving.roads)\nlane (DrivingObject property)\n(LaneSection attribute)\nlaneAt() (LaneGroup method)\n(Network method)\n(Road method)\n(RoadSection method)\nLaneChangeBehavior() (in module scenic.domains.driving.behaviors)\nLaneGroup (class in scenic.domains.driving.roads)\nlaneGroup (DrivingObject property)\nlaneGroupAt() (Network method)\n(Road method)\nlaneGroups (Network attribute)\n(Road attribute)\nlanes (LaneGroup attribute)\n(Network attribute)\n(Road attribute)\nLaneSection (class in scenic.domains.driving.roads)\nlaneSection (DrivingObject property)\nlaneSectionAt() (Network method)\n(Road method)\n\t\nlaneSections (Network attribute)\nlaneToLeft (LaneSection property)\nlaneToRight (LaneSection property)\nLazilyEvaluable (class in scenic.core.lazy_eval)\nLeft (class in scenic.syntax.ast)\nLeft() (in module scenic.syntax.veneer)\nLEFT_TURN (ManeuverType attribute)\nLeftSpec() (in module scenic.syntax.veneer)\nleftSurface (Object property), [1]\nLGSVLSimulation (class in scenic.simulators.lgsvl.simulator)\nLGSVLSimulator (class in scenic.simulators.lgsvl.simulator)\nlgsvlToScenicElevation() (in module scenic.simulators.lgsvl.utils)\nlgsvlToScenicPosition() (in module scenic.simulators.lgsvl.utils)\nlgsvlToScenicRotation() (in module scenic.simulators.lgsvl.utils)\nLine (class in scenic.formats.opendrive.xodr_parser)\nLinearElement (class in scenic.domains.driving.roads)\nlocalAnglesFor() (Orientation method), [1]\nLocalFinder (class in scenic.syntax.compiler)\nlocalPath() (in module scenic.syntax.veneer)\nM\nmailboxModels (in module scenic.simulators.carla.blueprints)\nmakeContext() (LazilyEvaluable static method)\nmakeDelayedFunctionCall() (in module scenic.core.lazy_eval)\nManeuver (class in scenic.domains.driving.roads)\nmaneuversAt() (Intersection method)\nManeuverType (class in scenic.domains.driving.roads)\nMap (class in scenic.simulators.gta.interface)\nMapWorkspace (class in scenic.simulators.gta.interface)\nmatchInRegion() (in module scenic.core.pruning)\nmatchPolygonalField() (in module scenic.core.pruning)\nmaxDistanceBetween() (in module scenic.core.pruning)\nmesh (VoxelRegion property)\nMeshRegion (class in scenic.core.regions)\nMeshShape (class in scenic.core.shapes)\n(class in scenic.syntax.veneer)\nMeshSurfaceRegion (class in scenic.core.regions)\n(class in scenic.syntax.veneer)\nMeshVolumeRegion (class in scenic.core.regions)\n(class in scenic.syntax.veneer)\nMethodDistribution (class in scenic.core.distributions)\nmid_loc (EdgeData attribute)\nmode2D (CompileOptions attribute)\nmodelOverride (CompileOptions attribute)\nModifier (class in scenic.syntax.veneer)\nModifyingSpecifier (class in scenic.core.specifiers)\nmodular scenario\nmodule\nscenic.core\nscenic.core.distributions\nscenic.core.dynamics\nscenic.core.dynamics.actions\nscenic.core.dynamics.behaviors\nscenic.core.dynamics.guards\nscenic.core.dynamics.invocables\nscenic.core.dynamics.scenarios\nscenic.core.dynamics.utils\nscenic.core.errors\nscenic.core.external_params\nscenic.core.geometry\nscenic.core.lazy_eval\nscenic.core.object_types\nscenic.core.propositions\nscenic.core.pruning\nscenic.core.regions\nscenic.core.requirements\nscenic.core.sample_checking\nscenic.core.scenarios\nscenic.core.serialization\nscenic.core.shapes\nscenic.core.simulators\nscenic.core.specifiers\nscenic.core.type_support\nscenic.core.utils\nscenic.core.vectors\nscenic.core.visibility\nscenic.core.workspaces\nscenic.domains\nscenic.domains.driving\nscenic.domains.driving.actions\nscenic.domains.driving.behaviors\nscenic.domains.driving.controllers\nscenic.domains.driving.model\nscenic.domains.driving.roads\nscenic.domains.driving.simulators\nscenic.domains.driving.workspace\nscenic.formats\nscenic.formats.opendrive\nscenic.formats.opendrive.workspace\nscenic.formats.opendrive.xodr_parser\nscenic.simulators\nscenic.simulators.carla\nscenic.simulators.carla.actions\nscenic.simulators.carla.behaviors\nscenic.simulators.carla.blueprints\nscenic.simulators.carla.misc\nscenic.simulators.carla.model\nscenic.simulators.carla.simulator\nscenic.simulators.gta\nscenic.simulators.gta.center_detection\nscenic.simulators.gta.img_modf\nscenic.simulators.gta.interface\nscenic.simulators.gta.map\nscenic.simulators.gta.messages\nscenic.simulators.gta.model\nscenic.simulators.lgsvl\nscenic.simulators.lgsvl.actions\nscenic.simulators.lgsvl.behaviors\nscenic.simulators.lgsvl.model\nscenic.simulators.lgsvl.simulator\nscenic.simulators.lgsvl.utils\nscenic.simulators.newtonian\nscenic.simulators.newtonian.driving_model\nscenic.simulators.newtonian.model\nscenic.simulators.newtonian.simulator\nscenic.simulators.utils\nscenic.simulators.utils.colors\nscenic.simulators.webots\nscenic.simulators.webots.actions\nscenic.simulators.webots.guideways\nscenic.simulators.webots.guideways.interface\nscenic.simulators.webots.guideways.intersection\nscenic.simulators.webots.guideways.model\nscenic.simulators.webots.model\nscenic.simulators.webots.road\nscenic.simulators.webots.road.car_models\nscenic.simulators.webots.road.interface\nscenic.simulators.webots.road.model\nscenic.simulators.webots.road.world\nscenic.simulators.webots.simulator\nscenic.simulators.webots.utils\nscenic.simulators.webots.WBTLexer\nscenic.simulators.webots.WBTParser\nscenic.simulators.webots.WBTVisitor\nscenic.simulators.webots.world_parser\nscenic.simulators.xplane\nscenic.simulators.xplane.model\nscenic.syntax\nscenic.syntax.ast\nscenic.syntax.compiler\nscenic.syntax.parser\nscenic.syntax.pygment\nscenic.syntax.relations\nscenic.syntax.translator\nscenic.syntax.veneer\n\t\nmonitor\nMonitor (class in scenic.core.dynamics.behaviors)\n(class in scenic.syntax.veneer)\nMonitorRequirement (class in scenic.core.requirements)\nmonotonicDistributionFunction() (in module scenic.core.distributions)\nmotorcycleModels (in module scenic.simulators.carla.blueprints)\nMultiplexerDistribution (class in scenic.core.distributions)\nmutate() (in module scenic.syntax.veneer)\nMutator (class in scenic.core.object_types)\n(class in scenic.syntax.veneer)\nN\nname (Modifier attribute)\n(NetworkElement attribute)\nneedsLazyEvaluation() (in module scenic.core.lazy_eval)\nneedsSampling() (in module scenic.core.lazy_eval)\nNetwork (class in scenic.domains.driving.roads)\nnetwork (in module scenic.domains.driving.model)\n(NetworkElement attribute)\nNetwork.DigestMismatchError\nNetworkElement (class in scenic.domains.driving.roads)\nNewtonianSimulation (class in scenic.simulators.newtonian.simulator)\nNewtonianSimulator (class in scenic.simulators.newtonian.simulator)\nnextSample() (ExternalSampler method)\n\t\nNode (class in scenic.simulators.webots.world_parser)\nNoisyColorDistribution (class in scenic.simulators.utils.colors)\nnominalDirectionsAt() (Network method)\n(NetworkElement method)\nNormal (class in scenic.core.distributions)\n(class in scenic.syntax.veneer)\nNotVisible() (in module scenic.syntax.veneer)\nNotVisibleFrom() (in module scenic.syntax.veneer)\nNotVisibleFromOp() (in module scenic.syntax.veneer)\nNotVisibleSpec() (in module scenic.syntax.veneer)\nnowhere (in module scenic.core.regions)\nNPCCar (class in scenic.domains.driving.model)\nNUE (in module scenic.simulators.webots.utils)\nO\nObject (class in scenic.core.object_types)\n(class in scenic.syntax.veneer)\nObject2D (class in scenic.core.object_types)\noccupiedSpace (Object property), [1]\nOffsetAction (class in scenic.domains.driving.actions)\n(class in scenic.simulators.webots.actions)\nOffsetAlong() (in module scenic.syntax.veneer)\nOffsetAlongSpec() (in module scenic.syntax.veneer)\nOffsetBy() (in module scenic.syntax.veneer)\noldBlueprintNames (in module scenic.simulators.carla.blueprints)\nOn() (in module scenic.syntax.veneer)\nonSurface (Object property), [1]\nopenDriveID (Signal attribute)\n\t\nOperatorDistribution (class in scenic.core.distributions)\nopp_loc (EdgeData attribute)\nopposite (LaneGroup property)\noppositeLaneGroup (DrivingObject property)\nOptions (class in scenic.core.distributions)\n(class in scenic.syntax.veneer)\norient() (Region method), [1]\nOrientation (class in scenic.core.vectors)\n(class in scenic.syntax.veneer)\nOrientationMutator (class in scenic.core.object_types)\nOrientedPoint (class in scenic.core.object_types)\n(class in scenic.syntax.veneer)\nOrientedPoint2D (class in scenic.core.object_types)\nOSMObject (class in scenic.simulators.webots.road.interface)\nP\nParam (class in scenic.syntax.ast)\nparam() (in module scenic.syntax.veneer)\nParamCubic (class in scenic.formats.opendrive.xodr_parser)\nparameter (class in scenic.syntax.ast)\nparamOverrides (CompileOptions attribute)\nparse() (in module scenic.simulators.webots.world_parser)\nparse_file() (in module scenic.syntax.parser)\nparse_string() (in module scenic.syntax.parser)\nParseCompileError\nPathRegion (class in scenic.core.regions)\n(class in scenic.syntax.veneer)\nPedestrian (class in scenic.domains.driving.model)\n(class in scenic.simulators.carla.model)\nPedestrianCrossing (class in scenic.domains.driving.roads)\n(class in scenic.simulators.webots.road.interface)\nPegenLexer (class in scenic.syntax.pygment)\npickledExt (Network attribute)\nPIDLateralController (class in scenic.domains.driving.controllers)\nPIDLongitudinalController (class in scenic.domains.driving.controllers)\nPiecewiseVectorField (class in scenic.core.vectors)\npitch (Orientation property), [1]\nplanarInradius (Object property), [1]\nPlane (class in scenic.simulators.xplane.model)\nplantpotModels (in module scenic.simulators.carla.blueprints)\nPoint (class in scenic.core.object_types)\n(class in scenic.syntax.veneer)\nPoint2D (class in scenic.core.object_types)\npoint_at() (Curve method)\npointAlongBy() (PolylineRegion method), [1]\nPointInRegionDistribution (class in scenic.core.regions)\n\t\nPointSetRegion (class in scenic.core.regions)\n(class in scenic.syntax.veneer)\nPoly3 (class in scenic.formats.opendrive.xodr_parser)\nPolygonalFootprintRegion (class in scenic.core.regions)\nPolygonalRegion (class in scenic.core.regions)\n(class in scenic.syntax.veneer)\nPolygonalVectorField (class in scenic.core.vectors)\n(class in scenic.syntax.veneer)\nPolylineRegion (class in scenic.core.regions)\n(class in scenic.syntax.veneer)\npositionFromScenic() (WebotsCoordinateSystem method)\nPositionMutator (class in scenic.core.object_types)\npositionToScenic() (WebotsCoordinateSystem method)\npositive() (in module scenic.simulators.carla.misc)\npostMortemDebugging (in module scenic.core.errors)\npostMortemRejections (in module scenic.core.errors)\nPreconditionViolation, [1]\npreferred orientation\nprojectVector() (MeshRegion method)\n(Region method), [1]\nProp (class in scenic.simulators.carla.model)\nPropertyDefault (class in scenic.core.specifiers)\nPropositionNode (class in scenic.core.propositions)\nprune() (in module scenic.core.pruning)\npruneContainment() (in module scenic.core.pruning)\npruneRelativeHeading() (in module scenic.core.pruning)\npurgeModulesUnsafeToCache() (in module scenic.syntax.translator)\nPythonCompileError\nPYTHONPATH\nPythonSnippetLexer (class in scenic.syntax.pygment)\nPYTHONWARNINGS\nR\nRandomControlFlowError\nRange (class in scenic.core.distributions)\n(class in scenic.syntax.veneer)\nRectangularRegion (class in scenic.core.regions)\n(class in scenic.syntax.veneer)\nRegion (class in scenic.core.regions)\n(class in scenic.syntax.veneer)\nregionFromShapelyObject() (in module scenic.core.regions)\nRegulatedControlAction (class in scenic.domains.driving.actions)\nRejectionException, [1]\nRejectSimulationException\nrel_to_abs() (Curve method)\nRelativeHeading() (in module scenic.syntax.veneer)\nrelativeHeadingRange() (in module scenic.core.pruning)\nRelativeHeadingRelation (class in scenic.syntax.relations)\nRelativePosition() (in module scenic.syntax.veneer)\nRelativeTo() (in module scenic.syntax.veneer)\nrepairMesh() (in module scenic.core.utils)\nreplay() (Simulator method)\nreplayFormatVersion() (Serializer class method)\nReplayMode (class in scenic.core.simulators)\nrequire() (in module scenic.syntax.veneer)\nrequiredProperties() (in module scenic.core.lazy_eval)\nRequirementType (class in scenic.core.requirements)\nresample() (in module scenic.syntax.veneer)\nresetExternalSampler() (Scenario method)\n\t\nresolveFor() (PropertyDefault method)\nreverseManeuvers (Maneuver property)\nRight (class in scenic.syntax.ast)\nRight() (in module scenic.syntax.veneer)\nRIGHT_TURN (ManeuverType attribute)\nRightSpec() (in module scenic.syntax.veneer)\nrightSurface (Object property), [1]\nRoad (class in scenic.domains.driving.roads)\n(class in scenic.simulators.webots.road.interface)\nroad (DrivingObject property)\n(in module scenic.domains.driving.model)\n(in module scenic.simulators.gta.model)\n(LaneGroup attribute)\n(LaneSection attribute)\nroadAt() (Network method)\nroadDirection (in module scenic.domains.driving.model)\n(in module scenic.simulators.gta.model)\n(Network attribute)\nRoadLink (class in scenic.formats.opendrive.xodr_parser)\nroadOrShoulder (in module scenic.domains.driving.model)\nroads (Network attribute)\nRoadSection (class in scenic.domains.driving.roads)\nroadSections (Network attribute)\nroll (Orientation property), [1]\nrotatedBy() (Vector method), [1]\nrun_step() (PIDLateralController method)\n(PIDLongitudinalController method)\nS\nSamplable (class in scenic.core.distributions)\nsample() (ExternalSampler method)\n(Samplable method)\nsampleAll() (Samplable static method)\nsampleGiven() (ExternalParameter method)\n(Samplable method)\nSamplingRequirement (class in scenic.core.requirements)\nscalarOperator() (in module scenic.core.vectors)\nScenario (class in scenic.core.scenarios)\nscenario (CompileOptions attribute)\nscenarioComplete (TerminationType attribute)\nscenarioFromFile() (in module scenic)\n(in module scenic.syntax.translator)\nscenarioFromString() (in module scenic)\n(in module scenic.syntax.translator)\nScene (class in scenic.core.scenarios)\nsceneFormatVersion() (Serializer class method)\nsceneFromBytes() (Scenario method)\nsceneToBytes() (Scenario method)\nscenic.core\nmodule\nscenic.core.distributions\nmodule\nscenic.core.dynamics\nmodule\nscenic.core.dynamics.actions\nmodule\nscenic.core.dynamics.behaviors\nmodule\nscenic.core.dynamics.guards\nmodule\nscenic.core.dynamics.invocables\nmodule\nscenic.core.dynamics.scenarios\nmodule\nscenic.core.dynamics.utils\nmodule\nscenic.core.errors\nmodule\nscenic.core.external_params\nmodule\nscenic.core.geometry\nmodule\nscenic.core.lazy_eval\nmodule\nscenic.core.object_types\nmodule\nscenic.core.propositions\nmodule\nscenic.core.pruning\nmodule\nscenic.core.regions\nmodule\nscenic.core.requirements\nmodule\nscenic.core.sample_checking\nmodule\nscenic.core.scenarios\nmodule\nscenic.core.serialization\nmodule\nscenic.core.shapes\nmodule\nscenic.core.simulators\nmodule\nscenic.core.specifiers\nmodule\nscenic.core.type_support\nmodule\nscenic.core.utils\nmodule\nscenic.core.vectors\nmodule\nscenic.core.visibility\nmodule\nscenic.core.workspaces\nmodule\nscenic.domains\nmodule\nscenic.domains.driving\nmodule\nscenic.domains.driving.actions\nmodule\nscenic.domains.driving.behaviors\nmodule\nscenic.domains.driving.controllers\nmodule\nscenic.domains.driving.model\nmodule\nscenic.domains.driving.roads\nmodule\nscenic.domains.driving.simulators\nmodule\nscenic.domains.driving.workspace\nmodule\nscenic.formats\nmodule\nscenic.formats.opendrive\nmodule\nscenic.formats.opendrive.workspace\nmodule\nscenic.formats.opendrive.xodr_parser\nmodule\nscenic.simulators\nmodule\nscenic.simulators.carla\nmodule\nscenic.simulators.carla.actions\nmodule\nscenic.simulators.carla.behaviors\nmodule\nscenic.simulators.carla.blueprints\nmodule\nscenic.simulators.carla.misc\nmodule\nscenic.simulators.carla.model\nmodule\nscenic.simulators.carla.simulator\nmodule\nscenic.simulators.gta\nmodule\nscenic.simulators.gta.center_detection\nmodule\nscenic.simulators.gta.img_modf\nmodule\nscenic.simulators.gta.interface\nmodule\nscenic.simulators.gta.map\nmodule\nscenic.simulators.gta.messages\nmodule\nscenic.simulators.gta.model\nmodule\nscenic.simulators.lgsvl\nmodule\nscenic.simulators.lgsvl.actions\nmodule\nscenic.simulators.lgsvl.behaviors\nmodule\nscenic.simulators.lgsvl.model\nmodule\nscenic.simulators.lgsvl.simulator\nmodule\nscenic.simulators.lgsvl.utils\nmodule\nscenic.simulators.newtonian\nmodule\nscenic.simulators.newtonian.driving_model\nmodule\nscenic.simulators.newtonian.model\nmodule\nscenic.simulators.newtonian.simulator\nmodule\nscenic.simulators.utils\nmodule\n\t\nscenic.simulators.utils.colors\nmodule\nscenic.simulators.webots\nmodule\nscenic.simulators.webots.actions\nmodule\nscenic.simulators.webots.guideways\nmodule\nscenic.simulators.webots.guideways.interface\nmodule\nscenic.simulators.webots.guideways.intersection\nmodule\nscenic.simulators.webots.guideways.model\nmodule\nscenic.simulators.webots.model\nmodule\nscenic.simulators.webots.road\nmodule\nscenic.simulators.webots.road.car_models\nmodule\nscenic.simulators.webots.road.interface\nmodule\nscenic.simulators.webots.road.model\nmodule\nscenic.simulators.webots.road.world\nmodule\nscenic.simulators.webots.simulator\nmodule\nscenic.simulators.webots.utils\nmodule\nscenic.simulators.webots.WBTLexer\nmodule\nscenic.simulators.webots.WBTParser\nmodule\nscenic.simulators.webots.WBTVisitor\nmodule\nscenic.simulators.webots.world_parser\nmodule\nscenic.simulators.xplane\nmodule\nscenic.simulators.xplane.model\nmodule\nscenic.syntax\nmodule\nscenic.syntax.ast\nmodule\nscenic.syntax.compiler\nmodule\nscenic.syntax.parser\nmodule\nscenic.syntax.pygment\nmodule\nscenic.syntax.relations\nmodule\nscenic.syntax.translator\nmodule\nscenic.syntax.veneer\nmodule\nScenicError\nScenicGrammarLexer (class in scenic.syntax.pygment)\nScenicLexer (class in scenic.syntax.pygment)\nScenicParseError\nScenicPropertyLexer (class in scenic.syntax.pygment)\nScenicRequirementLexer (class in scenic.syntax.pygment)\nScenicSnippetLexer (class in scenic.syntax.pygment)\nScenicSpecifierLexer (class in scenic.syntax.pygment)\nScenicStyle (class in scenic.syntax.pygment)\nScenicSyntaxError\nscenicToJSON() (in module scenic.core.serialization)\nscenicToSchematicCoords() (Workspace method), [1]\nscenicToWebotsPosition() (in module scenic.simulators.webots.road.interface)\nscenicToWebotsRotation() (in module scenic.simulators.webots.road.interface)\nscheduleForAgents() (Simulation method)\nsectionAt() (Lane method)\n(Road method)\nsections (Road attribute)\nSectorRegion (class in scenic.core.regions)\n(class in scenic.syntax.veneer)\nSerializationError\nSerializer (class in scenic.core.serialization)\nserializeValue() (Distribution method)\nSetBrakeAction (class in scenic.domains.driving.actions)\nsetDebuggingOptions() (in module scenic)\n(in module scenic.core.errors)\nSetHandBrakeAction (class in scenic.domains.driving.actions)\nsetLocalWorld() (in module scenic.simulators.webots.road.world)\nSetPositionAction (class in scenic.domains.driving.actions)\nSetReverseAction (class in scenic.domains.driving.actions)\nSetSpeedAction (class in scenic.domains.driving.actions)\nSetSteerAction (class in scenic.domains.driving.actions)\nSetThrottleAction (class in scenic.domains.driving.actions)\nSetTrafficLightAction (class in scenic.simulators.carla.actions)\nsetup() (Simulation method)\nSetVehicleLightStateAction (class in scenic.simulators.carla.actions)\nSetVelocityAction (class in scenic.domains.driving.actions)\nSetWalkingDirectionAction (class in scenic.domains.driving.actions)\nSetWalkingSpeedAction (class in scenic.domains.driving.actions)\nShape (class in scenic.core.shapes)\n(class in scenic.syntax.veneer)\nshiftedBy() (LaneSection method)\nshiftLanes() (Road method)\nShoulder (class in scenic.domains.driving.roads)\nshoulder (in module scenic.domains.driving.model)\n(LaneGroup property)\nshoulders (Network attribute)\nshow() (Network method)\nshow2D() (Scene method)\n(Workspace method), [1]\nshow3D() (Scene method)\n(Workspace method), [1]\nshowInternalBacktrace (in module scenic.core.errors)\nSidewalk (class in scenic.domains.driving.roads)\nsidewalk (in module scenic.domains.driving.model)\n(LaneGroup property)\nsidewalkRegion (Road attribute)\nsidewalks (Network attribute)\n(Road attribute)\nSignal (class in scenic.domains.driving.roads)\n(class in scenic.formats.opendrive.xodr_parser)\nsignedDistanceTo() (PolylineRegion method), [1]\nsimulate() (Simulator method)\nSimulation (class in scenic.core.simulators)\nsimulation() (in module scenic.syntax.veneer)\nSimulationCreationError\nsimulationFromBytes() (Scenario method)\nSimulationResult (class in scenic.core.simulators)\nsimulationTerminationCondition (TerminationType attribute)\nsimulationToBytes() (Scenario method)\nSimulator (class in scenic.core.simulators)\nSimulatorInterfaceWarning\nSliceDistribution (class in scenic.core.distributions)\nslowerLane (LaneSection property)\nsortedRequirements() (WeightedAcceptanceChecker method)\nSpecifier (class in scenic.core.specifiers)\nSpecifierError\nspeedLimit (NetworkElement attribute)\nsphericalCoordinates() (Vector method), [1]\nSpheroidRegion (class in scenic.core.regions)\n(class in scenic.syntax.veneer)\nSpheroidShape (class in scenic.core.shapes)\n(class in scenic.syntax.veneer)\nStarredDistribution (class in scenic.core.distributions)\nstart (PolylineRegion property), [1]\nstartDynamicSimulation() (Object method), [1]\nstartLane (Maneuver attribute)\nSteeringAction (class in scenic.domains.driving.actions)\nSteers (class in scenic.domains.driving.actions)\nstep() (Simulation method)\nstoreScenarioStateIn() (in module scenic.syntax.translator)\nSTRAIGHT (ManeuverType attribute)\nStuckBehaviorWarning\nstuckBehaviorWarningTimeout (in module scenic.core.dynamics)\nsupportInterval() (Distribution method)\n(in module scenic.core.distributions)\nsurface (Object property), [1]\nSurfaceCollisionTrimesh (class in scenic.core.regions)\nT\ntableModels (in module scenic.simulators.carla.blueprints)\ntags (NetworkElement attribute)\ntangent (EdgeData attribute)\nTarget (class in scenic.syntax.parser)\ntemporal requirement\nterminate_simulation_when() (in module scenic.syntax.veneer)\nterminate_when() (in module scenic.syntax.veneer)\nterminatedByBehavior (TerminationType attribute)\nterminatedByMonitor (TerminationType attribute)\nTerminationType (class in scenic.core.simulators)\nterminator (Modifier attribute)\nTerrain (class in scenic.simulators.webots.model)\ntimeLimit (TerminationType attribute)\nto_points() (Curve method)\ntoDistribution() (in module scenic.core.distributions)\ntoHeading() (in module scenic.core.type_support)\ntoLazyValue() (in module scenic.core.lazy_eval)\ntolerance (Network attribute)\ntoOrientation() (in module scenic.core.type_support)\nTop (class in scenic.syntax.ast)\nTop() (in module scenic.syntax.veneer)\nTopBackLeft (class in scenic.syntax.ast)\nTopBackLeft() (in module scenic.syntax.veneer)\nTopBackRight (class in scenic.syntax.ast)\nTopBackRight() (in module scenic.syntax.veneer)\n\t\nTopFrontLeft (class in scenic.syntax.ast)\nTopFrontLeft() (in module scenic.syntax.veneer)\nTopFrontRight (class in scenic.syntax.ast)\nTopFrontRight() (in module scenic.syntax.veneer)\ntopLevelNamespace() (in module scenic.syntax.translator)\ntopSurface (Object property), [1]\ntoScalar() (in module scenic.core.type_support)\ntoType() (in module scenic.core.type_support)\ntoTypes() (in module scenic.core.type_support)\ntoVector() (in module scenic.core.type_support)\ntrafficwarningModels (in module scenic.simulators.carla.blueprints)\nTransformer (class in scenic.syntax.compiler)\ntrashModels (in module scenic.simulators.carla.blueprints)\ntriangulatePolygon() (in module scenic.core.geometry)\nTriangulationError\ntruckModels (in module scenic.simulators.carla.blueprints)\nTruncatedNormal (class in scenic.core.distributions)\n(class in scenic.syntax.veneer)\nTryInterrupt (class in scenic.syntax.ast)\nTupleDistribution (class in scenic.core.distributions)\nTurnBehavior() (in module scenic.domains.driving.behaviors)\ntype (Maneuver attribute)\n(Signal attribute)\nTypecheckedDistribution (class in scenic.core.type_support)\nTypeChecker (class in scenic.core.type_support)\nTypeEqualityChecker (class in scenic.core.type_support)\nU\nU_TURN (ManeuverType attribute)\nuid (NetworkElement attribute)\nUnaryProposition (class in scenic.core.propositions)\nunderlyingFunction() (in module scenic.core.distributions)\nunderlyingType() (in module scenic.core.type_support)\nunfreezeTrafficLights() (in module scenic.simulators.carla.model)\nunifierOfTypes() (in module scenic.core.type_support)\nUniform() (in module scenic.core.distributions)\n(in module scenic.syntax.veneer)\nuniformColor() (Color static method)\n\t\nUniformDistribution (class in scenic.core.distributions)\nuniformPointIn() (Region static method), [1]\nuniformPointInner() (Region method), [1]\nunifyingType() (in module scenic.core.type_support)\nunifyMesh() (in module scenic.core.utils)\nunion() (MeshVolumeRegion method), [1]\n(PolygonalFootprintRegion method)\n(Region method), [1]\nunpacksDistributions() (in module scenic.core.distributions)\nupdateMetrics() (WeightedAcceptanceChecker method)\nupdateObjects() (Simulation method)\nV\nvalue (Modifier attribute)\nvalueFor() (ExternalSampler method)\nvalueInContext() (in module scenic.core.lazy_eval)\nvaluesHaveDiverged() (Simulation method)\nVector (class in scenic.core.vectors)\n(class in scenic.syntax.veneer)\nvector() (in module scenic.simulators.carla.misc)\nVectorDistribution (class in scenic.core.vectors)\nvectorDistributionMethod() (in module scenic.core.vectors)\nVectorField (class in scenic.core.vectors)\n(class in scenic.syntax.veneer)\nVectorlike (in module scenic.domains.driving.roads)\nVectorMethodDistribution (class in scenic.core.vectors)\nvectorOperator() (in module scenic.core.vectors)\nVectorOperatorDistribution (class in scenic.core.vectors)\nVehicle (class in scenic.domains.driving.model)\n(class in scenic.simulators.carla.model)\nVehicleType (class in scenic.domains.driving.roads)\nvehicleTypes (NetworkElement attribute)\nvendingMachineModels (in module scenic.simulators.carla.blueprints)\nverbosePrint() (in module scenic.syntax.veneer)\nverbosityLevel (in module scenic.core.errors)\nVerifaiDiscreteRange (class in scenic.core.external_params)\n(class in scenic.syntax.veneer)\n\t\nVerifaiOptions (class in scenic.core.external_params)\n(class in scenic.syntax.veneer)\nVerifaiParameter (class in scenic.core.external_params)\n(class in scenic.syntax.veneer)\nVerifaiRange (class in scenic.core.external_params)\n(class in scenic.syntax.veneer)\nVerifaiSampler (class in scenic.core.external_params)\nViewRegion (class in scenic.core.regions)\nviolationMsg (SamplingRequirement property)\nvisibilityBound() (in module scenic.core.pruning)\nvisible region\nVisible() (in module scenic.syntax.veneer)\nVisibleFrom() (in module scenic.syntax.veneer)\nVisibleFromOp() (in module scenic.syntax.veneer)\nvisibleRegion (Object property), [1]\n(Object2D property)\n(OrientedPoint property), [1]\n(OrientedPoint2D property)\n(Point property), [1]\n(Point2D property)\nVisibleSpec() (in module scenic.syntax.veneer)\nvoxelized() (MeshVolumeRegion method), [1]\nVoxelRegion (class in scenic.core.regions)\nW\nwalkerModels (in module scenic.simulators.carla.blueprints)\nWalkForwardBehavior() (in module scenic.domains.driving.behaviors)\nWalkingAction (class in scenic.domains.driving.actions)\nWalks (class in scenic.domains.driving.actions)\nWebotsCoordinateSystem (class in scenic.simulators.webots.utils)\nWebotsObject (class in scenic.simulators.webots.model)\nWebotsSimulation (class in scenic.simulators.webots.simulator)\nWebotsSimulator (class in scenic.simulators.webots.simulator)\nwebotsToScenicPosition() (in module scenic.simulators.webots.road.interface)\nwebotsToScenicRotation() (in module scenic.simulators.webots.road.interface)\nWeightedAcceptanceChecker (class in scenic.core.sample_checking)\nWith() (in module scenic.syntax.veneer)\nwithinDistanceToAnyCars() (in module scenic.domains.driving.model)\n\t\nwithinDistanceToAnyObjs() (in module scenic.domains.driving.model)\nwithinDistanceToObjsInLane() (in module scenic.domains.driving.model)\nwithPrior() (VerifaiParameter static method), [1]\nworkspace\nWorkspace (class in scenic.core.workspaces)\n(class in scenic.syntax.ast)\n(class in scenic.syntax.veneer)\nworkspace() (in module scenic.syntax.veneer)\nworld model\nworldPath (in module scenic.simulators.webots.road.world)\nWriteFileAction (class in scenic.simulators.webots.actions)\nwriteReplayHeader() (Serializer method)\nwriteScene() (Serializer method)\nwriteValue() (Serializer method)\nY\nyaw (Orientation property), [1]\nZ\nzoomAround() (Workspace method), [1]\n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Python Module Index — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/py-modindex.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Python Module Index\nPython Module Index\ns\n\t \t\n\ts\t\n\tscenic\t\n\t    scenic.core\t\n\t    scenic.core.distributions\t\n\t    scenic.core.dynamics\t\n\t    scenic.core.dynamics.actions\t\n\t    scenic.core.dynamics.behaviors\t\n\t    scenic.core.dynamics.guards\t\n\t    scenic.core.dynamics.invocables\t\n\t    scenic.core.dynamics.scenarios\t\n\t    scenic.core.dynamics.utils\t\n\t    scenic.core.errors\t\n\t    scenic.core.external_params\t\n\t    scenic.core.geometry\t\n\t    scenic.core.lazy_eval\t\n\t    scenic.core.object_types\t\n\t    scenic.core.propositions\t\n\t    scenic.core.pruning\t\n\t    scenic.core.regions\t\n\t    scenic.core.requirements\t\n\t    scenic.core.sample_checking\t\n\t    scenic.core.scenarios\t\n\t    scenic.core.serialization\t\n\t    scenic.core.shapes\t\n\t    scenic.core.simulators\t\n\t    scenic.core.specifiers\t\n\t    scenic.core.type_support\t\n\t    scenic.core.utils\t\n\t    scenic.core.vectors\t\n\t    scenic.core.visibility\t\n\t    scenic.core.workspaces\t\n\t    scenic.domains\t\n\t    scenic.domains.driving\t\n\t    scenic.domains.driving.actions\t\n\t    scenic.domains.driving.behaviors\t\n\t    scenic.domains.driving.controllers\t\n\t    scenic.domains.driving.model\t\n\t    scenic.domains.driving.roads\t\n\t    scenic.domains.driving.simulators\t\n\t    scenic.domains.driving.workspace\t\n\t    scenic.formats\t\n\t    scenic.formats.opendrive\t\n\t    scenic.formats.opendrive.workspace\t\n\t    scenic.formats.opendrive.xodr_parser\t\n\t    scenic.simulators\t\n\t    scenic.simulators.carla\t\n\t    scenic.simulators.carla.actions\t\n\t    scenic.simulators.carla.behaviors\t\n\t    scenic.simulators.carla.blueprints\t\n\t    scenic.simulators.carla.misc\t\n\t    scenic.simulators.carla.model\t\n\t    scenic.simulators.carla.simulator\t\n\t    scenic.simulators.gta\t\n\t    scenic.simulators.gta.center_detection\t\n\t    scenic.simulators.gta.img_modf\t\n\t    scenic.simulators.gta.interface\t\n\t    scenic.simulators.gta.map\t\n\t    scenic.simulators.gta.messages\t\n\t    scenic.simulators.gta.model\t\n\t    scenic.simulators.lgsvl\t\n\t    scenic.simulators.lgsvl.actions\t\n\t    scenic.simulators.lgsvl.behaviors\t\n\t    scenic.simulators.lgsvl.model\t\n\t    scenic.simulators.lgsvl.simulator\t\n\t    scenic.simulators.lgsvl.utils\t\n\t    scenic.simulators.newtonian\t\n\t    scenic.simulators.newtonian.driving_model\t\n\t    scenic.simulators.newtonian.model\t\n\t    scenic.simulators.newtonian.simulator\t\n\t    scenic.simulators.utils\t\n\t    scenic.simulators.utils.colors\t\n\t    scenic.simulators.webots\t\n\t    scenic.simulators.webots.actions\t\n\t    scenic.simulators.webots.guideways\t\n\t    scenic.simulators.webots.guideways.interface\t\n\t    scenic.simulators.webots.guideways.intersection\t\n\t    scenic.simulators.webots.guideways.model\t\n\t    scenic.simulators.webots.model\t\n\t    scenic.simulators.webots.road\t\n\t    scenic.simulators.webots.road.car_models\t\n\t    scenic.simulators.webots.road.interface\t\n\t    scenic.simulators.webots.road.model\t\n\t    scenic.simulators.webots.road.world\t\n\t    scenic.simulators.webots.simulator\t\n\t    scenic.simulators.webots.utils\t\n\t    scenic.simulators.webots.WBTLexer\t\n\t    scenic.simulators.webots.WBTParser\t\n\t    scenic.simulators.webots.WBTVisitor\t\n\t    scenic.simulators.webots.world_parser\t\n\t    scenic.simulators.xplane\t\n\t    scenic.simulators.xplane.model\t\n\t    scenic.syntax\t\n\t    scenic.syntax.ast\t\n\t    scenic.syntax.compiler\t\n\t    scenic.syntax.parser\t\n\t    scenic.syntax.pygment\t\n\t    scenic.syntax.relations\t\n\t    scenic.syntax.translator\t\n\t    scenic.syntax.veneer\t\n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Credits — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/credits.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Credits\n Edit on GitHub\nCredits\n\nIf you use Scenic, we request that you cite our CAV 2023 paper, our 2022 journal paper, and/or our original PLDI 2019 paper.\n\nScenic is primarily maintained by Daniel J. Fremont.\n\nThe Scenic project was started at UC Berkeley in Sanjit Seshia’s research group.\n\nThe language was initially developed by Daniel J. Fremont, Tommaso Dreossi, Shromona Ghosh, Xiangyu Yue, Alberto L. Sangiovanni-Vincentelli, and Sanjit A. Seshia.\n\nEdward Kim assisted in developing the library for dynamic driving scenarios and putting together this documentation.\n\nEric Vin, Matthew Rhea, and Ellen Kalvan developed Scenic’s support for 3D geometry. Shun Kashiwa developed the auto-generated parser for Scenic 3.0 and its support for temporal requirements.\n\nThe Scenic tool and example scenarios have benefitted from additional code contributions from:\n\nArmando Bañuelos\n\nJohnathan Chiu\n\nGreg Crow\n\nFrancis Indaheng\n\nMartin Jansa (LG Electronics, Inc.)\n\nAbolfazl Karimi\n\nKevin Li\n\nGuillermo López\n\nShalin Mehta\n\nJoel Moriana\n\nGaurav Rao\n\nAmeesh Shah\n\nJay Shenoy\n\nMirco Theile\n\nKesav Viswanadha\n\nQiancheng Wu\n\nWilson Wu\n\nFinally, many other people provided helpful advice and discussions, including:\n\nAnkush Desai\n\nAlastair Donaldson\n\nAndrew Gordon\n\nSteve Lemke\n\nDejan Nickovic\n\nJonathan Ragan-Kelley\n\nSriram Rajamani\n\nGerman Ros\n\nMarcell Vazquez-Chanlatte\n\neveryone who has reported bugs at our GitHub repository.\n\n Previous\n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "spheres_in_region.jpg (1027×1024)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/spheres_in_region.jpg",
    "html": ""
  },
  {
    "title": "simple_random_3.jpg (1024×928)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/simple_random_3.jpg",
    "html": ""
  },
  {
    "title": "simple_random_2.jpg (1024×1310)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/simple_random_2.jpg",
    "html": ""
  },
  {
    "title": "simple_random_1.jpg (1024×626)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/simple_random_1.jpg",
    "html": ""
  },
  {
    "title": "cone_plane_chair.jpg (1024×819)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/cone_plane_chair.jpg",
    "html": ""
  },
  {
    "title": "ego_box.jpg (745×704)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/ego_box.jpg",
    "html": ""
  },
  {
    "title": "crossing.png (278×295)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/crossing.png",
    "html": ""
  },
  {
    "title": "narrowGoal.jpg (1024×710)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/narrowGoal.jpg",
    "html": ""
  },
  {
    "title": "pedestrian.png (857×857)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/pedestrian.png",
    "html": ""
  },
  {
    "title": "vacuumSimple.jpg (1028×1024)",
    "url": "https://docs.scenic-lang.org/en/latest/_images/vacuumSimple.jpg",
    "html": ""
  },
  {
    "title": "Interfacing to New Simulators — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/new_simulator.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\nUsing the Scenic API\nDefining a World Model\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Interfacing to New Simulators\n Edit on GitHub\nInterfacing to New Simulators\n\nTo interface Scenic to a new simulator, there are two steps: using the Scenic API to compile scenarios, generate scenes, and orchestrate dynamic simulations, and writing a Scenic library defining the virtual world provided by the simulator.\n\nUsing the Scenic API\n\nScenic’s Python API is covered in more detail in our Using Scenic Programmatically page; we summarize the main steps here.\n\nCompiling a Scenic scenario is easy: just call the scenic.scenarioFromFile function with the path to a Scenic file (there’s also a variant scenic.scenarioFromString which works on strings). This returns a Scenario object representing the scenario; to sample a scene from it, call its generate method. Scenes are represented by Scene objects, from which you can extract the objects and their properties as well as the values of the global parameters (see the Scene documentation for details).\n\nSupporting dynamic scenarios requires additionally implementing a subclass of Simulator which communicates periodically with your simulator to implement the actions taken by dynamic agents and read back the state of the simulation. See the documentation of Simulator and Simulation for details on the methods which need to be implemented, and the scenic.simulators.carla.simulator and scenic.simulators.webots.simulator modules for examples.\n\nDefining a World Model\n\nTo make writing scenarios for your simulator easier, you should write a Scenic library specifying all the relevant information about the simulated world. This world model could include:\n\nScenic classes (subclasses of Object) corresponding to types of objects in the simulator;\n\ninstances of Region corresponding to locations of interest (e.g. one for each road);\n\na workspace specifying legal locations for objects (and optionally providing methods for schematically rendering scenes);\n\na set of actions which can be taken by dynamic agents during simulations;\n\nany other information or utility functions that might be useful in scenarios.\n\nThen any Scenic programs for your simulator can import this world model and make use of the information within.\n\nEach of the simulators natively supported by Scenic has a corresponding model.scenic file containing its world model. See the Supported Simulators page for links to the module under scenic.simulators for each simulator, where the world model can be found. For an example, see the scenic.simulators.lgsvl model, which specializes the simulator-agnostic model provided by the Driving Domain (in scenic.domains.driving.model).\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Supported Simulators — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/simulators.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nCurrently Supported\nDeprecated\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Supported Simulators\n Edit on GitHub\nSupported Simulators\n\nScenic is designed to be easily interfaced to any simulator (see Interfacing to New Simulators). On this page we list interfaces that we and others have developed; if you have a new interface, let us know and we’ll list it here!\n\nNote that not every interface supports all Scenic features: in particular, some interfaces do not support dynamic scenarios. See the individual entries for details on each interface’s capabilities and how to set it up.\n\nList of Simulators\n\nCurrently Supported\n\nBuilt-in Newtonian Simulator\n\nCARLA\n\nGrand Theft Auto V\n\nWebots\n\nX-Plane\n\nDeprecated\n\nLGSVL\n\nCurrently Supported\nBuilt-in Newtonian Simulator\n\nTo enable debugging of dynamic scenarios without having to install an external simulator, Scenic includes a simple 2D Newtonian physics simulator. The simulator supports scenarios written using the cross-platform Driving Domain, and can render top-down views showing the positions of objects relative to the road network. See the documentation of the scenic.simulators.newtonian module for details.\n\nCARLA\n\nOur interface to the CARLA simulator enables using Scenic to describe autonomous driving scenarios. The interface supports dynamic scenarios written using the CARLA world model (scenic.simulators.carla.model) as well as scenarios using the cross-platform Driving Domain. To use the interface, please follow these instructions:\n\nInstall the latest version of CARLA (we’ve tested versions 0.9.9 through 0.9.14) from the CARLA Release Page. Note that CARLA currently only supports Linux and Windows.\n\nInstall Scenic in your Python virtual environment as instructed in Getting Started with Scenic.\n\nWithin the same virtual environment, install CARLA’s Python API. How to do this depends on the CARLA version and whether you built it from source:\n\n0.9.12+Older VersionsBuilt from Source\n\nRun the following command, replacing X.Y.Z with the version of CARLA you installed:\n\npython -m pip install carla==X.Y.Z\n\n\nYou can check that the carla package was correctly installed by running python -c 'import carla': if it prints No module named 'carla', the installation didn’t work. We suggest upgrading to a newer version of CARLA so that you can use pip to install the Python API.\n\nTo start CARLA, run the command ./CarlaUE4.sh in your CARLA folder. Once CARLA is running, you can run dynamic Scenic scenarios following the instructions in the dynamics tutorial.\n\nGrand Theft Auto V\n\nThe interface to Grand Theft Auto V, used in our PLDI paper, allows Scenic to position cars within the game as well as to control the time of day and weather conditions. Many examples using the interface (including all scenarios from the paper) can be found in examples/gta. See the paper and scenic.simulators.gta for documentation.\n\nImporting scenes into GTA V and capturing rendered images requires a GTA V plugin, which you can find here.\n\nWebots\n\nWe have several interfaces to the Webots robotics simulator, for different use cases. Our main interface provides a generic world model that can be used with any Webots world and supports dynamic scenarios. See the examples/webots folder for example Scenic scenarios and Webots worlds using this interface, and scenic.simulators.webots for documentation.\n\nScenic also includes more specialized world models for use with Webots:\n\nA general model for traffic scenarios, used in our VerifAI paper. Examples using this model can be found in the VerifAI repository; see also the documentation of scenic.simulators.webots.road.\n\nNote\n\nThe last model above, and the example .wbt files for it, was written for the R2018 version of Webots. Relatively minor changes would be required to make it work with the newer open source versions of Webots. We may get around to porting them eventually; we’d also gladly accept a pull request!\n\nX-Plane\n\nOur interface to the X-Plane flight simulator enables using Scenic to describe aircraft taxiing scenarios. This interface is part of the VerifAI toolkit; documentation and examples can be found in the VerifAI repository.\n\nDeprecated\n\nScenic previously provided interfaces to these simulators, but no longer does. See individual entries for the last version of Scenic providing the interface and the reason it is no longer supported.\n\nLGSVL\n\nThe LGSVL simulator (a.k.a. SVL Simulator) was deprecated in Scenic 3.0, with the last version of Scenic supporting this simulator being 2.1. The original simulator is no longer usable due to LG shutting down its cloud service, but we are open to a PR targeting one of its forks.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Scenic Libraries — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/libraries.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSimulator Interfaces\nAbstract Domains\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Scenic Libraries\n Edit on GitHub\nScenic Libraries\n\nOne of the strengths of Scenic is its ability to reuse functions, classes, and behaviors across many scenarios, simplifying the process of writing complex scenarios. This page describes the libraries built into Scenic to facilitate scenario writing by end users.\n\nSimulator Interfaces\n\nMany of the simulator interfaces provide utility functions which are useful when writing scenarios for particular simulators. See the documentation for each simulator on the Supported Simulators page, as well as the corresponding module under scenic.simulators.\n\nAbstract Domains\n\nTo enable cross-platform scenarios which are not specific to one simulator, Scenic defines abstract domains which provide APIs for particular application domains like driving scenarios. An abstract domain defines a protocol which can be implemented by various simulator interfaces so that scenarios written for that domain can be executed in those simulators. For example, a scenario written for our driving domain can be run in both LGSVL and CARLA.\n\nA domain provides a Scenic world model which defines Scenic classes for the various types of objects that occur in its scenarios. The model also provides a simulator-agnostic way to access the geometry of the simulated world, by defining regions, vector fields, and other objects as appropriate (for example, the driving domain provides a Network class abstracting a road network). For domains which support dynamic scenarios, the model will also define a set of simulator-agnostic actions for dynamic agents to use.\n\nDriving Domain\n\nThe driving domain, scenic.domains.driving, is designed to support scenarios taking place on or near roads. It defines generic classes for cars and pedestrians, and provides a representation of a road network that can be loaded from standard map formats (e.g. OpenDRIVE). The domain supports dynamic scenarios, providing actions for agents which can drive and walk as well as implementations of common behaviors like lane following and collision avoidance. See the documentation of the scenic.domains.driving module for further details.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Scenic Internals — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/internals.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\nHow Scenic is Compiled\nGuide to the Scenic Parser & Compiler\nScenic Grammar\nScenic Modules\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Scenic Internals\n Edit on GitHub\nScenic Internals\n\nThis section of the documentation describes the implementation of Scenic. Much of this information will probably only be useful for people who need to make some change to the language (e.g. adding a new type of distribution). However, the detailed documentation on Scenic’s abstract application domains (in scenic.domains) and simulator interfaces (in scenic.simulators) may be of interest to people using those features.\n\nHow Scenic is Compiled\nGuide to the Scenic Parser & Compiler\nScenic Grammar\nScenic Modules\n\nDetailed documentation on Scenic’s components is organized by the submodules of the main scenic module:\n\nscenic.core\n\n\t\n\nScenic's core types and associated support code.\n\n\n\n\nscenic.domains\n\n\t\n\nGeneral scenario domains used across simulators.\n\n\n\n\nscenic.formats\n\n\t\n\nSupport for file formats not specific to particular simulators.\n\n\n\n\nscenic.simulators\n\n\t\n\nWorld models and interfaces for particular simulators.\n\n\n\n\nscenic.syntax\n\n\t\n\nThe Scenic compiler and associated support code.\n\nThe scenic module itself provides the top-level API for using Scenic: see Using Scenic Programmatically.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Developing Scenic — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/developing.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nGetting Started\nRunning the Test Suite\nDebugging\nBuilding the Documentation\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Developing Scenic\n Edit on GitHub\nDeveloping Scenic\n\nThis page covers information useful if you will be developing Scenic, either changing the language itself or adding new built-in libraries or simulator interfaces.\n\nTo find documentation (and code) for specific parts of Scenic’s implementation, see our page on Scenic Internals.\n\nGetting Started\n\nStart by cloning our repository on GitHub and setting up your virtual environment. Then to install Scenic and its development dependencies in your virtual environment run:\n\n$ python -m pip install -e \".[dev]\"\n\n\nThis will perform an “editable” install, so that any changes you make to Scenic’s code will take effect immediately when running Scenic in your virtual environment.\n\nScenic uses the isort and black tools to automatically sort import statements and enforce a consistent code style. Run the command pre-commit install to set up hooks which will run every time you commit and correct any formatting problems (you can then inspect the files and try committing again). You can also manually run the formatters on the files changed since the last commit with pre-commit run. 1\n\nRunning the Test Suite\n\nScenic has an extensive test suite exercising most of the features of the language. We use the pytest Python testing tool. To run the entire test suite, run the command pytest inside the virtual environment from the root directory of the repository.\n\nSome of the tests are quite slow, e.g. those which test the parsing and construction of road networks. We add a --fast option to pytest which skips such tests, while still covering all of the core features of the language. So it is convenient to often run pytest --fast as a quick check, remembering to run the full pytest before making any final commits. You can also run specific parts of the test suite with a command like pytest tests/syntax/test_specifiers.py, or use pytest’s -k option to filter by test name, e.g. pytest -k specifiers.\n\nNote that many of Scenic’s tests are probabilistic, so in order to reproduce a test failure you may need to set the random seed. We use the pytest-randomly plugin to help with this: at the beginning of each run of pytest, it prints out a line like:\n\nUsing --randomly-seed=344295085\n\n\nAdding this as an option, i.e. running pytest --randomly-seed=344295085, will reproduce the same sequence of tests with the same Python/Scenic random seed. As a shortcut, you can use --randomly-seed=last to use the seed from the previous testing run.\n\nIf you’re running the test suite on a headless server or just want to stop windows from popping up during testing, use the --no-graphics option to skip graphical tests.\n\nPrior to finalizing a PR or other substantial changes, it’s a good idea to run the test suite under all major versions of Python that Scenic supports, in fresh virtual environments. You can do this automatically with the command tox, which by default will test all supported major versions both with and without optional dependencies (this will take a long time). Some variations:\n\ntox -p will run the various combinations in parallel.\n\ntox -m basic skips testing installations with the optional dependencies.\n\ntox -- --fast only runs the “fast” tests. In general, any arguments after the -- will get passed to pytest. For example,\n\ntox -- tests/syntax/test_specifiers.py only runs the tests in the given file.\n\nSee the Tox website for more information about the available options and how to configure Tox.\n\nDebugging\n\nYou can use Python’s built-in debugger pdb to debug the parsing, compilation, sampling, and simulation of Scenic programs. The Scenic command-line option -b will cause the backtraces printed from uncaught exceptions to include Scenic’s internals; you can also use the --pdb option to automatically enter the debugger on such exceptions. If you’re trying to figure out why a scenario is taking many iterations of rejection sampling, first use the --verbosity option to print out the reason for each rejection. If the problem doesn’t become clear, you can use the --pdb-on-reject option to automatically enter the debugger when a scene or simulation is rejected.\n\nIf you’re using the Python API instead of invoking Scenic from the command line, these debugging features can be enabled using the following function from the scenic module:\n\nsetDebuggingOptions(*, verbosity=0, fullBacktrace=False, debugExceptions=False, debugRejections=False)[source]\n\nConfigure Scenic’s debugging options.\n\nParameters\n:\n\nverbosity (int) – Verbosity level. Zero by default, although the command-line interface uses 1 by default. See the --verbosity option for the allowed values.\n\nfullBacktrace (bool) – Whether to include Scenic’s innards in backtraces (like the -b command-line option).\n\ndebugExceptions (bool) – Whether to use pdb for post-mortem debugging of uncaught exceptions (like the --pdb option).\n\ndebugRejections (bool) – Whether to enter pdb when a scene or simulation is rejected (like the --pdb-on-reject option).\n\nIt is possible to put breakpoints into a Scenic program using the Python built-in function breakpoint. Note however that since code in a Scenic program is not always executed the way you might expect (e.g. top-level code is only run once, whereas code in requirements can run every time we generate a sample: see How Scenic is Compiled), some care is needed when interpreting what you see in the debugger. The same consideration applies when adding print statements to a Scenic program. For example, a top-level print(x) will not print out the actual value of x every time a sample is generated: instead, you will get a single print at compile time, showing the Distribution object which represents the distribution of x (and which is bound to x in the Python namespace used internally for the Scenic module).\n\nBuilding the Documentation\n\nScenic’s documentation is built using Sphinx. The freestanding documentation pages (like this one) are found under the docs folder, written in the reStructuredText format. The detailed documentation of Scenic’s internal classes, functions, etc. is largely auto-generated from their docstrings, which are written in a variant of Google’s style understood by the Napoleon Sphinx extension (see the docstring of Scenario.generate for a simple example: click the [source] link to the right of the function signature to see the code).\n\nIf you modify the documentation, you should build a copy of it locally to make sure everything looks good before you push your changes to GitHub (where they will be picked up automatically by ReadTheDocs). To compile the documentation, enter the docs folder and run make html. The output will be placed in the docs/_build/html folder, so the root page will be at docs/_build/html/index.html. If your changes do not appear, it’s possible that Sphinx has not detected them; you can run make clean to delete all the files from the last compilation and start from a clean slate.\n\nScenic extends Sphinx in a number of ways to improve the presentation of Scenic code and add various useful features: see docs/conf.py for full details. Some of the most commonly-used features are:\n\na scenic role which extends the standard Sphinx samp role with Scenic syntax highlighting;\n\na sampref role which makes a cross-reference like keyword but allows emphasizing variables like samp;\n\nthe term role for glossary terms is extended so that the cross-reference will work even if the link is plural but the glossary entry is singular or vice versa.\n\nFootnotes\n\n[1]\n\nTo run the formatters on all files, changed or otherwise, use make format in the root directory of the repository. But this should not be necessary if you installed the pre-commit hooks and so all files already committed are clean.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Using Scenic Programmatically — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/api.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nCompiling Scenarios and Generating Scenes\nRunning Dynamic Simulations\nStoring Scenes/Simulations for Later Use\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Using Scenic Programmatically\n Edit on GitHub\nUsing Scenic Programmatically\n\nWhile Scenic is most easily invoked as a command-line tool, it also provides a Python API for compiling Scenic programs, sampling scenes from them, and running dynamic simulations.\n\nCompiling Scenarios and Generating Scenes\n\nThe top-level interface to Scenic is provided by two functions in the scenic module which compile a Scenic program:\n\nscenarioFromFile(path, params={}, model=None, scenario=None, *, mode2D=False, **kwargs)[source]\n\nCompile a Scenic file into a Scenario.\n\nParameters\n:\n\npath (str) – Path to a Scenic file.\n\nparams (dict) – Global parameters to override, as a dictionary mapping parameter names to their desired values.\n\nmodel (str) – Scenic module to use as world model.\n\nscenario (str) – If there are multiple modular scenarios in the file, which one to compile; if not specified, a scenario called ‘Main’ is used if it exists.\n\nmode2D (bool) – Whether to compile this scenario in 2D Compatibility Mode.\n\nReturns\n:\n\nA Scenario object representing the Scenic scenario.\n\nNote for Scenic developers: this function accepts additional keyword arguments which are intended for internal use and debugging only. See _scenarioFromStream for details.\n\nscenarioFromString(string, params={}, model=None, scenario=None, *, filename='<string>', mode2D=False, **kwargs)[source]\n\nCompile a string of Scenic code into a Scenario.\n\nThe optional filename is used for error messages. Other arguments are as in scenarioFromFile.\n\nThe resulting Scenario object represents the abstract scenario defined by the Scenic program. To sample concrete scenes from this object, you can call the Scenario.generate method, which returns a Scene. If you are only using static scenarios, you can extract the sampled values for all the global parameters and objects in the scene from the Scene object. For example:\n\nimport random, scenic\nrandom.seed(12345)\nscenario = scenic.scenarioFromString('ego = new Object with foo Range(0, 5)')\nscene, numIterations = scenario.generate()\nprint(f'ego has foo = {scene.egoObject.foo}')\n\nego has foo = 2.083099362726706\n\nRunning Dynamic Simulations\n\nTo run dynamic scenarios, you must instantiate an instance of the Simulator class for the particular simulator you want to use. Each simulator interface that supports dynamic simulations defines a subclass of Simulator; for example, NewtonianSimulator for the simple Newtonian simulator built into Scenic. These subclasses provide simulator-specific functionality, and have different requirements for their use: see the specific documentation of each interface under scenic.simulators for details.\n\nOnce you have an instance of Simulator, you can ask it to run a simulation from a Scene by calling the Simulator.simulate method. If Scenic is able to run a simulation that satisfies all the requirements in the Scenic program (potentially after multiple attempts – Scenic uses rejection sampling), this method will return a Simulation object. Results of the simulation can then be obtained by inspecting its result attribute, which is an instance of SimulationResult (simulator-specific subclasses of Simulation may also provide additional information). For example:\n\nimport scenic\nfrom scenic.simulators.newtonian import NewtonianSimulator\nscenario = scenic.scenarioFromFile('examples/driving/badlyParkedCarPullingIn.scenic',\n                                   model='scenic.simulators.newtonian.driving_model',\n                                   mode2D=True)\nscene, _ = scenario.generate()\nsimulator = NewtonianSimulator()\nsimulation = simulator.simulate(scene, maxSteps=10)\nif simulation:  # `simulate` can return None if simulation fails\n        result = simulation.result\n        for i, state in enumerate(result.trajectory):\n                egoPos, parkedCarPos = state\n                print(f'Time step {i}: ego at {egoPos}; parked car at {parkedCarPos}')\n\n\nIf you want to monitor data from simulations to see if the system you are testing violates its specfications, you may want to use VerifAI instead of implementing your own code along the lines above. VerifAI supports running tests from Scenic programs, specifying system specifications using temporal logic or arbitrary Python monitor functions, actively searching the space of parameters in a Scenic program to find concrete scenarios where the system violates its specs 1, and more. See the VerifAI documentation for details.\n\nStoring Scenes/Simulations for Later Use\n\nScene and Simulation objects are heavyweight and not themselves suitable for bulk storage or transmission over a network 2. However, Scenic provides serialization routines which can encode such objects into relatively short sequences of bytes. Compact encodings are achieved by storing only the sampled values of the primitive random variables in the scenario: all non-random information is obtained from the original Scenic file.\n\nHaving compiled a Scenic scenario into a Scenario object, any scenes you generate from the scenario can be encoded as bytes using the Scenario.sceneToBytes method. For example, to save a scene to a file one could use code like the following:\n\nimport scenic, tempfile, pathlib\nscenario = scenic.scenarioFromFile('examples/gta/parkedCar.scenic', mode2D=True)\nscene, _ = scenario.generate()\ndata = scenario.sceneToBytes(scene)\nwith open(pathlib.Path(tempfile.gettempdir()) / 'test.scene', 'wb') as f:\n        f.write(data)\nprint(f'ego car position = {scene.egoObject.position}')\n\n\nThen you could restore the scene in another process, obtaining the same position for the ego car:\n\nimport scenic, tempfile, pathlib\nscenario = scenic.scenarioFromFile('examples/gta/parkedCar.scenic', mode2D=True)\nwith open(pathlib.Path(tempfile.gettempdir()) / 'test.scene', 'rb') as f:\n        data = f.read()\nscene = scenario.sceneFromBytes(data)\nprint(f'ego car position = {scene.egoObject.position}')\n\n\nNotice how we need to compile the scenario a second time in order to decode the scene, if the original Scenario object is not available. If you need to send a large number of scenes from one computer to another, for example, it suffices to send the Scenic file for the underlying scenario, plus the encodings of each of the scenes.\n\nYou can encode and decode simulations run from a Scenario in a similar way, using the Scenario.simulationToBytes and Scenario.simulationFromBytes methods. One additional concern when replaying a serialized simulation is that if your simulator is not deterministic (or you change the simulator configuration), the original simulation and its replay can diverge, leading to unexpected behavior or exceptions. Scenic can attempt to detect such divergences by saving the exact history of the simulation and comparing it to the replay, but this greatly increases the size of the encoded simulation. See Simulator.simulate for the available options.\n\nNote\n\nThe serialization format used for scenes and simulations is suitable for long-term storage (for instance if you want to save all the simulations you’ve run so that you can return to one later for further analysis), but it is not guaranteed to be compatible across major versions of Scenic.\n\nSee also\n\nIf you get exceptions or unexpected behavior when using the API, Scenic provides various debugging features: see Debugging.\n\nFootnotes\n\n[1]\n\nVerifAI’s active samplers can be used directly from Scenic when VerifAI is installed. See scenic.core.external_params.\n\n[2]\n\nIf you really do need to store/transmit such objects, you may be able to do so using dill, a drop-in replacement for Python’s standard pickle library. Be aware that pickling will produce much larger encodings than Scenic’s own APIs, as they need to include all the information present in the original Scenic file and its associated resources (e.g. for driving scenarios, the entire road map). Unpickling malicious files can also trigger arbitrary code execution, while Scenic’s deserialization APIs can be used with untrusted data (as long as you trust the Scenic program you’re running, of course).\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Command-Line Options — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/options.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nGeneral Scenario Control\nDynamic Simulations\nDebugging\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Command-Line Options\n Edit on GitHub\nCommand-Line Options\n\nThe scenic command supports a variety of options. Run scenic -h for a full list with short descriptions; we elaborate on some of the most important options below.\n\nOptions may be given before and after the path to the Scenic file to run, so the syntax of the command is:\n\n$ scenic [options] FILE [options]\n\nGeneral Scenario Control\n-m <model>, --model <model>\n\nSpecify the world model to use for the scenario, overriding any model statement in the scenario. The argument must be the fully qualified name of a Scenic module found on your PYTHONPATH (it does not necessarily need to be built into Scenic). This allows scenarios written using a generic model, like that provided by the Driving Domain, to be executed in a particular simulator (see the dynamic scenarios tutorial for examples).\n\nThe equivalent of this option for the Python API is the model argument to scenic.scenarioFromFile.\n\n-p <param> <value>, --param <param> <value>\n\nSpecify the value of a global parameter. This assignment overrides any param statements in the scenario. If the given value can be interpreted as an int or float, it is; otherwise it is kept as a string.\n\nThe equivalent of this option for the Python API is the params argument to scenic.scenarioFromFile (which, however, does not attempt to convert strings to numbers).\n\n--count <number>\n\nNumber of successful scenes to generate or simulations to run (i.e., not counting rejected scenes/simulations). The default is to run forever.\n\n-s <seed>, --seed <seed>\n\nSpecify the random seed used by Scenic, to make sampling deterministic.\n\nThis option sets the seed for the Python random number generator random and the numpy random number generator numpy.random, so external Python code called from within Scenic can also be made deterministic (although random and numpy.random should not be used in place of Scenic’s own sampling constructs in Scenic code).\n\n--scenario <scenario>\n\nIf the given Scenic file defines multiple scenarios, select which one to run. The named modular scenario must not require any arguments.\n\nThe equivalent of this option for the Python API is the scenario argument to scenic.scenarioFromFile.\n\n--2d\n\nCompile the scenario in 2D Compatibility Mode.\n\nThe equivalent of this option for the Python API is the mode2D argument to scenic.scenarioFromFile.\n\nDynamic Simulations\n-S, --simulate\n\nRun dynamic simulations from scenes instead of plotting scene diagrams. This option will only work for scenarios which specify a simulator, which is done automatically by the world models for the simulator interfaces that support dynamic scenarios, e.g. scenic.simulators.carla.model and scenic.simulators.lgsvl.model. If your scenario is written for an abstract domain, like scenic.domains.driving, you will need to use the --model option to specify the specific model for the simulator you want to use.\n\n--time <steps>\n\nMaximum number of time steps to run each simulation (the default is infinity). Simulations may end earlier if termination criteria defined in the scenario are met (see terminate when and terminate).\n\nDebugging\n--version\n\nShow which version of Scenic is being used.\n\n-v <verbosity>, --verbosity <verbosity>\n\nSet the verbosity level, from 0 to 3 (default 1):\n\n0\n\nNothing is printed except error messages and warnings (to stderr). Warnings can be suppressed using the PYTHONWARNINGS environment variable.\n\n1\n\nThe main steps of compilation and scene generation are indicated, with timing statistics.\n\n2\n\nAdditionally, details on which modules are being compiled and the reasons for any scene/simulation rejections are printed.\n\n3\n\nAdditionally, the actions taken by each agent at each time step of a dynamic simulation are printed.\n\nThis option can be configured from the Python API using scenic.setDebuggingOptions.\n\n--show-params\n\nShow values of global parameters for each generated scene.\n\n--show-records\n\nShow recorded values (see record) for each dynamic simulation.\n\n-b, --full-backtrace\n\nInclude Scenic’s internals in backtraces printed for uncaught exceptions. This information will probably only be useful if you are developing Scenic.\n\nThis option can be enabled from the Python API using scenic.setDebuggingOptions.\n\n--pdb\n\nIf an error occurs, enter the Python interactive debugger pdb. Implies the -b option.\n\nThis option can be enabled from the Python API using scenic.setDebuggingOptions.\n\n--pdb-on-reject\n\nIf a scene/simulation is rejected (so that another must be sampled), enter pdb. Implies the -b option.\n\nThis option can be enabled from the Python API using scenic.setDebuggingOptions.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Language Reference — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/language_reference.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nGeneral Notes on Syntax\nData Types Reference\nRegion Types Reference\nDistributions Reference\nStatements Reference\nObjects and Classes Reference\nSpecifiers Reference\nOperators Reference\nBuilt-in Functions Reference\nVisibility System\nScene Generation\nExecution of Dynamic Scenarios\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Language Reference\n Edit on GitHub\nLanguage Reference\n\nLanguage Constructs\n\nThese pages describe the syntax of Scenic in detail. For a one-page summary of Scenic’s syntax, see the Syntax Guide. For details on the syntax for functions, loops, etc. inherited from Python, see the Python Language Reference.\n\nGeneral Notes on Syntax\nData Types Reference\nRegion Types Reference\nDistributions Reference\nStatements Reference\nObjects and Classes Reference\nSpecifiers Reference\nOperators Reference\nBuilt-in Functions Reference\nVisibility System\n\nSemantics and Scenario Generation\n\nThe pages above describe the semantics of each of Scenic’s constructs individually; the following pages cover the semantics of entire Scenic programs, and how scenes and simulations are generated from them.\n\nScene Generation\nExecution of Dynamic Scenarios\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Syntax Guide — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/syntax_guide.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nPrimitive Data Types\nDistributions\nStatements\nObjects\nSpecifiers\nOperators\nBuilt-in Functions\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Syntax Guide\n Edit on GitHub\nSyntax Guide\n\nThis page summarizes the syntax of Scenic, excluding the basic syntax of variable assignments, functions, loops, etc., which is identical to Python (see the Python Tutorial for an introduction). For more details, click the links for individual language constructs to go to the corresponding section of the Language Reference.\n\nPrimitive Data Types\n\nBooleans\n\n\t\n\nexpressing truth values\n\n\n\n\nScalars\n\n\t\n\nrepresenting distances, angles, etc. as floating-point numbers\n\n\n\n\nVectors\n\n\t\n\nrepresenting positions and offsets in space\n\n\n\n\nHeadings\n\n\t\n\nrepresenting 2D orientations in the XY plane\n\n\n\n\nOrientations\n\n\t\n\nrepresenting 3D orientations in space\n\n\n\n\nVector Fields\n\n\t\n\nassociating an orientation to each point in space\n\n\n\n\nRegions\n\n\t\n\nrepresenting sets of points in space\n\n\n\n\nShapes\n\n\t\n\nrepresenting shapes (regions modulo similarity)\n\nDistributions\n\nRange(low, high)\n\n\t\n\nuniformly-distributed real number in the interval\n\n\n\n\nDiscreteRange(low, high)\n\n\t\n\nuniformly-distributed integer in the (fixed) interval\n\n\n\n\nNormal(mean, stdDev)\n\n\t\n\nnormal distribution with the given mean and standard deviation\n\n\n\n\nTruncatedNormal(mean, stdDev, low, high)\n\n\t\n\nnormal distribution truncated to the given window\n\n\n\n\nUniform(value, ...)\n\n\t\n\nuniform over a finite set of values\n\n\n\n\nDiscrete({value: weight, ...})\n\n\t\n\ndiscrete with given values and weights\n\n\n\n\nnew Point in region\n\n\t\n\nuniformly-distributed Point in a region\n\nStatements\nCompound Statements\n\nSyntax\n\n\t\n\nMeaning\n\n\n\n\nclass name[(superclass)]:\n\n\t\n\nDefines a Scenic class.\n\n\n\n\nbehavior name(arguments):\n\n\t\n\nDefines a dynamic behavior.\n\n\n\n\nmonitor name(arguments):\n\n\t\n\nDefines a monitor.\n\n\n\n\nscenario name(arguments):\n\n\t\n\nDefines a modular scenario.\n\n\n\n\ntry: ... interrupt when boolean:\n\n\t\n\nRun code with interrupts inside a dynamic behavior or modular scenario.\n\nSimple Statements\n\nSyntax\n\n\t\n\nMeaning\n\n\n\n\nmodel name\n\n\t\n\nSelect the world model.\n\n\n\n\nimport module\n\n\t\n\nImport a Scenic or Python module.\n\n\n\n\nparam name = value, ...\n\n\t\n\nDefine global parameters of the scenario.\n\n\n\n\nrequire boolean\n\n\t\n\nDefine a hard requirement.\n\n\n\n\nrequire[number] boolean\n\n\t\n\nDefine a soft requirement.\n\n\n\n\nrequire LTL formula\n\n\t\n\nDefine a dynamic hard requirement.\n\n\n\n\nrequire monitor monitor\n\n\t\n\nDefine a dynamic requirement using a monitor.\n\n\n\n\nterminate when boolean\n\n\t\n\nDefine a termination condition.\n\n\n\n\nterminate after scalar (seconds | steps)\n\n\t\n\nSet the scenario to terminate after a given amount of time.\n\n\n\n\nmutate identifier, ... [by number]\n\n\t\n\nEnable mutation of the given list of objects.\n\n\n\n\nrecord [initial | final] value as name\n\n\t\n\nSave a value at every time step or only at the start/end of the simulation.\n\nDynamic Statements\n\nThese statements can only be used inside a dynamic behavior, monitor, or compose block of a modular scenario.\n\nSyntax\n\n\t\n\nMeaning\n\n\n\n\ntake action, ...\n\n\t\n\nTake the action(s) specified.\n\n\n\n\nwait\n\n\t\n\nTake no actions this time step.\n\n\n\n\nterminate\n\n\t\n\nImmediately end the scenario.\n\n\n\n\nterminate simulation\n\n\t\n\nImmediately end the entire simulation.\n\n\n\n\ndo behavior/scenario, ...\n\n\t\n\nRun one or more sub-behaviors/sub-scenarios until they complete.\n\n\n\n\ndo behavior/scenario, ... until boolean\n\n\t\n\nRun sub-behaviors/scenarios until they complete or a condition is met.\n\n\n\n\ndo behavior/scenario, ... for scalar (seconds | steps)\n\n\t\n\nRun sub-behaviors/scenarios for (at most) a specified period of time.\n\n\n\n\ndo choose behavior/scenario, ...\n\n\t\n\nRun one choice of sub-behavior/scenario whose preconditions are satisfied.\n\n\n\n\ndo shuffle behavior/scenario, ...\n\n\t\n\nRun several sub-behaviors/scenarios in a random order, satisfying preconditions.\n\n\n\n\nabort\n\n\t\n\nBreak out of the current try-interrupt statement.\n\n\n\n\noverride object specifier, ...\n\n\t\n\nOverride properties of an object for the duration of the current scenario.\n\nObjects\n\nThe syntax new class specifier, ... creates an instance of a Scenic class.\n\nThe Scenic class Point provides the basic position properties in the first table below; its subclass OrientedPoint adds the orientation properties in the second table. Finally, the class Object, which represents physical objects and is the default superclass of user-defined Scenic classes, adds the properties in the third table. See the Objects and Classes Reference for details.\n\nProperty\n\n\t\n\nDefault\n\n\t\n\nMeaning\n\n\n\n\nposition 1\n\n\t\n\n(0, 0, 0)\n\n\t\n\nposition in global coordinates\n\n\n\n\nvisibleDistance\n\n\t\n\n50\n\n\t\n\ndistance for the ‘can see’ operator\n\n\n\n\nviewRayDensity\n\n\t\n\n5\n\n\t\n\ndetermines ray count (if ray count is not provided)\n\n\n\n\nviewRayDistanceScaling\n\n\t\n\nFalse\n\n\t\n\nwhether to scale number of rays with distance (if ray count is not provided)\n\n\n\n\nviewRayCount\n\n\t\n\nNone\n\n\t\n\ntuple of number of rays to send in each dimension.\n\n\n\n\nmutationScale\n\n\t\n\n0\n\n\t\n\noverall scale of mutations\n\n\n\n\npositionStdDev\n\n\t\n\n(1,1,0)\n\n\t\n\nmutation standard deviation for position\n\nProperties added by OrientedPoint:\n\nProperty\n\n\t\n\nDefault\n\n\t\n\nMeaning\n\n\n\n\nyaw 1\n\n\t\n\n0\n\n\t\n\nyaw in local coordinates\n\n\n\n\npitch 1\n\n\t\n\n0\n\n\t\n\npitch in local coordinates\n\n\n\n\nroll 1\n\n\t\n\n0\n\n\t\n\nroll in local coordinates\n\n\n\n\nparentOrientation\n\n\t\n\nglobal\n\n\t\n\nbasis for local coordinate system\n\n\n\n\nviewAngles\n\n\t\n\n(2π, π)\n\n\t\n\nangles for visibility calculations\n\n\n\n\norientationStdDev\n\n\t\n\n(5°, 0, 0)\n\n\t\n\nmutation standard deviation for orientation\n\nProperties added by Object:\n\nProperty\n\n\t\n\nDefault\n\n\t\n\nMeaning\n\n\n\n\nwidth\n\n\t\n\n1\n\n\t\n\nwidth of bounding box (X axis)\n\n\n\n\nlength\n\n\t\n\n1\n\n\t\n\nlength of bounding box (Y axis)\n\n\n\n\nheight\n\n\t\n\n1\n\n\t\n\nheight of bounding box (Z axis)\n\n\n\n\nshape\n\n\t\n\nBoxShape\n\n\t\n\nshape of the object\n\n\n\n\nallowCollisions\n\n\t\n\nFalse\n\n\t\n\nwhether collisions are allowed\n\n\n\n\nregionContainedIn\n\n\t\n\nworkspace\n\n\t\n\nRegion the object must lie within\n\n\n\n\nbaseOffset\n\n\t\n\n(0, 0, -self.height/2)\n\n\t\n\noffset determining the base of the object\n\n\n\n\ncontactTolerance\n\n\t\n\n1e-4\n\n\t\n\nmax distance to be considered on a surface\n\n\n\n\nsideComponentThresholds\n\n\t\n\n(-0.5, 0.5) per side\n\n\t\n\nthresholds to determine side surfaces\n\n\n\n\ncameraOffset\n\n\t\n\n(0, 0, 0)\n\n\t\n\nposition of camera for can see\n\n\n\n\nrequireVisible\n\n\t\n\nFalse\n\n\t\n\nwhether object must be visible from ego\n\n\n\n\noccluding\n\n\t\n\nTrue\n\n\t\n\nwhether object occludes visibility\n\n\n\n\nshowVisibleRegion\n\n\t\n\nFalse\n\n\t\n\nwhether to display the visible region\n\n\n\n\ncolor\n\n\t\n\nNone\n\n\t\n\ncolor of object\n\n\n\n\nvelocity 1\n\n\t\n\nfrom speed\n\n\t\n\ninitial (instantaneous) velocity\n\n\n\n\nspeed 1\n\n\t\n\n0\n\n\t\n\ninitial (later, instantaneous) speed\n\n\n\n\nangularVelocity 1\n\n\t\n\n(0, 0, 0)\n\n\t\n\ninitial (instantaneous) angular velocity\n\n\n\n\nangularSpeed 1\n\n\t\n\n0\n\n\t\n\nangular speed (change in heading/time)\n\n\n\n\nbehavior\n\n\t\n\nNone\n\n\t\n\ndynamic behavior, if any\n\n\n\n\nlastActions\n\n\t\n\nNone\n\n\t\n\ntuple of actions taken in last timestamp\n\n[1]\n(1,2,3,4,5,6,7,8)\n\nThese are dynamic properties, updated automatically every time step during dynamic simulations.\n\nSpecifiers\n\nThe with property value specifier can specify any property, including new properties not built into Scenic. Additional specifiers for the position and orientation properties are listed below.\n\nIllustration of the beyond, behind, and offset by specifiers. Each OrientedPoint (e.g. P) is shown as a bold arrow.\n\nSpecifier for position\n\n\t\n\nMeaning\n\n\n\n\nat vector\n\n\t\n\nPositions the object at the given global coordinates\n\n\n\n\nin region\n\n\t\n\nPositions the object uniformly at random in the given Region\n\n\n\n\ncontained in region\n\n\t\n\nPositions the object uniformly at random entirely contained in the given Region\n\n\n\n\non vector\n\n\t\n\nPositions the base of the object at the given global coordinates\n\n\n\n\non (region | Object)\n\n\t\n\nPositions the object uniformly at random or modifies the position so that base of the Object is in the given Region/on the given Object.\n\n\n\n\noffset by vector\n\n\t\n\nPositions the object at the given coordinates in the local coordinate system of ego (which must already be defined)\n\n\n\n\noffset along direction by vector\n\n\t\n\nPositions the object at the given coordinates, in a local coordinate system centered at ego and oriented along the given direction\n\n\n\n\nbeyond vector by (vector | scalar) [from (vector | OrientedPoint)]\n\n\t\n\nPositions the object with respect to the line of sight from a point or the ego\n\n\n\n\nvisible [from (Point | OrientedPoint)]\n\n\t\n\nEnsures the object is visible from the ego, or from the given Point/OrientedPoint if given, while optionally specifying position to be uniformly random over all positions that result in a visible object.\n\n\n\n\nnot visible [from (Point | OrientedPoint)]\n\n\t\n\nEnsures the object is not visible from the ego, or from the given Point/OrientedPoint if given, while optionally specifying position to be uniformly random over all positions that result in a non-visible object.\n\n\n\n\n(left | right) of (vector | OrientedPoint | Object) [by scalar]\n\n\t\n\nPositions the object to the left/right by the given scalar distance.\n\n\n\n\n(ahead of | behind) (vector | OrientedPoint | Object) [by scalar]\n\n\t\n\nPositions the object to the front/back by the given scalar distance\n\n\n\n\n(above | below) (vector | OrientedPoint | Object) [by scalar]\n\n\t\n\nPositions the object above/below by the given scalar distance\n\n\n\n\nfollowing vectorField [from vector] for scalar\n\n\t\n\nPosition by following the given vector field for the given distance starting from ego or the given vector\n\nSpecifier for orientation\n\n\t\n\nMeaning\n\n\n\n\nfacing orientation\n\n\t\n\nOrients the object along the given orientation in global coordinates\n\n\n\n\nfacing vectorField\n\n\t\n\nOrients the object along the given vector field at the object’s position\n\n\n\n\nfacing (toward | away from) vector\n\n\t\n\nOrients the object toward/away from the given position (thereby depending on the object’s position)\n\n\n\n\nfacing directly (toward | away from) vector\n\n\t\n\nOrients the object directly toward/away from the given position (thereby depending on the object’s position)\n\n\n\n\napparently facing heading [from vector]\n\n\t\n\nOrients the object so that it has the given heading with respect to the line of sight from ego (or the given vector)\n\nOperators\n\nIn the following tables, operators are grouped by the type of value they return.\n\nIllustration of several operators. Each OrientedPoint (e.g. P) is shown as a bold arrow.\n\nScalar Operators\n\n\t\n\nMeaning\n\n\n\n\nrelative heading of heading [from heading]\n\n\t\n\nThe relative heading of the given heading with respect to ego (or the from heading)\n\n\n\n\napparent heading of OrientedPoint [from vector]\n\n\t\n\nThe apparent heading of the OrientedPoint, with respect to the line of sight from ego (or the given vector)\n\n\n\n\ndistance [from vector] to vector\n\n\t\n\nThe distance to the given position from ego (or the from vector)\n\n\n\n\nangle [from vector] to vector\n\n\t\n\nThe heading (azimuth) to the given position from ego (or the from vector)\n\n\n\n\naltitude [from vector] to vector\n\n\t\n\nThe altitude to the given position from ego (or the from vector)\n\nBoolean Operators\n\n\t\n\nMeaning\n\n\n\n\n(Point | OrientedPoint) can see (vector | Object)\n\n\t\n\nWhether or not a position or Object is visible from a Point or OrientedPoint\n\n\n\n\n(vector | Object) in region\n\n\t\n\nWhether a position or Object lies in the region\n\n\n\n\n(Object | region) intersects (Object | region)\n\n\t\n\nWhether an Object/Region intersects an Object/Region.\n\nOrientation Operators\n\n\t\n\nMeaning\n\n\n\n\nscalar deg\n\n\t\n\nThe given angle, interpreted as being in degrees\n\n\n\n\nvectorField at vector\n\n\t\n\nThe orientation specified by the vector field at the given position\n\n\n\n\ndirection relative to direction\n\n\t\n\nThe first direction (a heading, orientation, or vector field), interpreted as an offset relative to the second direction\n\nVector Operators\n\n\t\n\nMeaning\n\n\n\n\nvector (relative to | offset by) vector\n\n\t\n\nThe first vector, interpreted as an offset relative to the second vector (or vice versa)\n\n\n\n\nvector offset along direction by vector\n\n\t\n\nThe second vector, interpreted in a local coordinate system centered at the first vector and oriented along the given direction\n\nRegion Operators\n\n\t\n\nMeaning\n\n\n\n\nvisible region\n\n\t\n\nThe part of the given region visible from ego\n\n\n\n\nnot visible region\n\n\t\n\nThe part of the given region not visible from ego\n\n\n\n\nregion visible from (Point | OrientedPoint)\n\n\t\n\nThe part of the given region visible from the given Point or OrientedPoint.\n\n\n\n\nregion not visible from (Point | OrientedPoint)\n\n\t\n\nThe part of the given region not visible from the given Point or OrientedPoint.\n\nOrientedPoint Operators\n\n\t\n\nMeaning\n\n\n\n\nvector relative to OrientedPoint\n\n\t\n\nThe given vector, interpreted in the local coordinate system of the OrientedPoint\n\n\n\n\nOrientedPoint offset by vector\n\n\t\n\nEquivalent to vector relative to OrientedPoint above\n\n\n\n\n(front | back | left | right) of Object\n\n\t\n\nThe midpoint of the corresponding side of the bounding box of the Object, inheriting the Object’s orientation.\n\n\n\n\n(front | back) (left | right) of Object\n\n\t\n\nThe midpoint of the corresponding edge of the bounding box of the Object, inheriting the Object’s orientation.\n\n\n\n\n(front | back) (left | right) of Object\n\n\t\n\nThe midpoint of the corresponding edge of the bounding box of the Object, inheriting the Object’s orientation.\n\n\n\n\n(top | bottom) (front | back) (left | right) of Object\n\n\t\n\nThe corresponding corner of the bounding box of the Object, inheriting the Object’s orientation.\n\nTemporal Operators\n\n\t\n\nMeaning\n\n\n\n\nalways condition\n\n\t\n\nRequire the condition to hold at every time step.\n\n\n\n\neventually condition\n\n\t\n\nRequire the condition to hold at some time step.\n\n\n\n\nnext condition\n\n\t\n\nRequire the condition to hold in the next time step.\n\n\n\n\ncondition until condition\n\n\t\n\nRequire the first condition to hold until the second becomes true.\n\n\n\n\ncondition implies condition\n\n\t\n\nRequire the second condition to hold if the first condition holds.\n\nBuilt-in Functions\n\nFunction\n\n\t\n\nDescription\n\n\n\n\nMisc Python functions\n\n\t\n\nVarious Python functions including min, max, open, etc.\n\n\n\n\nfilter\n\n\t\n\nFilter a possibly-random list (allowing limited randomized control flow).\n\n\n\n\nresample\n\n\t\n\nSample a new value from a distribution.\n\n\n\n\nlocalPath\n\n\t\n\nConvert a relative path to an absolute path, based on the current directory.\n\n\n\n\nverbosePrint\n\n\t\n\nLike print, but silent at low-enough verbosity levels.\n\n\n\n\nsimulation\n\n\t\n\nGet the the current simulation object.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Composing Scenarios — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/tutorials/composition.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\nModular Scenarios\nParallel and Sequential Composition\nInterrupts, Overriding, and Initial Scenarios\nRandom Selection of Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Composing Scenarios\n Edit on GitHub\nComposing Scenarios\n\nScenic provides facilities for defining multiple scenarios in a single program and composing them in various ways. This enables writing a library of scenarios which can be repeatedly used as building blocks to construct more complex scenarios.\n\nModular Scenarios\n\nThe scenario statement defines a named, reusable scenario, optionally with tunable parameters: what we call a modular scenario. For example, here is a scenario which creates a parked car on the shoulder of the ego’s current lane (assuming there is one), using some APIs from the Driving Domain:\n\nscenario ParkedCar(gap=0.25):\n    precondition: ego.laneGroup._shoulder != None\n    setup:\n        spot = new OrientedPoint on visible ego.laneGroup.curb\n        parkedCar = new Car left of spot by gap\n\n\nThe setup block contains Scenic code which executes when the scenario is instantiated, and which can define classes, create objects, declare requirements, etc. as in any ordinary Scenic scenario. Additionally, we can define preconditions and invariants, which operate in the same way as for dynamic behaviors.\n\nHaving now defined the ParkedCar scenario, we can use it in a more complex scenario, potentially multiple times:\n\nscenario Main():\n    setup:\n        ego = new Car\n    compose:\n        do ParkedCar(), ParkedCar(0.5)\n\n\nHere our Main scenario itself only creates the ego car; then its compose block orchestrates how to run other modular scenarios. In this case, we invoke two copies of the ParkedCar scenario in parallel, specifying in one case that the gap between the parked car and the curb should be 0.5 m instead of the default 0.25. So the scenario will involve three cars in total, and as usual Scenic will automatically ensure that they are all on the road and do not intersect.\n\nParallel and Sequential Composition\n\nThe scenario above is an example of parallel composition, where we use the do statement to run two scenarios at the same time. We can also use sequential composition, where one scenario begins after another ends. This is done the same way as in behaviors: in fact, the compose block of a scenario is executed in the same way as a monitor, and allows all the same control-flow constructs. For example, we could write a compose block as follows:\n\n1while True:\n2    do ParkedCar(gap=0.25) for 30 seconds\n3    do ParkedCar(gap=0.5) for 30 seconds\n\n\nHere, a new parked car is created every 30 seconds, 1 with the distance to the curb alternating between 0.25 and 0.5 m. Note that without the for 30 seconds qualifier, we would never get past line 2, since the ParkedCar scenario does not define any termination conditions using terminate when (or terminate in a compose block) and so runs forever by default. If instead we want to create a new car only when the ego has passed the current one, we can use a do-until statement:\n\nwhile True:\n    subScenario = ParkedCar(gap=0.25)\n    do subScenario until (distance past subScenario.parkedCar) > 10\n\n\nNote how we can refer to the parkedCar variable created in the ParkedCar scenario as a property of the scenario. Combined with the ability to pass objects as parameters of scenarios, this is convenient for reusing objects across scenarios.\n\nInterrupts, Overriding, and Initial Scenarios\n\nThe try-interrupt statement used in behaviors can also be used in compose blocks to switch between scenarios. For example, suppose we already have a scenario where the ego is following a leadCar, and want to elaborate it by adding a parked car which suddenly pulls in front of the lead car. We could write a compose block as follows:\n\n1following = FollowingScenario()\n2try:\n3    do following\n4interrupt when (distance to following.leadCar) < 10:\n5    do ParkedCarPullingAheadOf(following.leadCar)\n\n\nIf the ParkedCarPullingAheadOf scenario is defined to end shortly after the parked car finishes entering the lane, the interrupt handler will complete and Scenic will resume executing FollowingScenario on line 3 (unless the ego is still within 10 m of the lead car).\n\nSuppose that we want the lead car to behave differently while the parked car scenario is running; for example, perhaps the behavior for the lead car defined in FollowingScenario does not handle a parked car suddenly pulling in. To enable changing the behavior or other properties of an object in a sub-scenario, Scenic provides the override statement, which we can use as follows:\n\nscenario ParkedCarPullingAheadOf(target):\n    setup:\n        override target with behavior FollowLaneAvoidingCollisions\n        parkedCar = new Car left of ...\n\n\nHere we override the behavior property of target for the duration of the scenario, reverting it back to its original value (and thereby continuing to execute the old behavior) when the scenario terminates. The override object specifier, ... statement takes a comma-separated list of specifiers like an instance creation, and can specify any properties of the object except for dynamic properties like position or speed which can only be indirectly controlled by taking actions.\n\nIn order to allow writing scenarios which can both stand on their own and be invoked during another scenario, Scenic provides a special conditional statement testing whether we are inside the initial scenario, i.e., the very first scenario to run. For instance:\n\nscenario TwoLanePedestrianScenario():\n    setup:\n        if initial scenario:  # create ego on random 2-lane road\n            roads = filter(lambda r: len(r.lanes) == 2, network.roads)\n            road = Uniform(*roads)  # pick uniformly from list\n            ego = new Car on road\n        else:  # use existing ego car; require it is on a 2-lane road\n            require len(ego.road.lanes) == 2\n            road = ego.road\n        new Pedestrian on visible road.sidewalkRegion, with behavior ...\n\nRandom Selection of Scenarios\n\nFor very general scenarios, like “driving through a city, encountering typical human traffic”, we may want a variety of different events and interactions to be possible. We saw in the Dynamic Scenarios tutorial how we can write behaviors for individual agents which choose randomly between possible actions; Scenic allows us to do the same with entire scenarios. Most simply, since scenarios are first-class objects, we can write functions which operate on them, perhaps choosing a scenario from a list of options based on some complex criterion:\n\nchosenScenario = pickNextScenario(ego.position, ...)\ndo chosenScenario\n\n\nHowever, some scenarios may only make sense in certain contexts; for example, a red light runner scenario can take place only at an intersection. To facilitate modeling such situations, Scenic provides variants of the do statement which randomly choose scenarios to run amongst only those whose preconditions are satisfied:\n\n1do choose RedLightRunner, Jaywalker, ParkedCar(gap=0.5)\n2do choose {RedLightRunner: 2, Jaywalker: 1, ParkedCar(gap=0.5): 1}\n3do shuffle RedLightRunner, Jaywalker, ParkedCar\n\n\nHere, line 1 checks the preconditions of the three given scenarios, then executes one (and only one) of the enabled scenarios. If for example the current road has no shoulder, then ParkedCar will be disabled and we will have a 50/50 chance of executing either RedLightRunner or Jaywalker (assuming their preconditions are satisfied). If none of the three scenarios are enabled, Scenic will reject the simulation. Line 2 shows a non-uniform variant, where RedLightRunner is twice as likely to be chosen as each of the other scenarios (so if only ParkedCar is disabled, we will pick RedLightRunner with probability 2/3; if none are disabled, 2/4). Finally, line 3 is a shuffled variant, where all three scenarios will be executed, but in random order. 2\n\nFootnotes\n\n[1]\n\nIn a real implementation, we would probably want to require that the parked car is not initially visible from the ego, to avoid the sudden appearance of cars out of nowhere.\n\n[2]\n\nRespecting preconditions, so in particular the simulation will be rejected if at some point none of the remaining scenarios to execute are enabled.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Dynamic Scenarios — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/tutorials/dynamics.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nAgents, Actions, and Behaviors\nInterrupts\nStateful Behaviors\nRequirements and Monitors\nPreconditions and Invariants\nTerminating the Scenario\nTrying Some Examples\nFurther Reading\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Dynamic Scenarios\n Edit on GitHub\nDynamic Scenarios\n\nThe Scenic Fundamentals described how Scenic can model scenarios like “a badly-parked car” by defining spatial relationships between objects. Here, we’ll cover how to model temporal aspects of scenarios: for a scenario like “a badly-parked car, which pulls into the road as the ego car approaches”, we need to specify not only the initial position of the car but how it behaves over time.\n\nAgents, Actions, and Behaviors\n\nIn Scenic, we call objects which take actions over time dynamic agents, or simply agents. These are ordinary Scenic objects, so we can still use all of Scenic’s syntax for describing their initial positions, orientations, etc. In addition, we specify their dynamic behavior using a built-in property called behavior. Here’s an example using one of the built-in behaviors from the Driving Domain:\n\nmodel scenic.domains.driving.model\nnew Car with behavior FollowLaneBehavior\n\n\nA behavior defines a sequence of actions for the agent to take, which need not be fixed but can be probabilistic and depend on the state of the agent or other objects. In Scenic, an action is an instantaneous operation executed by an agent, like setting the steering angle of a car or turning on its headlights. Most actions are specific to particular application domains, and so different sets of actions are provided by different simulator interfaces. For example, the Driving Domain defines a SetThrottleAction for cars.\n\nTo define a behavior, we write a function which runs over the course of the scenario, periodically issuing actions. Scenic uses a discrete notion of time, so at each time step the function specifies zero or more actions for the agent to take. For example, here is a very simplified version of the FollowLaneBehavior above:\n\nbehavior FollowLaneBehavior():\n    while True:\n        throttle, steering = ...    # compute controls\n        take SetThrottleAction(throttle), SetSteerAction(steering)\n\n\nWe intend this behavior to run for the entire scenario, so we use an infinite loop. In each step of the loop, we compute appropriate throttle and steering controls, then use the take statement to take the corresponding actions. When that statement is executed, Scenic pauses the behavior until the next time step of the simulation, when the function resumes and the loop repeats.\n\nWhen there are multiple agents, all of their behaviors run in parallel; each time step, Scenic sends their selected actions to the simulator to be executed and advances the simulation by one step. It then reads back the state of the simulation, updating the positions and other dynamic properties of the objects.\n\nBehaviors can access the current state of the world to decide what actions to take:\n\nbehavior WaitUntilClose(threshold=15):\n    while (distance from self to ego) > threshold:\n        wait\n    do FollowLaneBehavior()\n\n\nHere, we repeatedly query the distance from the agent running the behavior (self) to the ego car; as long as it is above a threshold, we wait, which means take no actions. Once the threshold is met, we start driving by invoking the FollowLaneBehavior we saw above using the do statement. Since FollowLaneBehavior runs forever, we will never return to the WaitUntilClose behavior.\n\nThe example above also shows how behaviors may take arguments, like any Scenic function. Here, threshold is an argument to the behavior which has default value 15 but can be customized, so we could write for example:\n\nego = new Car\ncar2 = new Car visible, with behavior WaitUntilClose\ncar3 = new Car visible, with behavior WaitUntilClose(20)\n\n\nBoth car2 and car3 will use the WaitUntilClose behavior, but independent copies of it with thresholds of 15 and 20 respectively.\n\nUnlike ordinary Scenic code, control flow constructs such as if and while are allowed to depend on random variables inside a behavior. Any distributions defined inside a behavior are sampled at simulation time, not during scene sampling. Consider the following behavior:\n\n1behavior Foo():\n2    threshold = Range(4, 7)\n3    while True:\n4        if self.distanceToClosest(Pedestrian) < threshold:\n5            strength = TruncatedNormal(0.8, 0.02, 0.5, 1)\n6            take SetBrakeAction(strength), SetThrottleAction(0)\n7        else:\n8            take SetThrottleAction(0.5), SetBrakeAction(0)\n\n\nHere, the value of threshold is sampled only once, at the beginning of the scenario when the behavior starts running. The value strength, on the other hand, is sampled every time control reaches line 5, so that every time step when the car is braking we use a slightly different braking strength (0.8 on average, but with Gaussian noise added with standard deviation 0.02, truncating the possible values to between 0.5 and 1).\n\nInterrupts\n\nIt is frequently useful to take an existing behavior and add a complication to it; for example, suppose we want a car that follows a lane, stopping whenever it encounters an obstacle. Scenic provides a concept of interrupts which allows us to reuse the basic FollowLaneBehavior without having to modify it:\n\nbehavior FollowAvoidingObstacles():\n    try:\n        do FollowLaneBehavior()\n    interrupt when self.distanceToClosest(Object) < 5:\n        take SetBrakeAction(1)\n\n\nThis try-interrupt statement has similar syntax to the Python try statement (and in fact allows except clauses just as in Python), and begins in the same way: at first, the code block after the try: (the body) is executed. At the start of every time step during its execution, the condition from each interrupt clause is checked; if any are true, execution of the body is suspended and we instead begin to execute the corresponding interrupt handler. In the example above, there is only one interrupt, which fires when we come within 5 meters of any object. When that happens, FollowLaneBehavior is paused and we instead apply full braking for one time step. In the next step, we will resume FollowLaneBehavior wherever it left off, unless we are still within 5 meters of an object, in which case the interrupt will fire again.\n\nIf there are multiple interrupt clauses, successive clauses take precedence over those which precede them. Furthermore, such higher-priority interrupts can fire even during the execution of an earlier interrupt handler. This makes it easy to model a hierarchy of behaviors with different priorities; for example, we could implement a car which drives along a lane, passing slow cars and avoiding collisions, along the following lines:\n\nbehavior Drive():\n    try:\n        do FollowLaneBehavior()\n    interrupt when self.distanceToNextObstacle() < 20:\n        do PassingBehavior()\n    interrupt when self.timeToCollision() < 5:\n        do CollisionAvoidance()\n\n\nHere, the car begins by lane following, switching to passing if there is a car or other obstacle too close ahead. During either of those two sub-behaviors, if the time to collision gets too low, we switch to collision avoidance. Once the CollisionAvoidance behavior completes, we will resume whichever behavior was interrupted earlier. If we were in the middle of PassingBehavior, it will run to completion (possibly being interrupted again) before we finally resume FollowLaneBehavior.\n\nAs this example illustrates, when an interrupt handler completes, by default we resume execution of the interrupted code. If this is undesired, the abort statement can be used to cause the entire try-interrupt statement to exit. For example, to run a behavior until a condition is met without resuming it afterward, we can write:\n\nbehavior ApproachAndTurnLeft():\n    try:\n        do FollowLaneBehavior()\n    interrupt when (distance from self to intersection) < 10:\n        abort    # cancel lane following\n    do WaitForTrafficLightBehavior()\n    do TurnLeftBehavior()\n\n\nThis is a common enough use case of interrupts that Scenic provides a shorthand notation:\n\nbehavior ApproachAndTurnLeft():\n    do FollowLaneBehavior() until (distance from self to intersection) < 10\n    do WaitForTrafficLightBehavior()\n    do TurnLeftBehavior()\n\n\nScenic also provides a shorthand for interrupting a behavior after a certain period of time:\n\nbehavior DriveForAWhile():\n    do FollowLaneBehavior() for 30 seconds\n\n\nThe alternative form do behavior for n steps uses time steps instead of real simulation time.\n\nFinally, note that when try-interrupt statements are nested, interrupts of the outer statement take precedence. This makes it easy to build up complex behaviors in a modular way. For example, the behavior Drive we wrote above is relatively complicated, using interrupts to switch between several different sub-behaviors. We would like to be able to put it in a library and reuse it in many different scenarios without modification. Interrupts make this straightforward; for example, if for a particular scenario we want a car that drives normally but suddenly brakes for 5 seconds when it reaches a certain area, we can write:\n\nbehavior DriveWithSuddenBrake():\n    haveBraked = False\n    try:\n        do Drive()\n    interrupt when self in targetRegion and not haveBraked:\n        do StopBehavior() for 5 seconds\n        haveBraked = True\n\n\nWith this behavior, Drive operates as it did before, interrupts firing as appropriate to switch between lane following, passing, and collision avoidance. But during any of these sub-behaviors, if the car enters the targetRegion it will immediately brake for 5 seconds, then pick up where it left off.\n\nStateful Behaviors\n\nAs the last example shows, behaviors can use local variables to maintain state, which is useful when implementing behaviors which depend on actions taken in the past. To elaborate on that example, suppose we want a car which usually follows the Drive behavior, but every 15-30 seconds stops for 5 seconds. We can implement this behavior as follows:\n\nbehavior DriveWithRandomStops():\n    delay = Range(15, 30) seconds\n    last_stop = 0\n    try:\n        do Drive()\n    interrupt when simulation().currentTime - last_stop > delay:\n        do StopBehavior() for 5 seconds\n        delay = Range(15, 30) seconds\n        last_stop = simulation().currentTime\n\n\nHere delay is the randomly-chosen amount of time to run Drive for, and last_stop keeps track of the time when we last started to run it. When the time elapsed since last_stop exceeds delay, we interrupt Drive and stop for 5 seconds. Afterwards, we pick a new delay before the next stop, and save the current time in last_stop, effectively resetting our timer to zero.\n\nNote\n\nIt is possible to change global state from within a behavior by using the Python global statement, for instance to communicate between behaviors. If using this ability, keep in mind that the order in which behaviors of different agents is executed within a single time step could affect your results. The default order is the order in which the agents were defined, but it can be adjusted by overriding the Simulation.scheduleForAgents method.\n\nRequirements and Monitors\n\nJust as you can declare spatial constraints on scenes using the require statement, you can also impose constraints on dynamic scenarios. For example, if we don’t want to generate any simulations where car1 and car2 are simultaneously visible from the ego car, we could write:\n\nrequire always not ((ego can see car1) and (ego can see car2))\n\n\nHere, always condition is a temporal operator which can only be used inside a requirement, and which evaluates to true if and only if the condition is true at every time step of the scenario. So if the condition above is ever false during a simulation, the requirement will be violated, causing Scenic to reject that simulation and sample a new one. Similarly, we can require that a condition hold at some time during the scenario using the eventually operator:\n\nrequire eventually ego in intersection\n\n\nIt is also possible to relate conditions at different time steps. For example, to require that car1 enters the intersection no later than when car2 does, we can use the until operator:\n\nrequire car2 not in intersection until car1 in intersection\nrequire eventually car2 in intersection\n\n\nTemporal operators can be combined with Boolean operators to build up more complex requirements 1, e.g.:\n\nrequire (always car.speed < 30) implies (always distance to car > 10)\n\n\nSee Temporal Operators for a complete list of the available operators and their semantics.\n\nYou can also use the ordinary require statement inside a behavior to require that a given condition hold at a certain point during the execution of the behavior. For example, here is a simple elaboration of the WaitUntilClose behavior we saw above which requires that no pedestrian comes close to self until the ego does (after which we place no further restrictions):\n\nbehavior WaitUntilClose(threshold=15):\n    while distance from self to ego > threshold:\n        require self.distanceToClosest(Pedestrian) > threshold\n        wait\n    do FollowLaneBehavior()\n\n\nIf you want to enforce a complex requirement that isn’t conveniently expressible either using the temporal operators built into Scenic or by modifying a behavior, you can define a monitor. Like behaviors, monitors are functions which run in parallel with the scenario, but they are not associated with any agent and any actions they take are ignored (so you might as well only use the wait statement). Here is a monitor for requiring that a given car spends at most a certain amount of time in the intersection:\n\n1monitor LimitTimeInIntersection(car, limit=100):\n2    stepsInIntersection = 0\n3    while True:\n4        require stepsInIntersection <= limit\n5        if car in intersection:\n6            stepsInIntersection += 1\n7        wait\n\n\nWe use the variable stepsInIntersection to remember how many time steps car has spent in the intersection; if it ever exceeds the limit, the requirement on line 4 will fail and we will reject the simulation. Note the necessity of the wait statement on line 7: if we omitted it, the loop could run forever without any time actually passing in the simulation.\n\nLike behaviors, monitors can take parameters, allowing a monitor defined in a library to be reused in various situations. To instantiate a monitor in a scenario, use the require monitor statement:\n\nrequire monitor LimitTimeInIntersection(ego)\nrequire monitor LimitTimeInIntersection(taxi, limit=200)\n\nPreconditions and Invariants\n\nEven general behaviors designed to be used in multiple scenarios may not operate correctly from all possible starting states: for example, FollowLaneBehavior assumes that the agent is actually in a lane rather than, say, on a sidewalk. To model such assumptions, Scenic provides a notion of guards for behaviors. Most simply, we can specify one or more preconditions:\n\nbehavior MergeInto(newLane):\n    precondition: self.lane is not newLane and self.road is newLane.road\n    ...\n\n\nHere, the precondition requires that whenever the MergeInto behavior is executed by an agent, the agent must not already be in the destination lane but should be on the same road. We can add any number of such preconditions; like ordinary requirements, violating any precondition causes the simulation to be rejected.\n\nSince behaviors can be interrupted, it is possible for a behavior to resume execution in a state it doesn’t expect: imagine a car which is lane following, but then swerves onto the shoulder to avoid an accident; naïvely resuming lane following, we find we are no longer in a lane. To catch such situations, Scenic allows us to define invariants which are checked at every time step during the execution of a behavior, not just when it begins running. These are written similarly to preconditions:\n\nbehavior FollowLaneBehavior():\n    invariant: self in road\n    ...\n\n\nWhile the default behavior for guard violations is to reject the simulation, in some cases it may be possible to recover from a violation by taking some additional actions. To enable this kind of design, Scenic signals guard violations by raising a GuardViolation exception which can be caught like any other exception; the simulation is only rejected if the exception propagates out to the top level. So to model the lane-following-with-collision-avoidance behavior suggested above, we could write code like this:\n\nbehavior Drive():\n    while True:\n        try:\n            do FollowLaneBehavior()\n        interrupt when self.distanceToClosest(Object) < 5:\n            do CollisionAvoidance()\n        except InvariantViolation:   # FollowLaneBehavior has failed\n            do GetBackOntoRoad()\n\n\nWhen any object comes within 5 meters, we suspend lane following and switch to collision avoidance. When the CollisionAvoidance behavior completes, FollowLaneBehavior will be resumed; if its invariant fails because we are no longer on the road, we catch the resulting InvariantViolation exception and run a GetBackOntoRoad behavior to restore the invariant. The whole try statement then completes, so the outermost loop iterates and we begin lane following once again.\n\nTerminating the Scenario\n\nBy default, scenarios run forever, unless the --time option is used to impose a time limit. However, scenarios can also define termination criteria using the terminate when statement; for example, we could decide to end a scenario as soon as the ego car travels at least a certain distance:\n\nstart = new Point on road\nego = new Car at start\nterminate when (distance to start) >= 50\n\n\nAdditionally, the terminate statement can be used inside behaviors and monitors: if it is ever executed, the scenario ends. For example, we can use a monitor to terminate the scenario once the ego spends 30 time steps in an intersection:\n\nmonitor StopAfterTimeInIntersection:\n    totalTime = 0\n    while totalTime < 30:\n        if ego in intersection:\n            totalTime += 1\n        wait\n    terminate\n\n\nNote\n\nIn order to make sure that requirements are not violated, termination criteria are only checked after all requirements. So if in the same time step a monitor uses the terminate statement but another behavior uses require with a false condition, the simulation will be rejected rather than terminated.\n\nTrying Some Examples\n\nYou can see all of the above syntax in action by running some of our examples of dynamic scenarios. We have examples written for the CARLA and LGSVL driving simulators, and those in examples/driving in particular are designed to use Scenic’s abstract driving domain and so work in either of these simulators, as well as Scenic’s built-in Newtonian physics simulator. The Newtonian simulator is convenient for testing and simple experiments; you can find details on how to install the more realistic simulators in our Supported Simulators page (they should work on both Linux and Windows, but not macOS, at the moment).\n\nLet’s try running examples/driving/badlyParkedCarPullingIn.scenic, which implements the “a badly-parked car, which pulls into the road as the ego car approaches” scenario we mentioned above. To start out, you can run it like any other Scenic scenario to get the usual schematic diagram of the generated scenes:\n\n$ scenic examples/driving/badlyParkedCarPullingIn.scenic --2d\n\n\nTo run dynamic simulations, add the --simulate option (-S for short). Since this scenario is not written for a particular simulator, you’ll need to specify which one you want by using the --model option (-m for short) to select the corresponding Scenic world model: for example, to use the Newtonian simulator we could add --model scenic.simulators.newtonian.driving_model. It’s also a good idea to put a time bound on the simulations, which we can do using the --time option.\n\n$ scenic examples/driving/badlyParkedCarPullingIn.scenic \\\n    --2d       \\\n    --simulate \\\n    --model scenic.simulators.newtonian.driving_model \\\n    --time 200\n\n\nRunning the scenario in CARLA is exactly the same, except we use the --model scenic.simulators.carla.model option instead (make sure to start CARLA running first). For LGSVL, the one difference is that this scenario specifies a map which LGSVL doesn’t have built in; fortunately, it’s easy to switch to a different map. For scenarios using the driving domain, the map file is specified by defining a global parameter map, and for the LGSVL interface we use another parameter lgsvl_map to specify the name of the map in LGSVL (the CARLA interface likewise uses a parameter carla_map). These parameters can be set at the command line using the --param option (-p for short); for example, let’s pick the “BorregasAve” LGSVL map, an OpenDRIVE file for which is included in the Scenic repository. We can then run a simulation by starting LGSVL in “API Only” mode and invoking Scenic as follows:\n\n$ scenic examples/driving/badlyParkedCarPullingIn.scenic \\\n    --2d       \\\n    --simulate \\\n    --model scenic.simulators.lgsvl.model \\\n    --time 200 \\\n    --param map assets/maps/LGSVL/borregasave.xodr \\\n    --param lgsvl_map BorregasAve\n\n\nTry playing around with different example scenarios and different choices of maps (making sure that you keep the map and lgsvl_map/carla_map parameters consistent). For both CARLA and LGSVL, you don’t have to restart the simulator between scenarios: just kill Scenic 2 and restart it with different arguments.\n\nFurther Reading\n\nThis tutorial illustrated most of Scenic’s core syntax for dynamic scenarios. As with the rest of Scenic’s syntax, these constructs are summarized in our Syntax Guide, with links to detailed documentation in the Language Reference. You may also be interested in some other sections of the documentation:\n\nComposing Scenarios\n\nBuilding more complex scenarios out of simpler ones in a modular way.\n\nSupported Simulators\n\nDetails on which simulator interfaces support dynamic scenarios.\n\nExecution of Dynamic Scenarios\n\nThe gory details of exactly how behaviors run, monitors are checked, etc. (probably not worth reading unless you’re having a subtle timing issue).\n\nFootnotes\n\n[1]\n\nFor those familiar with temporal logic, you can encode any formula of Linear Temporal Logic.\n\n[2]\n\nOr use the --count option to have Scenic automatically terminate after a desired number of simulations.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Scenic Fundamentals — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/tutorials/fundamentals.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nObjects, Geometry, and Specifiers\nRandomness and Regions\nOrientations in Depth\nPoints, Oriented Points, and Classes\nModels and Simulators\nSpecifiers in Depth\nDeclarative Hard and Soft Constraints\nMutations\nA Worked Example\nFurther Reading\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Scenic Fundamentals\n Edit on GitHub\nScenic Fundamentals\n\nThis tutorial motivates and illustrates the main features of Scenic, focusing on aspects of the language that make it particularly well-suited for describing geometric scenarios. We begin by walking through Scenic’s core features from first principles, using simple toy examples displayed in Scenic’s built-in visualizer. We then consider discuss two case studies in depth: using Scenic to generate traffic scenes to test and train autonomous cars (as in [F22], [F19]), and testing a motion planning algorithm for a Mars rover able to climb over rocks. These examples show Scenic interfacing with actual simulators, and demonstrate how it can be applied to real problems.\n\nWe’ll focus here on the spatial aspects of scenarios; for adding temporal dynamics to a scenario, see our page on Dynamic Scenarios.\n\nObjects, Geometry, and Specifiers\n\nTo start with, we’ll construct a very basic Scenic program:\n\n1ego = new Object\n\n\nRunning this program should cause a window to pop up, looking like this:\n\nYou can rotate and move the camera of the visualizer around using the mouse. The only Object currently present is the one we created using the new keyword (rendered as a green box). Since we assigned this object to the ego name, it has special significance to Scenic, as we’ll see later. For now it only has the effect of highlighting the object green in Scenic’s visualizer. Pressing w will render all objects as wireframes, which will allow you to see the coordinate axes in the center of the ego object (at the origin).\n\nSince we didn’t provide any additional information to Scenic about this object, its properties like position, orientation, width, etc. were assigned default values from the object’s class: here, the built-in class Object, representing a physical object. So we end up with a generic cube at the origin. To define the properties of an object, Scenic provides a flexible system of specifiers based on the many ways one can describe the position and orientation of an object in natural language. We can see a few of these specifiers in action in the following slightly more complex program (see the Syntax Guide for a summary of all the specifiers, and the Specifiers Reference for detailed definitions):\n\n 1ego = new Object with shape ConeShape(),\n 2        with width 2,\n 3        with length 2,\n 4        with height 1.5,\n 5        facing (-90 deg, 45 deg, 0)\n 6\n 7chair = new Object at (4,0,2),\n 8            with shape MeshShape.fromFile(localPath(\"meshes/chair.obj\"),\n 9                initial_rotation=(0,90 deg,0), dimensions=(1,1,1))\n10\n11plane_shape = MeshShape.fromFile(path=localPath(\"meshes/plane.obj\"))\n12\n13plane = new Object left of chair by 1,\n14            with shape plane_shape,\n15            with width 2,\n16            with length 2,\n17            with height 1,\n18            facing directly toward ego\n\n\nThis should generate the following scene:\n\nThe first object we create, the ego, has a cone shape. Scenic provides several built-in shapes like this (see Shape for a list). We then set the object’s dimensions using the with specifier, which can set any property (even properties not built into Scenic, which you might access in your own code or which a particular simulator might understand). Finally, we set the object’s global orientation (its orientation property) using the facing specifier. The tuple after facing contains the Euler angles of the desired orientation (yaw, pitch, roll).\n\nThe second object we create is first placed at a specific point in space using the at specifier (setting the object’s position property). We then set its shape to one imported from a mesh file, using the MeshShape class, applying an initial rotation to tell Scenic which side of the chair is its front. We also set default dimensions of the shape, which the object will then automatically inherit. If we hadn’t set these default dimensions, Scenic would automatically infer the dimensions from the mesh file.\n\nOn line 11 we load a shape from a file, specifically to highlight that since Scenic is built on top of Python, we can write arbitrary Python expressions in Scenic (with some exceptions).\n\nFor our third and final object, we use the left of specifier to place it to the left of chair (the second object) by 1 unit. We set its shape and dimensions, similar to before, and then orient it to face directly toward the ego object using the facing directly toward specifier. This gives a first hint of the power of specifiers, with Scenic automatically working out how to compute the object’s orientation so that it faces the ego regardless of how we specified its position (in fact, we could move the left of specifier to be after the facing directly toward and the code would still work).\n\nScenic will automatically reject scenarios that don’t make physical sense, for instance when objects intersect each other 1. For an example of this, try changing the code above to have a much larger ego object, to the point where it would intersect with the plane. While this isn’t too important in the scenarios we’ve seen so far, it becomes very useful when we start constructing random scenarios.\n\nRandomness and Regions\n\nSo far all of our Scenic programs have defined concrete scenes, i.e. they uniquely define all the aspects of a scene, so every time we run the program we’ll get the same scene. This is because so far we haven’t introduced any randomness. Scenic is a probabilistic programming language, meaning a single Scenic program can in fact define a probability distribution over many possible scenes.\n\nLet’s look at a simple Scenic program with some random elements:\n\n1ego = new Object with shape Uniform(BoxShape(), SpheroidShape(), ConeShape()),\n2                 with width Range(1,2),\n3                 with length Range(1,2),\n4                 with height Range(1,3),\n5                 facing (Range(0,360) deg, Range(0,360) deg, Range(0,360) deg)\n\n\nThis will generate an object with a shape that is either a box, a spheroid, or a cone (each with equal probability). It will have a random width, length, and height within the ranges specified, and uniformly random rotation angles. Some examples:\n\n  \n\nRandom values can be used almost everywhere in Scenic; the major exception is that control flow (e.g. if statements and for loops) cannot depend on random values. This restriction enables more efficient sampling (see [F19]) and can often be worked around: for example it is still possible to select random elements satisfying desired criteria from lists (see filter).\n\nAnother key construct in Scenic is a Region, which represents a set of points in space. Having defined a region of interest, for example a lane of a road, you can then sample points from it, check whether objects are contained in it, etc. You can also use a region to define the workspace, a designated region which all objects in the scenario must be contained in (useful, for example, if the simulated world has fixed obstacles that Scenic objects should not intersect). For example, the following code:\n\n1region = RectangularRegion((0,0,0), 0, 10, 10)\n2workspace = Workspace(region)\n3\n4new Object in region, with shape SpheroidShape()\n5new Object in region, with shape SpheroidShape()\n6new Object in region, with shape SpheroidShape()\n\n\nshould generate a scene similar to this:\n\nNote that in this scene the coordinate axes in the center are displayed due to the --axes flag, which can help clarify orientation.\n\nWe first create a 10-unit square RectangularRegion, and set it as the scenario’s workspace. RectangularRegion is a 2D region, meaning it does not have a volume and therefore can’t really contain objects. It is still a valid workspace, however, since for containment checks involving 2D regions, Scenic automatically uses the region’s footprint, which extends infinitely in the positive and negative Z directions. We then create 3 spherical objects and place them using the in specifier, which sets the position of an object (its center) to a uniformly-random point in the given region.\n\nSimilarly, we can use the on specifier to place the base of an object uniformly at random in a region, where the base is by default the center of the bottom side of its bounding box. The on specifier is also overloaded to work on objects, by default extracting the top surface of the object’s mesh and placing the object on that. This can lead to very compact syntax for randomly placing objects on others, as seen in the following example:\n\n1workspace = Workspace(RectangularRegion((0,0,0), 0, 4, 4))\n2floor = workspace\n3\n4chair = new Object on floor,\n5            with shape MeshShape.fromFile(path=localPath(\"meshes/chair.obj\"),\n6                dimensions=(1,1,1), initial_rotation=(0, 90 deg, 0))\n7\n8ego = new Object on chair,\n9            with shape ConeShape(dimensions=(0.25,0.25,0.25))\n\n\nwhich might generate something like this:\n\nOrientations in Depth\n\nNotice how in the last example the cone is oriented to be tangent with the curved surface of the chair, even though we never set an orientation with facing. To explain this behavior, we need to look deeper into Scenic’s orientation system. All objects have an orientation property, which is their orientation in global coordinates 2. If you just want to set the orientation by giving explicit angles in global coordinates, you can use the facing specifier as we saw above. However, it’s often useful to specify the orientation of an object in terms of some other coordinate system, for instance that of another object. To support such use cases, Scenic does not allow directly setting the value of orientation using with: instead, its value is derived from the values of 4 other properties, parentOrientation, yaw, pitch, and roll. The parentOrientation property defines the parent orientation of the object, which is the orientation with respect to which the (intrinsic Euler) angles yaw, pitch, and roll are interpreted. Specifically, orientation is obtained as follows:\n\nstart from parentOrientation;\n\napply a yaw (a CCW rotation around the positive Z axis) of yaw;\n\napply a pitch (a CCW rotation around the resulting positive X axis) of pitch;\n\napply a roll (a CCW rotation around the resulting positive Y axis) of roll.\n\nBy default, parentOrientation is aligned with the global coordinate system, so that yaw for example is just the angle by which to rotate the object around the Z axis (this corresponds to the heading property in older versions of Scenic). But by setting parentOrientation to the orientation of another object, we can easily compose rotations together: “face the same way as the plane, but upside-down” could be implemented with parentOrientation plane.orientation, with roll 180 deg.\n\nIn fact it is often unnecessary to set parentOrientation yourself, since many of Scenic’s specifiers do so automatically when there is a natural choice of orientation to use. This includes all specifiers which position one object in terms of another: if we write new Object ahead of plane by 100, the ahead of specifier specifies position to be 100 meters ahead of the plane but also specifies parentOrientation to be plane.orientation. So by default the new object will be oriented the same way as the plane; to implement the “upside-down” part, we could simply write new Object ahead of plane by 100, with roll 180 deg. Importantly, the ahead of specifier here only specifies parentOrientation optionally, giving it a new default value: if you want a different value, you can override that default by explicitly writing with parentOrientation value. (We’ll return to how Scenic manages default values and “optional” specifications later.)\n\nAnother case where a specifier sets parentOrientation automatically is our cone-on-a-chair example above: in the code new Object on chair, the on specifier not only specifies position to be a random point on the top surface of the chair but also specifies parentOrientation to be an orientation tangent to the surface at that point. Thus the cone lies flat on the surface by default without our needing to specify its orientation; we could even add code like with roll 45 deg to rotate the cone while keeping it tangent with the surface.\n\nIn general, the on region specifier specifies parentOrientation whenever the region in question has a preferred orientation: a Vector Field (another primitive Scenic type) which defines an orientation at each point in the region. The class MeshSurfaceRegion, used to represent surfaces of an object, has a default preferred orientation which is tangent to the surface, allowing us to easily place objects on irregular surfaces as we’ve seen. Preferred orientations can also be convenient for modeling the nominal driving direction on roads, for example (we’ll return to this use case below).\n\nPoints, Oriented Points, and Classes\n\nWe’ve seen that Scenic has a built-in class Object for representing physical objects, and that individual objects are instantiated using the new keyword. Object is actually the bottom class in a hierarchy of built-in Scenic classes that support this syntax: its superclass is OrientedPoint, whose superclass in turn is Point. The base class Point provides the position property, while its subclass OrientedPoint adds orientation (plus parentOrientation, yaw, etc.). These two classes do not represent physical objects and aren’t included in scenes generated by Scenic, but they provide a convenient way to use specifier syntax to construct positions and orientations for later use without creating actual objects. A Point can be used anywhere where a vector is expected (e.g. at point), and an OrientedPoint can also be used anywhere where an orientation is expected. With both a position and an orientation, an OrientedPoint defines a local coordinate system, and so can be used with specifiers like ahead of to position objects:\n\nspot = new OrientedPoint on curb\nnew Object left of spot by 0.25\n\n\nHere, suppose curb is a region with a preferred orientation aligned with the plane of the road and along the curb; then the first line creates an OrientedPoint at a uniformly-random position on the curb, oriented along the curb. So the second line then creates an Object offset 0.25 meters into the road, regardless of which direction the road happens to run in the global coordinate system.\n\nScenic also allows users to define their own classes. In our earlier example placing spheres in a region, we explicitly wrote out the specifiers for each object we created even though they were all identical. Such repetition can often be avoided by using functions and loops, and by defining a class of object providing new default values for properties of interest. Our example could be equivalently written:\n\n1workspace = Workspace(RectangularRegion((0,0,0), 0, 10, 10))\n2\n3class SphereObject:\n4    position: new Point in workspace\n5    shape: SpheroidShape()\n6\n7for i in range(3):\n8    new SphereObject\n\n\nHere we define the SphereObject class, providing new default values for the position and shape properties, overriding those inherited from Object (the default superclass if none is explicitly given). So for example the default position for a SphereObject is the expression new Point in workspace, which creates a Point that can be automatically interpreted as a position. This gives us a way to get the convenience of specifiers in class definitions. Note that this is a random expression, and it is evaluated independently each time a SphereObject is defined; so the loop creates 3 objects which will all have different positions (and as usual Scenic will ensure they do not overlap). We can still override the default value as needed: adding the line new SphereObject at (0,0,5) would create a SphereObject which still used the default value of shape but whose position is exactly (0,0,5).\n\nIn addition to the special syntax seen above for defining properties of a class and instantiating an instance of a class, Scenic classes support inheritance and methods in the same way as Python:\n\nclass Vehicle:\n    pass\nclass Taxicab(Vehicle):\n    magicNumber: 42\n\n    def myMethod(self, x):\n        return self.width + self.magicNumber + x\n\nego = new Taxicab with magicNumber 1729\ny = ego.myMethod(3.14)\n\nModels and Simulators\n\nFor the next part of this tutorial, we’ll move beyond the internal Scenic visualizer to an actual simulator. Specifically, we will consider examples from our case study using Scenic to generate traffic scenes in GTA V to test and train autonomous cars ([F19], [F22]).\n\nTo start, suppose we want scenes of one car viewed from another on the road. We can write this very concisely in Scenic:\n\n1from scenic.simulators.gta.model import Car\n2ego = new Car\n3new Car\n\n\nLine 1 imports the GTA world model, a Scenic library defining everything specific to our GTA interface. This includes the definition of the class Car, as well as information about the road geometry that we’ll see later. We’ll suppress this import statement in subsequent examples.\n\nLine 2 then creates a Car and assigns it to the special variable ego specifying the ego object, which we’ve seen before. This is the reference point for the scenario: our simulator interfaces typically use it as the viewpoint for rendering images, and many of Scenic’s geometric operators use ego by default when a position is left implicit 3.\n\nFinally, line 3 creates a second Car. Compiling this scenario with Scenic, sampling a scene from it, and importing the scene into GTA V yields an image like this:\n\nA scene sampled from the simple car scenario, rendered in GTA V.\n\nNote that both the ego car (where the camera is located) and the second car are both located on the road and facing along it, despite the fact that the code above does not specify the position or any other properties of the two cars. This is because reasonable default values for these properties have already been defined in the Car definition (shown here slightly simplified):\n\n1class Car:\n2    position: new Point on road\n3    heading: roadDirection at self.position    # note: can only set `heading` in 2D mode\n4    width: self.model.width\n5    length: self.model.length\n6    model: CarModel.defaultModel()      # a distribution over several car models\n7    requireVisible: True    # so all cars appear in the rendered images\n\n\nHere road is a region defined in the gta model to specify which points in the workspace are on a road. Similarly, roadDirection is a Vector Field specifying the nominal traffic direction at such points. The operator F at X simply gets the direction of the field F at point X, so line 3 sets a Car’s default heading to be the road direction at its position. The default position, in turn, is a new Point on road, which means a uniformly random point on the road. Thus, in our simple scenario above both cars will be placed on the road facing a reasonable direction, without our having to specify this explicitly.\n\nOne further point of interest in the code above is that the default value for heading depends on the value of position, and the default values of width and length depend on model. Scenic allows default value expressions to use the special syntax self.property to refer to the value of another property of the object being defined: Scenic tracks the resulting dependencies and evaluates the expressions in an appropriate order (or raises an error if there are any cyclic dependencies). This capability is also frequently used by specifiers, as we explain next.\n\nSpecifiers in Depth\nWhy Specifiers?\n\nThe syntax left of X and facing Y for specifying positions and orientations may seem unusual compared to typical constructors in object-oriented languages. There are two reasons why Scenic uses this kind of syntax: first, readability. The second is more subtle and based on the fact that in natural language there are many ways to specify positions and other properties, some of which interact with each other. Consider the following ways one might describe the location of a car:\n\n“is at position X” (an absolute position)\n\n“is just left of position X” (a position based on orientation)\n\n“is 3 m West of the taxi” (a relative position)\n\n“is 3 m left of the taxi” (a local coordinate system)\n\n“is one lane left of the taxi” (another local coordinate system)\n\n“appears to be 10 m behind the taxi” (relative to the line of sight)\n\n“is 10 m along the road from the taxi” (following a potentially-curving vector field)\n\nThese are all fundamentally different from each other: for example, (4) and (5) differ if the taxi is not parallel to the lane.\n\nFurthermore, these specifications combine other properties of the object in different ways: to place the object “just left of” a position, we must first know the object’s orientation; whereas if we wanted to face the object “towards” a location, we must instead know its position. There can be chains of such dependencies: for example, the description “the car is 0.5 m left of the curb” means that the right edge of the car is 0.5 m away from the curb, not its center, which is what the car’s position property stores. So the car’s position depends on its width, which in turn depends on its model. In a typical object-oriented language, these dependencies might be handled by first computing values for position and all other properties, then passing them to a constructor. For “a car is 0.5 m left of the curb” we might write something like:\n\n# hypothetical Python-like language (not Scenic)\nmodel = Car.defaultModelDistribution.sample()\npos = curb.offsetLeft(0.5 + model.width / 2)\ncar = Car(pos, model=model)\n\n\nNotice how model must be used twice, because model determines both the model of the car and (indirectly) its position. This is inelegant, and breaks encapsulation because the default model distribution is used outside of the Car constructor. The latter problem could be fixed by having a specialized constructor or factory function:\n\n# hypothetical Python-like language (not Scenic)\ncar = CarLeftOfBy(curb, 0.5)\n\n\nHowever, such functions would proliferate since we would need to handle all possible combinations of ways to specify different properties (e.g. do we want to require a specific model? Are we overriding the width provided by the model for this specific car?). Instead of having a multitude of such monolithic constructors, Scenic uses specifiers to factor the definition of objects into potentially-interacting but syntactically-independent parts:\n\nnew Car left of curb by 0.5,\n        with model CarModel.models['BUS']\n\n\nHere the specifiers left of X by D and with model M do not have an order, but together specify the properties of the car. Scenic works out the dependencies between properties (here, position is provided by left of, which depends on width, whose default value depends on model) and evaluates them in the correct order. To use the default model distribution we would simply omit line 2; keeping it affects the position of the car appropriately without having to specify BUS more than once.\n\nDependencies and Modifying Specifiers\n\nIn addition to explicit dependencies when one specifier uses a property defined by another, Scenic also tracks dependencies which arise when an expression implicitly refers to the properties of the object being defined. For example, suppose we wanted to elaborate the scenario above by saying the car is oriented up to 5° off of the nominal traffic direction. We can write this using the roadDirection vector field and Scenic’s general operator X relative to Y, which can interpret vectors and orientations as being in a variety of local coordinate systems:\n\nnew Car left of curb by 0.5,\n        facing Range(-5, 5) deg relative to roadDirection\n\n\nNotice that since roadDirection is a vector field, it defines a different local coordinate system at each point in space: at different points on the map, roads point different directions! Thus an expression like 15 deg relative to field does not define a unique heading. The example above works because Scenic knows that the expression Range(-5, 5) deg relative to roadDirection depends on a reference position, and automatically uses the position of the Car being defined.\n\nAnother kind of dependency arises from modifying specifiers, which are specifiers that can take an already-specified value for a property and modify it (thereby in a sense both depending on that property and specifying it). The main example is the on region specifier, which in addition to the usage we saw above for placing an object randomly within a region, also can be used as a modifying specifier: if the position property has already been specified, then on region projects that position onto the region. So for example the code new Object ahead of plane by 100, on ground does not raise an error even though both ahead of and on specify position: Scenic first computes a position 100 m ahead of the plane, and then projects that position down onto the ground.\n\nSpecifier Priorities\n\nAs we’ve discussed previously, specifiers can specify multiple properties, and they can specify some properties optionally, allowing other specifiers to override them. In fact, when a specifier specifies a property it does so with a priority represented by a positive integer. A property specified with priority 1 cannot be overridden; increasingly large integers represent lower priorities, so a priority-2 specifier overrides one with priority 3. This system enables more-specific specifiers to naturally take precedence over more general specifiers while reducing the amount of boilerplate code you need to write. Consider for example the following sequence of object creations, where we provide progressively more information about the object:\n\nIn new Object ahead of plane by 100, the ahead of specifier specifies parentOrientation with priority 3, so that the new object is aligned with the plane (a reasonable default since we’re positioning the object with respect to the plane).\n\nIn new Object ahead of plane by 100, on ground, the on ground specifies parentOrientation with priority 2, so it takes precedence and the object is aligned with the ground rather than the plane (which makes more sense since “on ground” implies the object likely lies flat on the ground).\n\nFinally, in new Object ahead of plane by 100, on ground, with parentOrientation (0, 90 deg, 0), the with specifier specifies parentOrientation with priority 1, so it takes precedence and Scenic uses the explicit orientation the user provided.\n\nAs these examples show, specifier priorities enable concise specifications of objects to have intuitive default behavior when no explicit information is given, while at the same time overriding this behavior remains straightforward.\n\nFor a more thorough look at the specifier system, including which specifiers specify which properties and at which priorities, consult the Specifiers Reference.\n\nDeclarative Hard and Soft Constraints\n\nNotice that in the scenarios above we never explicitly ensured that two cars will not intersect each other. Despite this, Scenic will never generate such scenes. This is because Scenic enforces several default requirements, as mentioned above:\n\nAll objects must be contained in the workspace, or a particular specified region (its container). For example, we can define the Car class so that all of its instances must be contained in the region road by default.\n\nObjects must not intersect each other (unless explicitly allowed).\n\nScenic also allows the user to define custom requirements checking arbitrary conditions built from various geometric predicates. For example, the following scenario produces a car headed roughly towards the camera, while still facing the nominal road direction:\n\nego = new Car on road\ncar2 = new Car offset by (Range(-10, 10), Range(20, 40)), with viewAngle 30 deg\nrequire car2 can see ego\n\n\nHere we have used the X can see Y predicate, which in this case is checking that the ego car is inside the 30° view cone of the second car.\n\nRequirements, called observations in other probabilistic programming languages, are very convenient for defining scenarios because they make it easy to restrict attention to particular cases of interest. Note how difficult it would be to write the scenario above without the require statement: when defining the ego car, we would have to somehow specify those positions where it is possible to put a roughly-oncoming car 20–40 meters ahead (for example, this is not possible on a one-way road). Instead, we can simply place ego uniformly over all roads and let Scenic work out how to condition the distribution so that the requirement is satisfied 4. As this example illustrates, the ability to declaratively impose constraints gives Scenic greater versatility than purely-generative formalisms. Requirements also improve encapsulation by allowing us to restrict an existing scenario without altering it. For example:\n\nfrom myScenarioLib import genericTaxiScenario    # import another Scenic scenario\nfifthAvenue = ...             # extract a Region from a map here\nrequire genericTaxiScenario.taxi in fifthAvenue\n\n\nThe constraints in our examples above are hard requirements which must always be satisfied. Scenic also allows imposing soft requirements that need only be true with some minimum probability:\n\nrequire[0.5] car2 can see ego   # condition only needs to hold with prob. >= 0.5\n\n\nSuch requirements can be useful, for example, in ensuring adequate representation of a particular condition when generating a training set: for instance, we could require that at least 90% of generated images have a car driving on the right side of the road.\n\nMutations\n\nA common testing paradigm is to randomly generate variations of existing tests. Scenic supports this paradigm by providing syntax for performing mutations in a compositional manner, adding variety to a scenario without changing its code. For example, given a complex scenario involving a taxi, we can add one additional line:\n\nfrom bigScenario import taxi\nmutate taxi\n\n\nThe mutate statement will add Gaussian noise to the position and orientation properties of taxi, while still enforcing all built-in and custom requirements. The standard deviation of the noise can be scaled by writing, for example, mutate taxi by 2 (which adds twice as much noise), and in fact can be controlled separately for position and orientation (see scenic.core.object_types.Mutator).\n\nA Worked Example\n\nWe conclude with a larger example of a Scenic program which also illustrates the language’s utility across domains and simulators. Specifically, we consider the problem of testing a motion planning algorithm for a Mars rover able to climb over hills and rocks. Such robots can have very complex dynamics, with the feasibility of a motion plan depending on exact details of the robot’s hardware and the geometry of the terrain. We can use Scenic to write a scenario generating challenging cases for a planner to solve in simulation. Some of the specifiers and operators we’ll use have not been discussed before in the tutorial; as usual, information about them can be found in the Syntax Guide.\n\nWe will write a scenario representing a hilly field of rocks and pipes with a bottleneck between the rover and its goal that forces the path planner to consider climbing over a rock. First, we import a small Scenic library for the Webots robotics simulator and a mars specific library which defines the (empty) workspace and several types of objects: the Rover itself, the Goal (represented by a flag), the MarsGround and MarsHill classes which are used to create the hilly terrain, and debris classes Rock, BigRock, and Pipe. Rock and BigRock have fixed sizes, and the rover can climb over them; Pipe cannot be climbed over, and can represent a pipe of arbitrary length, controlled by the length property (which corresponds to Scenic’s Y axis).\n\n1model scenic.simulators.webots.mars.model\n2from mars_lib import *\n\n\nHere we’ve used the model statement to select the world model for the scenario: it is equivalent to from scenic.simulators.webots.model import * except that the choice of model can be overridden from the command line when compiling the scenario (using the --model option). This is useful for scenarios that use one of Scenic’s Abstract Domains: the scenario can be written once in a simulator-agnostic manner, then used with different simulators by selecting the appropriate simulator-specific world model.\n\nNow we can start to create objects. The first object we will create will be the hilly ground. To do this, we use the MarsGround which has a terrain property which should be set to a collection of MarsHill classes, each of which adds a gaussian hill to the ground. Note that the MarsGround object has allowCollisions set to True, allowing objects to intersect and be slightly embedded in the ground. In the following code we create a ground object with 60 small hills (which are allowed to stack on top of each other):\n\n5ground = new MarsGround on (0,0,0), with terrain [new MarsHill for _ in range(60)]\n\n\nWe next create the rover at a fixed position and the goal at a random position on the other side of the workspace, ensuring both are on the ground:\n\n8ego = new Rover at (0, -3), on ground, with controller 'sojourner'\n9goal = new Goal at (Range(-2, 2), Range(2, 3)), on ground, facing (0,0,0)\n\n\nNext we pick a position for the bottleneck, requiring it to lie roughly on the way from the robot to its goal, and place a rock there. Here we use the simple form of facing which takes a scalar argument, effectively setting the yaw of the object in the global coordinate system (so that 0 deg is due North, for example, and 90 deg is due West).\n\n15bottleneck = new OrientedPoint at ego offset by Range(-1.5, 1.5) @ Range(0.5, 1.5), facing Range(-30, 30) deg\n16require abs((angle to goal) - (angle to bottleneck)) <= 10 deg\n17new BigRock at bottleneck, on ground\n\n\nNote how we define bottleneck as an OrientedPoint, with a range of possible orientations: this is to set up a local coordinate system for positioning the pipes making up the bottleneck. Specifically, we position two pipes of varying lengths on either side of the bottleneck, projected onto the ground, with their ends far enough apart for the robot to be able to pass between. Note that we explicitly specify parentOrientation to be the global coordinate system, which prevents the pipes from lying tangent to the ground as we want them flat and partially embedded in the ground.\n\n16gap = 1.2 * ego.width\n17halfGap = gap / 2\n18\n19leftEdge = new OrientedPoint left of bottleneck by halfGap,\n20    facing Range(60, 120) deg relative to bottleneck.heading\n21rightEdge = new OrientedPoint right of bottleneck by halfGap,\n22    facing Range(-120, -60) deg relative to bottleneck.heading\n23\n24new Pipe ahead of leftEdge, with length Range(1, 2), on ground, facing leftEdge, with parentOrientation 0\n25new Pipe ahead of rightEdge, with length Range(1, 2), on ground, facing rightEdge, with parentOrientation 0\n\n\nFinally, to make the scenario slightly more interesting, we add several additional obstacles, positioned either on the far side of the bottleneck or anywhere at random (recalling that Scenic automatically ensures that no objects will overlap).\n\n29new Pipe on ground, with parentOrientation 0\n30new BigRock beyond bottleneck by Range(0.25, 0.75) @ Range(0.75, 1), on ground\n31new BigRock beyond bottleneck by Range(-0.75, -0.25) @ Range(0.75, 1), on ground\n32new Rock on ground\n33new Rock on ground\n34new Rock on ground\n\n\nThis completes the scenario, which can also be found in the Scenic repository under examples/webots/mars/narrowGoal.scenic. Scenes generated from the scenario, and visualized in Scenic’s internal visualizer and Webots, are shown below.\n\nA scene sampled from the Mars rover scenario, rendered in Scenic’s internal visualizer.\n\nA scene sampled from the Mars rover scenario, rendered in Webots.\n\nFurther Reading\n\nThis tutorial illustrated the syntax of Scenic through several simple examples. Much more complex scenarios are possible, such as the platoon and bumper-to-bumper traffic GTA V scenarios shown below. For many further examples using a variety of simulators, see the examples folder, as well as the links in the Supported Simulators page.\n\n     \n\nOur tutorial on Dynamic Scenarios describes how to define scenarios with dynamic agents that move or take other actions over time. We also have a tutorial on Composing Scenarios: defining scenarios in a modular, reusable way and combining them to build up more complex scenarios.\n\nFor a comprehensive overview of Scenic’s syntax, including details on all specifiers, operators, distributions, statements, and built-in classes, see the Language Reference. Our Syntax Guide summarizes all of these language constructs in convenient tables with links to the detailed documentation.\n\nFootnotes\n\n[1]\n\nAlthough collisions can be allowed on a per-object basis: see the allowCollisions property of Object.\n\n[2]\n\nRepresented as an instance of the Orientation class, which internally uses quaternions (although you shouldn’t need to worry about that). In the rare case where you need to manipulate orientations beyond what Scenic’s operators provide, see the documentation for Orientation.\n\n[3]\n\nIn fact, since ego is a variable and can be reassigned, we can set ego to one object, build a part of the scene around it, then reassign ego and build another part of the scene.\n\n[4]\n\nOn the other hand, Scenic may have to work hard to satisfy difficult constraints. Ultimately Scenic falls back on rejection sampling, which in the worst case will run forever if the constraints are inconsistent (although we impose a limit on the number of iterations: see Scenario.generate).\n\nReferences\n\n[F22]\n(1,2)\n\nFremont et al., Scenic: A Language for Scenario Specification and Data Generation, Machine Learning, 2022. [Online]\n\n[F19]\n(1,2,3)\n\nFremont et al., Scenic: A Language for Scenario Specification and Scene Generation, PLDI 2019.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Getting Started with Scenic — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/quickstart.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nInstallation\nTrying Some Examples\nLearning More\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Getting Started with Scenic\n Edit on GitHub\nGetting Started with Scenic\nInstallation\n\nScenic requires Python 3.8 or newer. Run python --version to make sure you have a new enough version; if not, you can install one from the Python website or using pyenv (e.g. running pyenv install 3.11). If the version of Python you want to use is called something different than just python on your system, e.g. python3.11, use that name in place of python when creating a virtual environment below.\n\nThere are two ways to install Scenic:\n\nfrom our repository, which has the very latest features but may not be stable. The repository also contains example scenarios such as those used in the instructions below and our tutorials.\n\nfrom the Python Package Index (PyPI), which will get you the latest official release of Scenic but will not include example scenarios, etc.\n\nIf this is your first time using Scenic, we suggest installing from the repository so that you can try out the example scenarios.\n\nOnce you’ve decided which method you want to use, follow the instructions below for your operating system. If you encounter any errors, please see our Notes on Installing Scenic for suggestions.\n\nmacOSLinuxWindowsWSL\n\nActivate the virtual environment in which you want to install Scenic. To create and activate a new virtual environment called venv, you can run the following commands:\n\npython3 -m venv venv\nsource venv/bin/activate\n\n\nOnce your virtual environment is activated, you no longer need to use a name like python3 or python3.11; use just python to ensure you’re running the copy of Python in your virtual environment.\n\nNext, make sure your pip tool is up-to-date:\n\npython -m pip install --upgrade pip\n\n\nNow you can install Scenic either from the repository or from PyPI:\n\nRepositoryPyPI\n\nThe following commands will clone the Scenic repository into a folder called Scenic and install Scenic from there. It is an “editable install”, so if you later update the repository with git pull or make changes to the code yourself, you won’t need to reinstall Scenic.\n\ngit clone https://github.com/BerkeleyLearnVerify/Scenic\ncd Scenic\npython -m pip install -e .\n\n\nIf you will be developing Scenic, you will want to use a variant of the last command to install additional development dependencies: see Developing Scenic.\n\nYou can now verify that Scenic is properly installed by running the command:\n\nscenic --version\n\n\nThis should print out a message like Scenic 3.0.0 showing which version of Scenic is installed. If you get an error (or got one earlier when following the instructions above), please see our Notes on Installing Scenic for suggestions.\n\nNote\n\nIf a feature described in this documentation seems to be missing, your version of Scenic may be too old: take a look at What’s New in Scenic to see when the feature was added.\n\nTo help read Scenic code, we suggest you install a syntax highlighter plugin for your text editor. Plugins for Sublime Text and Visual Studio Code can be installed from within those tools; for other editors supporting the TextMate grammar format, the grammar is available here.\n\nTrying Some Examples\n\nThe Scenic repository contains many example scenarios, found in the examples directory. They are organized in various directories with the name of the simulator, abstract application domain, or visualizer they are written for. For example, gta and webots for the GTA and Webots simulators; the driving directory for the abstract driving domain; and the visualizer directory for the built in Scenic visualizer.\n\nEach simulator has a specialized Scenic interface which requires additional setup (see Supported Simulators); however, for convenience Scenic provides an easy way to visualize scenarios without running a simulator. Simply run scenic, giving a path to a Scenic file:\n\nscenic examples/webots/vacuum/vacuum_simple.scenic\n\n\nThis will compile the Scenic program and sample from it (which may take several seconds), displaying a schematic of the resulting scene. Since this is a simple scenario designed to evaluate the performance of a robot vacuum, you should get something like this:\n\nThe green cylinder is the vacuum, surrounded by various pieces of furniture in a room. You can adjust the camera angle by clicking and dragging, and zoom in and out using the mouse wheel. If you close the window or press q, Scenic will sample another scene from the same scenario and display it. This will repeat until you kill the generator (Control-c in the terminal on Linux; Command-q in the viewer window on MacOS).\n\nSome scenarios were written for older versions of Scenic, which were entirely 2D. Those scenarios should be run using the --2d command-line option, which will enable 2D backwards-compatibility mode. Information about whether or not the --2d flag should be used can be found in the README of each example directory.\n\nOne such scenario is the badly-parked car example from our GTA case study, which can be run with the following command:\n\nscenic --2d examples/gta/badlyParkedCar2.scenic\n\n\nThis will open Scenic’s 2D viewer, and should look something like this:\n\nHere the circled rectangle is the ego car; its view cone extends to the right, where we see another car parked rather poorly at the side of the road (the white lines are curbs). (Note that on MacOS, scene generation with the 2D viewer is stopped differently than with the 3D viewer: right-click on its icon in the Dock and select Quit.)\n\nScenarios for the other simulators can be viewed in the same way. Here are a few for different simulators:\n\nscenic --2d examples/driving/pedestrian.scenic\nscenic examples/webots/mars/narrowGoal.scenic\nscenic --2d examples/webots/road/crossing.scenic\n\n  \n\nThe scenic command has options for setting the random seed, running dynamic simulations, printing debugging information, etc.: see Command-Line Options.\n\nLearning More\n\nDepending on what you’d like to do with Scenic, different parts of the documentation may be helpful:\n\nIf you want to start learning how to write Scenic programs, see Scenic Fundamentals.\n\nIf you want to learn how to write dynamic scenarios in Scenic, see Dynamic Scenarios.\n\nIf you want to use Scenic with a simulator, see Supported Simulators (which also describes how to interface Scenic to a new simulator, if the one you want isn’t listed).\n\nIf you want to control Scenic from Python rather than using the command-line tool (for example if you want to collect data from the generated scenarios), see Using Scenic Programmatically.\n\nIf you want to add a feature to the language or otherwise need to understand Scenic’s inner workings, see our pages on Developing Scenic and Scenic Internals.\n\nIf you can’t find something in the documentation, or have any question about Scenic, feel free to post on our community forum.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "What’s New in Scenic — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/new.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\nScenic 3.x\nScenic 2.x\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n What’s New in Scenic\n Edit on GitHub\nWhat’s New in Scenic\n\nThis page describes what new features have been added in each version of Scenic, as well as any syntax changes which break backwards compatibility. Scenic uses semantic versioning, so a program written for Scenic 2.1 should also work in Scenic 2.5, but not necessarily in Scenic 3.0. You can run scenic --version to see which version of Scenic you are using.\n\nScenic 3.x\n\nThe Scenic 3.x series adds native support for 3D geometry, precise modeling of the shapes of objects, and temporal requirements. It also features a new parser enabling clearer error messages, greater language extensibility, and various improvements to the syntax.\n\nSee Porting to Scenic 3 for tools to help migrate existing 2D scenarios.\n\nScenic 3.0.0\n\nBackwards-incompatible syntax changes:\n\nObjects must be explicitly created using the new keyword, e.g. new Object at (1, 2) instead of the old Object at (1, 2). This removes an ambiguity in the Scenic grammar, and makes non-creation uses of class names like myClasses = [Car, Bicycle, Pedestrian] clearer.\n\nMonitor definitions must include a parenthesized list of arguments, like behaviors: you should write monitor MyMonitor(): for example instead of the old monitor MyMonitor:. Furthermore, monitors are no longer automatically enforced in the scenario where they are defined: you must explicitly instantiate them with the new require monitor statement.\n\nAs the heading property is now derived from the 3D orientation (see below), it can no longer be set directly. Classes providing a default value for heading should instead provide a default value for parentOrientation. Code like with heading 30 deg should be replaced with the more idiomatic facing 30 deg.\n\nBackwards-incompatible semantics changes:\n\nObjects are no longer required to be visible from the ego by default. (The requireVisible property is now False by default.)\n\nVisibility checks take occlusion into account by default (see below). The visible regions of objects are now 3D regions.\n\nChecking containment of objects in regions is now precise (previously, Scenic only checked if all of the corners of the object were contained in the region).\n\nWhile evaluating a precondition or invariant of a behavior or scenario, code that would cause the simulation to be rejected (such as sampling from an empty list) is now considered as simply making the precondition/invariant false.\n\nThe left of Object specifier and its variants now correctly take into account the dimensions of both the object being created and the given object (the implementation previously did not account for the latter, despite the documentation saying otherwise).\n\nThe offset by specifier now optionally specifies parentOrientation.\n\nThe visible and not visible specifiers now take into account occlusion and the shapes of objects. In previous versions, they only checked whether the center of the object was visible/not visible, ignoring occlusion.\n\nBackwards-incompatible API changes:\n\nThe maxIterations argument of Simulator.simulate now has default value 1, rather than 100. A default value of 1 is the most reasonable in general since it means that when a simulation is rejected, a new scene will have to be generated (instead of trying many simulations from the same starting scene, which might well fail in the same way).\n\nFor simulator interface writers: the Simulator.createSimulation and Simulation APIs have changed; initial creation of objects is now done automatically, and other initialization must be done in the new Simulation.setup method. See scenic.core.simulators for details.\n\nMajor new features:\n\nScenic uses 3D geometry. Vectors now have 3 coordinates: if a third coordinate is not provided, it is assumed to be zero, so that scenarios taking place entirely in the z=0 plane will continue to work as before. Orientations of objects in space are represented by a new orientation property (internally a quaternion), which is computed by applying intrinsic yaw, pitch, and roll rotations, given by new properties by those names. These rotations are applied to the object’s parentOrientation, which by default aligns with the Scenic global coordinate system but is optionally specified by left of and similar specifiers; this makes it easy to orient an object with respect to another object. See the relevant section of the tutorial for examples.\n\nScenic models the precise shapes of objects, rather than simply using bounding boxes for collision detection and visibility checks. Objects have a new shape property (an instance of the Shape class) representing their shape; shapes can be created from standard 3D mesh formats such as STL.\n\nVisibility checks now take occlusion into account as well as precise shapes of objects. This is done using raytracing: the number of rays can be controlled on a per-object basis using viewRayDensity and related properties.\n\nThe require statement accepts arbitrary properties in Linear Temporal Logic (not just the require always and require eventually forms previously allowed).\n\nSampled Scene objects can now be serialized to short sequences of bytes and restored later. Similarly, executed Simulation objects can be saved and replayed. See Storing Scenes/Simulations for Later Use for details.\n\nScenic syntax highlighters for Sublime Text, Visual Studio Code, and other TextMate-compatible editors are now available: see Getting Started with Scenic. For users of Pygments, the scenic package automatically installs a Pygments lexer (and associated style) for Scenic.\n\nMinor new features:\n\nIt is no longer necessary to define an ego object. If no ego is defined, the egoObject attribute of a sampled Scene is None.\n\nSyntax errors should now always indicate the correct part of the source code.\n\nScenic 2.x\n\nThe Scenic 2.x series is a major new version of Scenic which adds native support for dynamic scenarios, scenario composition, and more.\n\nScenic 2.1.0\n\nMajor new features:\n\nModular scenarios and ways to compose them together, introduced as a prototype in 2.0.0, are now finalized, with many fixes and improvements. See Composing Scenarios for an overview of the new syntax.\n\nThe record statement for recording values at every step of dynamic simulations (or only at the start/end).\n\nA built-in Newtonian physics simulator for debugging dynamic scenarios without having to install an external simulator (see scenic.simulators.newtonian).\n\nThe interface to the Webots simulator has been greatly generalized, and now supports dynamic scenarios (see scenic.simulators.webots).\n\nMinor new features:\n\nYou can now write require expr as name to give a name to a requirement; similarly for require always, termination conditions, etc.\n\nCompatibility with Python 3.7 is restored. Scenic 2 now supports all versions of Python from 3.7 to 3.11.\n\nScenic 2.0.0\n\nBackwards-incompatible syntax changes:\n\nThe interval notation (low, high) for uniform distributions has been removed: use Range(low, high) instead. As a result of this change, the usual Python syntax for tuples is now legal in Scenic.\n\nThe height property of Object, measuring its extent along the Y axis, has been renamed length to better match its intended use. The name height will be used again in a future version of Scenic with native support for 3D geometry.\n\nMajor new features:\n\nScenic now supports writing and executing dynamic scenarios, where agents take actions over time according to behaviors specified in Scenic. See Dynamic Scenarios for an overview of the new syntax.\n\nAn abstract Driving Domain allowing traffic scenarios to be written in a platform-agnostic way and executed in multiple simulators (in particular, both CARLA and LGSVL). This library includes functionality to parse road networks from standard formats (currently OpenDRIVE) and expose information about them for use in Scenic scenarios.\n\nA much generalized and improved interface to CARLA. (Many thanks to the CARLA team for contributing this.)\n\nAn interface to the LGSVL driving simulator. (Many thanks to the LG team for helping develop this interface.)\n\nMinor new features:\n\nOperators and specifiers which take vectors as arguments will now accept tuples and lists of length 2; for example, you can write Object at (1, 2). The old syntax Object at 1@2 is still supported.\n\nThe model statement allows a scenario to specify which world model it uses, while being possible to override from the command line with the --model option.\n\nGlobal parameters can be overridden from the command line using the --param option (e.g. to specify a different map to use for a scenario).\n\nThe unpacking operator * can now be used with Uniform to select a random element of a random list/tuple (e.g. lane = Uniform(*network.lanes); sec = Uniform(*lane.sections)).\n\nThe Python built-in function filter is now supported, and can be used along with unpacking as above to select a random element of a random list satisfying a given condition (see filter for an example).\n\n(Many other minor features didn’t make it into this list.)\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Notes on Installing Scenic — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/install_notes.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nAll Platforms\nMacOS\nWindows\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Notes on Installing Scenic\n Edit on GitHub\nNotes on Installing Scenic\n\nThis page describes common issues with installing Scenic and suggestions for fixing them.\n\nAll Platforms\nMissing Python Version\n\nIf when running pip you get an error saying that your machine does not have a compatible version, this means that you do not have Python 3.8 or later on your PATH. Install a newer version of Python, either directly from the Python website or using pyenv (e.g. running pyenv install 3.10.4). Then use that version of Python when creating a virtual environment before installing Scenic.\n\n“setup.py” not found\n\nThis error indicates that you are using too old a version of pip: you need at least version 21.3. Run python -m pip install --upgrade pip to upgrade.\n\nDependency Conflicts\n\nIf you install Scenic using pip, you might see an error message like the following:\n\nERROR: pip’s dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.\n\nThis error means that in order to install Scenic, pip had to break the dependency constraints of some package you had previously installed (the error message will indicate which one). So while Scenic will work correctly, something else may now be broken. This won’t happen if you install Scenic into a fresh virtual environment.\n\nCannot Find Scenic\n\nIf when running the scenic command you get a “command not found” error, or when trying to import the scenic module you get a ModuleNotFoundError, then Scenic has not been installed where your shell or Python respectively can find it. The most likely problem is that you installed Scenic for one copy of Python but are now using a different one: for example, if you installed Scenic in a Python virtual environment (which we highly recommend), you may have forgotten to activate that environment, and so are using your system Python instead. See the virtual environment tutorial for instructions.\n\nScene Schematics Don’t Appear (2D)\n\nIf no window appears when you ask Scenic to generate and display a scene using the --2d flag (as in the example commands in Getting Started with Scenic), this means that Matplotlib has no interactive backend installed. On Linux, try installing the python3-tk package (e.g. sudo apt-get install python3-tk).\n\nMissing SDL\n\nIf you get an error about SDL being missing, you may need to install it. On Linux (or Windows with WSL), install the libsdl2-dev package (e.g. sudo apt-get install libsdl2-dev); on macOS, if you use Homebrew you can run brew install sdl2. For other platforms, see the SDL website.\n\nUsing a Local Scenic Version with VerifAI\n\nIf you are using Scenic as part of the VerifAI toolkit, the VerifAI installation process will automatically install Scenic from PyPI. However, if you need to use your own fork of Scenic or some features which have not yet been released on PyPI, you will need to install Scenic manually in VerifAI’s virtual environment. The easiest way to do this is as follows:\n\nInstall VerifAI in a virtual environment of your choice.\n\nActivate the virtual environment.\n\nChange directory to your clone of the Scenic repository.\n\nRun pip install -e .\n\nYou can test that this process has worked correctly by going back to the VerifAI repo and running the Scenic part of its test suite with pytest tests/test_scenic.py.\n\nNote\n\nInstalling Scenic in this way bypasses dependency resolution for VerifAI. If your local version of Scenic requires different versions of some of VerifAI’s dependencies, you may get errors from pip about dependency conflicts. Such errors do not actually prevent Scenic from being installed; however you may get unexpected behavior from VerifAI at runtime. If you are developing forks of Scenic and VerifAI, a more stable approach would be to modify VerifAI’s pyproject.toml to point to your fork of Scenic instead of the scenic package on PyPI.\n\nMacOS\nInstalling python-fcl on Apple silicon\n\nIf on an Apple-silicon machine you get an error related to pip being unable to install python-fcl, it can be installed manually using the following steps:\n\nClone the python-fcl repository.\n\nNavigate to the repository.\n\nInstall dependencies using Homebrew with the following command: brew install fcl eigen octomap\n\nActivate your virtual environment if you haven’t already.\n\nInstall the package using pip with the following command: CPATH=$(brew --prefix)/include:$(brew --prefix)/include/eigen3 LD_LIBRARY_PATH=$(brew --prefix)/lib python -m pip install .\n\nWindows\nUsing WSL\n\nFor greatest ease of installation, we recommend using the Windows Subsystem for Linux (WSL, a.k.a. “Bash on Windows”) on Windows 10 and newer.\n\nSome WSL users have reported encountering the error no display name and no $DISPLAY environmental variable, but have had success applying the techniques outlined here.\n\nIt is possible to run Scenic natively on Windows; however, in the past there have been issues with some of Scenic’s dependencies either not providing wheels for Windows or requiring manual installation of additional libraries.\n\nProblems building Shapely\n\nIn the past, the shapely package did not install properly on Windows. If you encounter this issue, try installing it manually following the instructions here.\n\n Previous\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  },
  {
    "title": "Welcome to Scenic’s documentation! — Scenic documentation",
    "url": "https://docs.scenic-lang.org/en/latest/index.html",
    "html": "latest\n\nINTRODUCTION\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTUTORIALS\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLANGUAGE AND TOOL REFERENCE\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLIBRARIES AND SIMULATORS\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGENERAL INFORMATION\n\nPublications Using Scenic\nCredits\n Welcome to Scenic’s documentation!\n Edit on GitHub\nWelcome to Scenic’s documentation!\n\nScenic is a domain-specific probabilistic programming language for modeling the environments of cyber-physical systems like robots and autonomous cars. A Scenic program defines a distribution over scenes, configurations of physical objects and agents; sampling from this distribution yields concrete scenes which can be simulated to produce training or testing data. Scenic can also define (probabilistic) policies for dynamic agents, allowing modeling scenarios where agents take actions over time in response to the state of the world.\n\nScenic was designed and implemented by Daniel J. Fremont, Eric Vin, Edward Kim, Tommaso Dreossi, Shromona Ghosh, Xiangyu Yue, Alberto L. Sangiovanni-Vincentelli, and Sanjit A. Seshia, with contributions from many others. For a description of the language and some of its applications, see our journal paper on Scenic 2, which extends our PLDI 2019 paper on Scenic 1; the new features in Scenic 3 are described in our CAV 2023 paper. Our publications page lists additional papers using Scenic.\n\nNote\n\nThe syntax of Scenic 3 is not completely backwards-compatible with earlier versions of Scenic, which were used in our papers prior to 2023. See What’s New in Scenic for a list of syntax changes and new features. Old code can likely be easily ported; you can also install older releases if necessary from GitHub.\n\nIf you have any problems using Scenic, please submit an issue to our GitHub repository or ask a question on our community forum.\n\nTable of Contents\n\nIntroduction\n\nGetting Started with Scenic\nNotes on Installing Scenic\nWhat’s New in Scenic\n\nTutorials\n\nScenic Fundamentals\nDynamic Scenarios\nComposing Scenarios\n\nLanguage and Tool Reference\n\nSyntax Guide\nLanguage Reference\nCommand-Line Options\nUsing Scenic Programmatically\nDeveloping Scenic\nScenic Internals\n\nLibraries and Simulators\n\nScenic Libraries\nSupported Simulators\nInterfacing to New Simulators\n\nGeneral Information\n\nPublications Using Scenic\nCredits\nIndices and Tables\n\nIndex\n\nModule Index\n\nGlossary\n\nLicense\n\nScenic is distributed under the 3-Clause BSD License.\n\nNext \n\n© Copyright 2020-2024, Daniel J. Fremont. Revision d7679fb8.\n\nBuilt with Sphinx using a theme provided by Read the Docs.\n Read the Docs\nv: latest "
  }
]